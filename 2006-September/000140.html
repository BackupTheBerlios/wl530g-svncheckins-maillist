<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Wl530g-svncheckins] r354 - in trunk/Marvell/Src/uClinux-dist: .	lzma lzma/C lzma/C/7zip lzma/C/7zip/Archive	lzma/C/7zip/Archive/7z_C lzma/C/7zip/Common	lzma/C/7zip/Compress lzma/C/7zip/Compress/Branch	lzma/C/7zip/Compress/LZ lzma/C/7zip/Compress/LZ/BinTree	lzma/C/7zip/Compress/LZ/HashChain lzma/C/7zip/Compress/LZMA	lzma/C/7zip/Compress/LZMA_Alone lzma/C/7zip/Compress/LZMA_C	lzma/C/7zip/Compress/RangeCoder lzma/C/Common lzma/C/Windows	lzma/CS lzma/CS/7zip lzma/CS/7zip/Common	lzma/CS/7zip/Compress lzma/CS/7zip/Compress/LZ	lzma/CS/7zip/Compress/LZMA lzma/CS/7zip/Compress/LzmaAlone	lzma/CS/7zip/Compress/LzmaAlone/Properties	lzma/CS/7zip/Compress/RangeCoder lzma/Java lzma/Java/SevenZip	lzma/Java/SevenZip/Compression lzma/Java/SevenZip/Compression/LZ	lzma/Java/SevenZip/Compression/LZMA	lzma/Java/SevenZip/Compression/RangeCoder
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/wl530g-svncheckins/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:wl530g-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BWl530g-svncheckins%5D%20r354%20-%20in%20trunk/Marvell/Src/uClinux-dist%3A%20.%0A%09lzma%20lzma/C%20lzma/C/7zip%20lzma/C/7zip/Archive%0A%09lzma/C/7zip/Archive/7z_C%20lzma/C/7zip/Common%0A%09lzma/C/7zip/Compress%20lzma/C/7zip/Compress/Branch%0A%09lzma/C/7zip/Compress/LZ%20lzma/C/7zip/Compress/LZ/BinTree%0A%09lzma/C/7zip/Compress/LZ/HashChain%20lzma/C/7zip/Compress/LZMA%0A%09lzma/C/7zip/Compress/LZMA_Alone%20lzma/C/7zip/Compress/LZMA_C%0A%09lzma/C/7zip/Compress/RangeCoder%20lzma/C/Common%20lzma/C/Windows%0A%09lzma/CS%20lzma/CS/7zip%20lzma/CS/7zip/Common%0A%09lzma/CS/7zip/Compress%20lzma/CS/7zip/Compress/LZ%0A%09lzma/CS/7zip/Compress/LZMA%20lzma/CS/7zip/Compress/LzmaAlone%0A%09lzma/CS/7zip/Compress/LzmaAlone/Properties%0A%09lzma/CS/7zip/Compress/RangeCoder%20lzma/Java%20lzma/Java/SevenZip%0A%09lzma/Java/SevenZip/Compression%20lzma/Java/SevenZip/Compression/LZ%0A%09lzma/Java/SevenZip/Compression/LZMA%0A%09lzma/Java/SevenZip/Compression/RangeCoder&In-Reply-To=%3C200609221743.k8MHhVwE005776%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000139.html">
   <LINK REL="Next"  HREF="000141.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Wl530g-svncheckins] r354 - in trunk/Marvell/Src/uClinux-dist: .	lzma lzma/C lzma/C/7zip lzma/C/7zip/Archive	lzma/C/7zip/Archive/7z_C lzma/C/7zip/Common	lzma/C/7zip/Compress lzma/C/7zip/Compress/Branch	lzma/C/7zip/Compress/LZ lzma/C/7zip/Compress/LZ/BinTree	lzma/C/7zip/Compress/LZ/HashChain lzma/C/7zip/Compress/LZMA	lzma/C/7zip/Compress/LZMA_Alone lzma/C/7zip/Compress/LZMA_C	lzma/C/7zip/Compress/RangeCoder lzma/C/Common lzma/C/Windows	lzma/CS lzma/CS/7zip lzma/CS/7zip/Common	lzma/CS/7zip/Compress lzma/CS/7zip/Compress/LZ	lzma/CS/7zip/Compress/LZMA lzma/CS/7zip/Compress/LzmaAlone	lzma/CS/7zip/Compress/LzmaAlone/Properties	lzma/CS/7zip/Compress/RangeCoder lzma/Java lzma/Java/SevenZip	lzma/Java/SevenZip/Compression lzma/Java/SevenZip/Compression/LZ	lzma/Java/SevenZip/Compression/LZMA	lzma/Java/SevenZip/Compression/RangeCoder</H1>
    <B>jcollake at mail.berlios.de</B> 
    <A HREF="mailto:wl530g-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BWl530g-svncheckins%5D%20r354%20-%20in%20trunk/Marvell/Src/uClinux-dist%3A%20.%0A%09lzma%20lzma/C%20lzma/C/7zip%20lzma/C/7zip/Archive%0A%09lzma/C/7zip/Archive/7z_C%20lzma/C/7zip/Common%0A%09lzma/C/7zip/Compress%20lzma/C/7zip/Compress/Branch%0A%09lzma/C/7zip/Compress/LZ%20lzma/C/7zip/Compress/LZ/BinTree%0A%09lzma/C/7zip/Compress/LZ/HashChain%20lzma/C/7zip/Compress/LZMA%0A%09lzma/C/7zip/Compress/LZMA_Alone%20lzma/C/7zip/Compress/LZMA_C%0A%09lzma/C/7zip/Compress/RangeCoder%20lzma/C/Common%20lzma/C/Windows%0A%09lzma/CS%20lzma/CS/7zip%20lzma/CS/7zip/Common%0A%09lzma/CS/7zip/Compress%20lzma/CS/7zip/Compress/LZ%0A%09lzma/CS/7zip/Compress/LZMA%20lzma/CS/7zip/Compress/LzmaAlone%0A%09lzma/CS/7zip/Compress/LzmaAlone/Properties%0A%09lzma/CS/7zip/Compress/RangeCoder%20lzma/Java%20lzma/Java/SevenZip%0A%09lzma/Java/SevenZip/Compression%20lzma/Java/SevenZip/Compression/LZ%0A%09lzma/Java/SevenZip/Compression/LZMA%0A%09lzma/Java/SevenZip/Compression/RangeCoder&In-Reply-To=%3C200609221743.k8MHhVwE005776%40sheep.berlios.de%3E"
       TITLE="[Wl530g-svncheckins] r354 - in trunk/Marvell/Src/uClinux-dist: .	lzma lzma/C lzma/C/7zip lzma/C/7zip/Archive	lzma/C/7zip/Archive/7z_C lzma/C/7zip/Common	lzma/C/7zip/Compress lzma/C/7zip/Compress/Branch	lzma/C/7zip/Compress/LZ lzma/C/7zip/Compress/LZ/BinTree	lzma/C/7zip/Compress/LZ/HashChain lzma/C/7zip/Compress/LZMA	lzma/C/7zip/Compress/LZMA_Alone lzma/C/7zip/Compress/LZMA_C	lzma/C/7zip/Compress/RangeCoder lzma/C/Common lzma/C/Windows	lzma/CS lzma/CS/7zip lzma/CS/7zip/Common	lzma/CS/7zip/Compress lzma/CS/7zip/Compress/LZ	lzma/CS/7zip/Compress/LZMA lzma/CS/7zip/Compress/LzmaAlone	lzma/CS/7zip/Compress/LzmaAlone/Properties	lzma/CS/7zip/Compress/RangeCoder lzma/Java lzma/Java/SevenZip	lzma/Java/SevenZip/Compression lzma/Java/SevenZip/Compression/LZ	lzma/Java/SevenZip/Compression/LZMA	lzma/Java/SevenZip/Compression/RangeCoder">jcollake at mail.berlios.de
       </A><BR>
    <I>Fri Sep 22 19:43:31 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000139.html">[Wl530g-svncheckins] r353 - in	trunk/Marvell/Src/uClinux-dist/linux-2.4.x:	arch/armnommu/boot/compressed lib
</A></li>
        <LI>Next message: <A HREF="000141.html">[Wl530g-svncheckins] r355 - trunk/Marvell/Src/uClinux-dist/lzma
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#140">[ date ]</a>
              <a href="thread.html#140">[ thread ]</a>
              <a href="subject.html#140">[ subject ]</a>
              <a href="author.html#140">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jcollake
Date: 2006-09-22 19:40:29 +0200 (Fri, 22 Sep 2006)
New Revision: 354

Added:
   trunk/Marvell/Src/uClinux-dist/lzma/
   trunk/Marvell/Src/uClinux-dist/lzma/7zC.txt
   trunk/Marvell/Src/uClinux-dist/lzma/7zFormat.txt
   trunk/Marvell/Src/uClinux-dist/lzma/C/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMain.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zTypes.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsw
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile.gcc
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StdAfx.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchTypes.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/StdAfx.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree2.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3Z.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree4.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTreeMain.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC2.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC3.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC4.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HCMain.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/IMatchFinder.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/StdAfx.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMA.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/StdAfx.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile.gcc
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateTest.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTest.c
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTypes.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile.gcc
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoder.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderOpt.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/StdAfx.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/ICoder.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/IStream.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/ComTry.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Defs.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyCom.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyGuidDef.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyInitGuid.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyUnknown.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyWindows.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StdAfx.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Types.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/
   trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/Defs.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.cpp
   trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.h
   trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/StdAfx.h
   trunk/Marvell/Src/uClinux-dist/lzma/CPL.html
   trunk/Marvell/Src/uClinux-dist/lzma/CS/
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CRC.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CommandLineParser.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/InBuffer.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/OutBuffer.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/IMatchFinder.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzBinTree.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzInWindow.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzOutWindow.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaBase.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaDecoder.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaEncoder.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.csproj
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.sln
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaBench.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/AssemblyInfo.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Resources.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Settings.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoder.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBit.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBitTree.cs
   trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/ICoder.cs
   trunk/Marvell/Src/uClinux-dist/lzma/Java/
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/CRC.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/ICodeProgress.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/BinTree.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/InWindow.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/OutWindow.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Base.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Decoder.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Encoder.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeDecoder.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeEncoder.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Decoder.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Encoder.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/ICodeProgress.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaAlone.java
   trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaBench.java
   trunk/Marvell/Src/uClinux-dist/lzma/LGPL.txt
   trunk/Marvell/Src/uClinux-dist/lzma/Methods.txt
   trunk/Marvell/Src/uClinux-dist/lzma/history.txt
   trunk/Marvell/Src/uClinux-dist/lzma/lzma.exe
   trunk/Marvell/Src/uClinux-dist/lzma/lzma.txt
Log:
lzma code - preparing to use lzma instead of gzip for kernel compression

Added: trunk/Marvell/Src/uClinux-dist/lzma/7zC.txt
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/7zC.txt	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/7zC.txt	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,235 @@
+7z ANSI-C Decoder 4.43
+----------------------
+
+7z ANSI-C Decoder 4.43 Copyright (C) 1999-2006 Igor Pavlov
+
+7z ANSI-C provides 7z/LZMA decoding.
+7z ANSI-C version is simplified version ported from C++ code.
+
+LZMA is default and general compression method of 7z format
+in 7-Zip compression program (www.7-zip.org). LZMA provides high 
+compression ratio and very fast decompression.
+
+
+LICENSE
+-------
+
+Read lzma.txt for information about license.
+
+
+Files
+---------------------
+
+7zAlloc.*    - Allocate and Free
+7zBuffer.*   - Buffer structure
+7zCrc.*      - CRC32 code
+7zDecode.*   - Low level memory-&gt;memory decoding
+7zExtract.*  - High level stream-&gt;memory decoding
+7zHeader.*   - .7z format constants
+7zIn.*       - .7z archive opening
+7zItem.*     - .7z structures
+7zMain.c     - Test application
+7zMethodID.* - MethodID structure
+7zTypes.h    - Base types and constants
+
+
+How To Use
+----------
+
+You must download 7-Zip program from www.7-zip.org.
+
+You can create .7z archive with 7z.exe or 7za.exe:
+
+  7za.exe a archive.7z *.htm -r -mx -m0fb=255 -mf=off
+
+If you have big number of files in archive, and you need fast extracting, 
+you can use partly-solid archives:
+  
+  7za.exe a archive.7z *.htm -ms=512K -r -mx -m0fb=255 -m0d=512K -mf=off
+
+In that example 7-Zip will use 512KB solid blocks. So it needs to decompress only 
+512KB for extracting one file from such archive.
+
+
+Limitations of current version of 7z ANSI-C Decoder
+---------------------------------------------------
+
+ - It reads only &quot;FileName&quot;, &quot;Size&quot;, and &quot;CRC&quot; information for each file in archive.
+ - It supports only LZMA and Copy (no compression) methods.
+ - It converts original UTF-16 Unicode file names to UTF-8 Unicode file names.
+ 
+These limitations will be fixed in future versions.
+
+
+Using 7z ANSI-C Decoder Test application:
+-----------------------------------------
+
+Usage: 7zDec &lt;command&gt; &lt;archive_name&gt;
+
+&lt;Command&gt;:
+  e: Extract files from archive
+  l: List contents of archive
+  t: Test integrity of archive
+
+Example: 
+
+  7zDec l archive.7z
+
+lists contents of archive.7z
+
+  7zDec e archive.7z
+
+extracts files from archive.7z to current folder.
+
+
+How to use .7z Decoder
+----------------------
+
+.7z Decoder can be compiled in one of two modes:
+
+1) Default mode. In that mode 7z Decoder will read full compressed 
+   block to RAM before decompressing.
+  
+2) Mode with defined _LZMA_IN_CB. In that mode 7z Decoder can read
+   compressed block by parts. And you can specify desired buffer size. 
+   So memory requirements can be reduced. But decompressing speed will 
+   be 5-10% lower and code size is slightly larger.
+
+   
+Memory allocation
+~~~~~~~~~~~~~~~~~
+
+7z Decoder uses two memory pools:
+1) Temporary pool
+2) Main pool
+Such scheme can allow you to avoid fragmentation of allocated blocks.
+
+Steps for using 7z decoder
+--------------------------
+
+Use code at 7zMain.c as example.
+
+1) Declare variables:
+  inStream                     /* implements ISzInStream interface */
+  CArchiveDatabaseEx db;       /* 7z archive database structure */
+  ISzAlloc allocImp;           /* memory functions for main pool */
+  ISzAlloc allocTempImp;       /* memory functions for temporary pool */
+
+2) call InitCrcTable(); function to initialize CRC structures.
+
+3) call SzArDbExInit(&amp;db); function to initialize db structures.
+
+4) call SzArchiveOpen(inStream, &amp;db, &amp;allocMain, &amp;allocTemp) to open archive
+
+This function opens archive &quot;inStream&quot; and reads headers to &quot;db&quot;.
+All items in &quot;db&quot; will be allocated with &quot;allocMain&quot; functions.
+SzArchiveOpen function allocates and frees temporary structures by &quot;allocTemp&quot; functions.
+
+5) List items or Extract items
+
+  Listing code:
+  ~~~~~~~~~~~~~
+    {
+      UInt32 i;
+      for (i = 0; i &lt; db.Database.NumFiles; i++)
+      {
+        CFileItem *f = db.Database.Files + i;
+        printf(&quot;%10d  %s\n&quot;, (int)f-&gt;Size, f-&gt;Name);
+      }
+    }
+
+  Extracting code:
+  ~~~~~~~~~~~~~~~~
+
+  SZ_RESULT SzExtract(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    UInt32 fileIndex,         /* index of file */
+    UInt32 *blockIndex,       /* index of solid block */
+    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    size_t *outBufferSize,    /* buffer size for output buffer */
+    size_t *offset,           /* offset of stream for required file in *outBuffer */
+    size_t *outSizeProcessed, /* size of file in *outBuffer */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp);
+
+  If you need to decompress more than one file, you can send these values from previous call:
+    blockIndex, 
+    outBuffer, 
+    outBufferSize,
+  You can consider &quot;outBuffer&quot; as cache of solid block. If your archive is solid, 
+  it will increase decompression speed.
+
+  After decompressing you must free &quot;outBuffer&quot;:
+  allocImp.Free(outBuffer);
+
+6) call SzArDbExFree(&amp;db, allocImp.Free) to free allocated items in &quot;db&quot;.
+
+
+
+
+Memory requirements for .7z decoding 
+------------------------------------
+
+Memory usage for Archive opening:
+  - Temporary pool:
+     - Memory for compressed .7z headers (if _LZMA_IN_CB is not defined)
+     - Memory for uncompressed .7z headers
+     - some other temporary blocks
+  - Main pool:
+     - Memory for database: 
+       Estimated size of one file structures in solid archive:
+         - Size (4 or 8 Bytes)
+         - CRC32 (4 bytes)
+         - Some file information (4 bytes)
+         - File Name (variable length) + pointer + allocation structures
+
+Memory usage for archive Decompressing:
+  - Temporary pool:
+     - Memory for compressed solid block (if _LZMA_IN_CB is not defined)
+     - Memory for LZMA decompressing structures
+  - Main pool:
+     - Memory for decompressed solid block
+  
+
+If _LZMA_IN_CB is defined, 7z Decoder will not allocate memory for 
+compressed blocks. Instead of this, you must allocate buffer with desired 
+size before calling 7z Decoder. Use 7zMain.c as example.
+
+
+
+EXIT codes
+-----------
+
+7z Decoder functions can return one of the following codes:
+
+#define SZ_OK (0)
+#define SZE_DATA_ERROR (1)
+#define SZE_OUTOFMEMORY (2)
+#define SZE_CRC_ERROR (3)
+
+#define SZE_NOTIMPL (4)
+#define SZE_FAIL (5)
+
+#define SZE_ARCHIVE_ERROR (6)
+
+
+
+LZMA Defines
+------------
+
+_LZMA_IN_CB       - Use special callback mode for input stream to reduce memory requirements
+
+_SZ_FILE_SIZE_64  - define it if you need support for files larger than 4 GB
+_SZ_NO_INT_64     - define it if your compiler doesn't support long long int
+
+_LZMA_PROB32      - it can increase LZMA decompressing speed on some 32-bit CPUs.
+
+_SZ_ONE_DIRECTORY - define it if you want to locate all source files to one directory
+_SZ_ALLOC_DEBUG   - define it if you want to debug alloc/free operations to stderr.
+
+
+---
+
+<A HREF="http://www.7-zip.org">http://www.7-zip.org</A>
+<A HREF="http://www.7-zip.org/support.html">http://www.7-zip.org/support.html</A>


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/7zC.txt
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/7zFormat.txt
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/7zFormat.txt	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/7zFormat.txt	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,471 @@
+7z Format description (2.30 Beta 25)
+-----------------------------------
+
+This file contains description of 7z archive format. 
+7z archive can contain files compressed with any method.
+See &quot;Methods.txt&quot; for description for defined compressing methods.
+
+
+Format structure Overview
+-------------------------
+
+Some fields can be optional.
+
+Archive structure
+~~~~~~~~~~~~~~~~~  
+SignatureHeader
+[PackedStreams]
+[PackedStreamsForHeaders]
+[
+  Header 
+  or 
+  {
+    Packed Header
+    HeaderInfo
+  }
+]
+
+
+
+Header structure
+~~~~~~~~~~~~~~~~  
+{
+  ArchiveProperties
+  AdditionalStreams
+  {
+    PackInfo
+    {
+      PackPos
+      NumPackStreams
+      Sizes[NumPackStreams]
+      CRCs[NumPackStreams]
+    }
+    CodersInfo
+    {
+      NumFolders
+      Folders[NumFolders]
+      {
+        NumCoders
+        CodersInfo[NumCoders]
+        {
+          ID
+          NumInStreams;
+          NumOutStreams;
+          PropertiesSize
+          Properties[PropertiesSize]
+        }
+        NumBindPairs
+        BindPairsInfo[NumBindPairs]
+        {
+          InIndex;
+          OutIndex;
+        }
+        PackedIndices
+      }
+      UnPackSize[Folders][Folders.NumOutstreams]
+      CRCs[NumFolders]
+    }
+    SubStreamsInfo
+    {
+      NumUnPackStreamsInFolders[NumFolders];
+      UnPackSizes[]
+      CRCs[]
+    }
+  }
+  MainStreamsInfo
+  {
+    (Same as in AdditionalStreams)
+  }
+  FilesInfo
+  {
+    NumFiles
+    Properties[]
+    {
+      ID
+      Size
+      Data
+    }
+  }
+}
+
+HeaderInfo structure
+~~~~~~~~~~~~~~~~~~~~
+{
+  (Same as in AdditionalStreams)
+}
+
+
+
+Notes about Notation and encoding
+---------------------------------
+
+7z uses little endian encoding.
+
+7z archive format has optional headers that are marked as
+[]
+Header
+[]
+
+REAL_UINT64 means real UINT64.
+
+UINT64 means real UINT64 encoded with the following scheme:
+
+  Size of encoding sequence depends from first byte:
+  First_Byte  Extra_Bytes        Value
+  (binary)   
+  0xxxxxxx               : ( xxxxxxx           )
+  10xxxxxx    BYTE y[1]  : (  xxxxxx &lt;&lt; (8 * 1)) + y
+  110xxxxx    BYTE y[2]  : (   xxxxx &lt;&lt; (8 * 2)) + y
+  ...
+  1111110x    BYTE y[6]  : (       x &lt;&lt; (8 * 6)) + y
+  11111110    BYTE y[7]  :                         y
+  11111111    BYTE y[8]  :                         y
+
+
+
+Property IDs
+------------
+
+0x00 = kEnd,
+
+0x01 = kHeader,
+
+0x02 = kArchiveProperties,
+    
+0x03 = kAdditionalStreamsInfo,
+0x04 = kMainStreamsInfo,
+0x05 = kFilesInfo,
+    
+0x06 = kPackInfo,
+0x07 = kUnPackInfo,
+0x08 = kSubStreamsInfo,
+
+0x09 = kSize,
+0x0A = kCRC,
+
+0x0B = kFolder,
+
+0x0C = kCodersUnPackSize,
+0x0D = kNumUnPackStream,
+
+0x0E = kEmptyStream,
+0x0F = kEmptyFile,
+0x10 = kAnti,
+
+0x11 = kName,
+0x12 = kCreationTime,
+0x13 = kLastAccessTime,
+0x14 = kLastWriteTime,
+0x15 = kWinAttributes,
+0x16 = kComment,
+
+0x17 = kEncodedHeader,
+
+
+7z format headers
+-----------------
+
+SignatureHeader
+~~~~~~~~~~~~~~~
+  BYTE kSignature[6] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};
+
+  ArchiveVersion
+  {
+    BYTE Major;   // now = 0
+    BYTE Minor;   // now = 2
+  };
+
+  UINT32 StartHeaderCRC;
+
+  StartHeader
+  {
+    REAL_UINT64 NextHeaderOffset
+    REAL_UINT64 NextHeaderSize
+    UINT32 NextHeaderCRC
+  }
+
+
+...........................
+
+
+ArchiveProperties
+~~~~~~~~~~~~~~~~~
+BYTE NID::kArchiveProperties (0x02)
+while(true)
+{
+  BYTE PropertyType;
+  if (aType == 0)
+    break;
+  UINT64 PropertySize;
+  BYTE PropertyData[PropertySize];
+}
+
+
+Digests (NumStreams)
+~~~~~~~~~~~~~~~~~~~~~
+  BYTE AllAreDefined
+  if (AllAreDefined == 0)
+  {
+    for(NumStreams)
+      BIT Defined
+  }
+  UINT32 CRCs[NumDefined]
+
+
+PackInfo
+~~~~~~~~~~~~
+  BYTE NID::kPackInfo  (0x06)
+  UINT64 PackPos
+  UINT64 NumPackStreams
+
+  []
+  BYTE NID::kSize    (0x09)
+  UINT64 PackSizes[NumPackStreams]
+  []
+
+  []
+  BYTE NID::kCRC      (0x0A)
+  PackStreamDigests[NumPackStreams]
+  []
+
+  BYTE NID::kEnd
+
+
+Folder
+~~~~~~
+  UINT64 NumCoders;
+  for (NumCoders)
+  {
+    BYTE 
+    {
+      0:3 DecompressionMethod.IDSize
+      4:
+        0 - IsSimple
+        1 - Is not simple
+      5:
+        0 - No Attributes
+        1 - There Are Attributes
+      7:
+        0 - Last Method in Alternative_Method_List
+        1 - There are more alternative methods
+    } 
+    BYTE DecompressionMethod.ID[DecompressionMethod.IDSize]
+    if (!IsSimple)
+    {
+      UINT64 NumInStreams;
+      UINT64 NumOutStreams;
+    }
+    if (DecompressionMethod[0] != 0)
+    {
+      UINT64 PropertiesSize
+      BYTE Properties[PropertiesSize]
+    }
+  }
+    
+  NumBindPairs = NumOutStreamsTotal - 1;
+
+  for (NumBindPairs)
+  {
+    UINT64 InIndex;
+    UINT64 OutIndex;
+  }
+
+  NumPackedStreams = NumInStreamsTotal - NumBindPairs;
+  if (NumPackedStreams &gt; 1)
+    for(NumPackedStreams)
+    {
+      UINT64 Index;
+    };
+
+
+
+
+Coders Info
+~~~~~~~~~~~
+
+  BYTE NID::kUnPackInfo  (0x07)
+
+
+  BYTE NID::kFolder  (0x0B)
+  UINT64 NumFolders
+  BYTE External
+  switch(External)
+  {
+    case 0:
+      Folders[NumFolders]
+    case 1:
+      UINT64 DataStreamIndex
+  }
+
+
+  BYTE ID::kCodersUnPackSize  (0x0C)
+  for(Folders)
+    for(Folder.NumOutStreams)
+     UINT64 UnPackSize;
+
+
+  []
+  BYTE NID::kCRC   (0x0A)
+  UnPackDigests[NumFolders]
+  []
+
+  
+
+  BYTE NID::kEnd
+
+
+
+SubStreams Info
+~~~~~~~~~~~~~~
+  BYTE NID::kSubStreamsInfo; (0x08)
+
+  []
+  BYTE NID::kNumUnPackStream; (0x0D)
+  UINT64 NumUnPackStreamsInFolders[NumFolders];
+  []
+
+
+  []
+  BYTE NID::kSize  (0x09)
+  UINT64 UnPackSizes[]
+  []
+
+
+  []
+  BYTE NID::kCRC  (0x0A)
+  Digests[Number of streams with unknown CRC]
+  []
+
+  
+  BYTE NID::kEnd
+
+
+Streams Info
+~~~~~~~~~~~~
+
+  []
+  PackInfo
+  []
+
+
+  []
+  CodersInfo
+  []
+
+
+  []
+  SubStreamsInfo
+  []
+
+  BYTE NID::kEnd
+
+
+FilesInfo
+~~~~~~~~~
+  BYTE NID::kFilesInfo;  (0x05)
+  UINT64 NumFiles
+
+  while(true)
+  {
+    BYTE PropertyType;
+    if (aType == 0)
+      break;
+
+    UINT64 Size;
+
+    switch(PropertyType)
+    {
+      kEmptyStream:   (0x0E)
+        for(NumFiles)
+          BIT IsEmptyStream
+
+      kEmptyFile:     (0x0F)
+        for(EmptyStreams)
+          BIT IsEmptyFile
+
+      kAnti:          (0x10)
+        for(EmptyStreams)
+          BIT IsAntiFile
+      
+      case kCreationTime:   (0x12)
+      case kLastAccessTime: (0x13)
+      case kLastWriteTime:  (0x14)
+        BYTE AllAreDefined
+        if (AllAreDefined == 0)
+        {
+          for(NumFiles)
+            BIT TimeDefined
+        }
+        BYTE External;
+        if(External != 0)
+          UINT64 DataIndex
+        []
+        for(Definded Items)
+          UINT32 Time
+        []
+      
+      kNames:     (0x11)
+        BYTE External;
+        if(External != 0)
+          UINT64 DataIndex
+        []
+        for(Files)
+        {
+          wchar_t Names[NameSize];
+          wchar_t 0;
+        }
+        []
+
+      kAttributes:  (0x15)
+        BYTE AllAreDefined
+        if (AllAreDefined == 0)
+        {
+          for(NumFiles)
+            BIT AttributesAreDefined
+        }
+        BYTE External;
+        if(External != 0)
+          UINT64 DataIndex
+        []
+        for(Definded Attributes)
+          UINT32 Attributes
+        []
+    }
+  }
+
+
+Header
+~~~~~~
+  BYTE NID::kHeader (0x01)
+
+  []
+  ArchiveProperties
+  []
+
+  []
+  BYTE NID::kAdditionalStreamsInfo; (0x03)
+  StreamsInfo
+  []
+
+  []
+  BYTE NID::kMainStreamsInfo;    (0x04)
+  StreamsInfo
+  []
+
+  []
+  FilesInfo
+  []
+
+  BYTE NID::kEnd
+
+
+HeaderInfo
+~~~~~~~~~~
+  []
+  BYTE NID::kEncodedHeader; (0x17)
+  StreamsInfo for Encoded Header
+  []
+
+
+---
+End of document


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/7zFormat.txt
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,70 @@
+/* 7zAlloc.c */
+
+#include &lt;stdlib.h&gt;
+#include &quot;7zAlloc.h&quot;
+
+/* #define _SZ_ALLOC_DEBUG */
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+
+#ifdef _SZ_ALLOC_DEBUG
+
+#ifdef _WIN32
+#include &lt;windows.h&gt;
+#endif
+#include &lt;stdio.h&gt;
+int g_allocCount = 0;
+int g_allocCountTemp = 0;
+#endif
+
+void *SzAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount);
+  g_allocCount++;
+  #endif
+  return malloc(size);
+}
+
+void SzFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCount--;
+    fprintf(stderr, &quot;\nFree; count = %10d&quot;, g_allocCount);
+  }
+  #endif
+  free(address);
+}
+
+void *SzAllocTemp(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc_temp %10d bytes;  count = %10d&quot;, size, g_allocCountTemp);
+  g_allocCountTemp++;
+  #ifdef _WIN32
+  return HeapAlloc(GetProcessHeap(), 0, size);
+  #endif
+  #endif
+  return malloc(size);
+}
+
+void SzFreeTemp(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCountTemp--;
+    fprintf(stderr, &quot;\nFree_temp; count = %10d&quot;, g_allocCountTemp);
+  }
+  #ifdef _WIN32
+  HeapFree(GetProcessHeap(), 0, address);
+  return;
+  #endif
+  #endif
+  free(address);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,20 @@
+/* 7zAlloc.h */
+
+#ifndef __7Z_ALLOC_H
+#define __7Z_ALLOC_H
+
+#include &lt;stddef.h&gt;
+
+typedef struct _ISzAlloc
+{
+  void *(*Alloc)(size_t size);
+  void (*Free)(void *address); /* address can be 0 */
+} ISzAlloc;
+
+void *SzAlloc(size_t size);
+void SzFree(void *address);
+
+void *SzAllocTemp(size_t size);
+void SzFreeTemp(void *address);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zAlloc.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,29 @@
+/* 7zBuffer.c */
+
+#include &quot;7zBuffer.h&quot;
+#include &quot;7zAlloc.h&quot;
+
+void SzByteBufferInit(CSzByteBuffer *buffer)
+{
+  buffer-&gt;Capacity = 0;
+  buffer-&gt;Items = 0;
+}
+
+int SzByteBufferCreate(CSzByteBuffer *buffer, size_t newCapacity, void * (*allocFunc)(size_t size))
+{
+  buffer-&gt;Capacity = newCapacity;
+  if (newCapacity == 0)
+  {
+    buffer-&gt;Items = 0;
+    return 1;
+  }
+  buffer-&gt;Items = (Byte *)allocFunc(newCapacity);
+  return (buffer-&gt;Items != 0);
+}
+
+void SzByteBufferFree(CSzByteBuffer *buffer, void (*freeFunc)(void *))
+{
+  freeFunc(buffer-&gt;Items);
+  buffer-&gt;Items = 0;
+  buffer-&gt;Capacity = 0;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,19 @@
+/* 7zBuffer.h */
+
+#ifndef __7Z_BUFFER_H
+#define __7Z_BUFFER_H
+
+#include &lt;stddef.h&gt;
+#include &quot;7zTypes.h&quot;
+
+typedef struct _CSzByteBuffer
+{    
+	size_t Capacity;
+  Byte *Items;
+}CSzByteBuffer;
+
+void SzByteBufferInit(CSzByteBuffer *buffer);
+int SzByteBufferCreate(CSzByteBuffer *buffer, size_t newCapacity, void * (*allocFunc)(size_t size));
+void SzByteBufferFree(CSzByteBuffer *buffer, void (*freeFunc)(void *));
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zBuffer.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,76 @@
+/* 7zCrc.c */
+
+#include &quot;7zCrc.h&quot;
+
+#define kCrcPoly 0xEDB88320
+
+UInt32 g_CrcTable[256];
+
+void InitCrcTable()
+{
+  UInt32 i;
+  for (i = 0; i &lt; 256; i++)
+  {
+    UInt32 r = i;
+    int j;
+    for (j = 0; j &lt; 8; j++)
+      if (r &amp; 1) 
+        r = (r &gt;&gt; 1) ^ kCrcPoly;
+      else     
+        r &gt;&gt;= 1;
+    g_CrcTable[i] = r;
+  }
+}
+
+void CrcInit(UInt32 *crc) { *crc = 0xFFFFFFFF; }
+UInt32 CrcGetDigest(UInt32 *crc) { return *crc ^ 0xFFFFFFFF; } 
+
+void CrcUpdateByte(UInt32 *crc, Byte b)
+{
+  *crc = g_CrcTable[((Byte)(*crc)) ^ b] ^ (*crc &gt;&gt; 8);
+}
+
+void CrcUpdateUInt16(UInt32 *crc, UInt16 v)
+{
+  CrcUpdateByte(crc, (Byte)v);
+  CrcUpdateByte(crc, (Byte)(v &gt;&gt; 8));
+}
+
+void CrcUpdateUInt32(UInt32 *crc, UInt32 v)
+{
+  int i;
+  for (i = 0; i &lt; 4; i++)
+    CrcUpdateByte(crc, (Byte)(v &gt;&gt; (8 * i)));
+}
+
+void CrcUpdateUInt64(UInt32 *crc, UInt64 v)
+{
+  int i;
+  for (i = 0; i &lt; 8; i++)
+  {
+    CrcUpdateByte(crc, (Byte)(v));
+    v &gt;&gt;= 8;
+  }
+}
+
+void CrcUpdate(UInt32 *crc, const void *data, size_t size)
+{
+  UInt32 v = *crc;
+  const Byte *p = (const Byte *)data;
+  for (; size &gt; 0 ; size--, p++)
+    v = g_CrcTable[((Byte)(v)) ^ *p] ^ (v &gt;&gt; 8);
+  *crc = v;
+}
+
+UInt32 CrcCalculateDigest(const void *data, size_t size)
+{
+  UInt32 crc;
+  CrcInit(&amp;crc);
+  CrcUpdate(&amp;crc, data, size);
+  return CrcGetDigest(&amp;crc);
+}
+
+int CrcVerifyDigest(UInt32 digest, const void *data, size_t size)
+{
+  return (CrcCalculateDigest(data, size) == digest);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,24 @@
+/* 7zCrc.h */
+
+#ifndef __7Z_CRC_H
+#define __7Z_CRC_H
+
+#include &lt;stddef.h&gt;
+
+#include &quot;7zTypes.h&quot;
+
+extern UInt32 g_CrcTable[256];
+void InitCrcTable();
+
+void CrcInit(UInt32 *crc);
+UInt32 CrcGetDigest(UInt32 *crc);
+void CrcUpdateByte(UInt32 *crc, Byte v);
+void CrcUpdateUInt16(UInt32 *crc, UInt16 v);
+void CrcUpdateUInt32(UInt32 *crc, UInt32 v);
+void CrcUpdateUInt64(UInt32 *crc, UInt64 v);
+void CrcUpdate(UInt32 *crc, const void *data, size_t size);
+ 
+UInt32 CrcCalculateDigest(const void *data, size_t size);
+int CrcVerifyDigest(UInt32 digest, const void *data, size_t size);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zCrc.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,150 @@
+/* 7zDecode.c */
+
+#include &quot;7zDecode.h&quot;
+#ifdef _SZ_ONE_DIRECTORY
+#include &quot;LzmaDecode.h&quot;
+#else
+#include &quot;../../Compress/LZMA_C/LzmaDecode.h&quot;
+#endif
+
+CMethodID k_Copy = { { 0x0 }, 1 };
+CMethodID k_LZMA = { { 0x3, 0x1, 0x1 }, 3 };
+
+#ifdef _LZMA_IN_CB
+
+typedef struct _CLzmaInCallbackImp
+{
+  ILzmaInCallback InCallback;
+  ISzInStream *InStream;
+  size_t Size;
+} CLzmaInCallbackImp;
+
+int LzmaReadImp(void *object, const unsigned char **buffer, SizeT *size)
+{
+  CLzmaInCallbackImp *cb = (CLzmaInCallbackImp *)object;
+  size_t processedSize;
+  SZ_RESULT res;
+  *size = 0;
+  res = cb-&gt;InStream-&gt;Read((void *)cb-&gt;InStream, (void **)buffer, cb-&gt;Size, &amp;processedSize);
+  *size = (SizeT)processedSize;
+  if (processedSize &gt; cb-&gt;Size)
+    return (int)SZE_FAIL;
+  cb-&gt;Size -= processedSize;
+  if (res == SZ_OK)
+    return 0;
+  return (int)res;
+}
+
+#endif
+
+SZ_RESULT SzDecode(const CFileSize *packSizes, const CFolder *folder,
+    #ifdef _LZMA_IN_CB
+    ISzInStream *inStream,
+    #else
+    const Byte *inBuffer,
+    #endif
+    Byte *outBuffer, size_t outSize, 
+    size_t *outSizeProcessed, ISzAlloc *allocMain)
+{
+  UInt32 si;
+  size_t inSize = 0;
+  CCoderInfo *coder;
+  if (folder-&gt;NumPackStreams != 1)
+    return SZE_NOTIMPL;
+  if (folder-&gt;NumCoders != 1)
+    return SZE_NOTIMPL;
+  coder = folder-&gt;Coders;
+  *outSizeProcessed = 0;
+
+  for (si = 0; si &lt; folder-&gt;NumPackStreams; si++)
+    inSize += (size_t)packSizes[si];
+
+  if (AreMethodsEqual(&amp;coder-&gt;MethodID, &amp;k_Copy))
+  {
+    size_t i;
+    if (inSize != outSize)
+      return SZE_DATA_ERROR;
+    #ifdef _LZMA_IN_CB
+    for (i = 0; i &lt; inSize;)
+    {
+      size_t j;
+      Byte *inBuffer;
+      size_t bufferSize;
+      RINOK(inStream-&gt;Read((void *)inStream,  (void **)&amp;inBuffer, inSize - i, &amp;bufferSize));
+      if (bufferSize == 0)
+        return SZE_DATA_ERROR;
+      if (bufferSize &gt; inSize - i)
+        return SZE_FAIL;
+      *outSizeProcessed += bufferSize;
+      for (j = 0; j &lt; bufferSize &amp;&amp; i &lt; inSize; j++, i++)
+        outBuffer[i] = inBuffer[j];
+    }
+    #else
+    for (i = 0; i &lt; inSize; i++)
+      outBuffer[i] = inBuffer[i];
+    *outSizeProcessed = inSize;
+    #endif
+    return SZ_OK;
+  }
+
+  if (AreMethodsEqual(&amp;coder-&gt;MethodID, &amp;k_LZMA))
+  {
+    #ifdef _LZMA_IN_CB
+    CLzmaInCallbackImp lzmaCallback;
+    #else
+    SizeT inProcessed;
+    #endif
+
+    CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+    int result;
+    SizeT outSizeProcessedLoc;
+
+    #ifdef _LZMA_IN_CB
+    lzmaCallback.Size = inSize;
+    lzmaCallback.InStream = inStream;
+    lzmaCallback.InCallback.Read = LzmaReadImp;
+    #endif
+
+    if (LzmaDecodeProperties(&amp;state.Properties, coder-&gt;Properties.Items, 
+        coder-&gt;Properties.Capacity) != LZMA_RESULT_OK)
+      return SZE_FAIL;
+
+    state.Probs = (CProb *)allocMain-&gt;Alloc(LzmaGetNumProbs(&amp;state.Properties) * sizeof(CProb));
+    if (state.Probs == 0)
+      return SZE_OUTOFMEMORY;
+
+    #ifdef _LZMA_OUT_READ
+    if (state.Properties.DictionarySize == 0)
+      state.Dictionary = 0;
+    else
+    {
+      state.Dictionary = (unsigned char *)allocMain-&gt;Alloc(state.Properties.DictionarySize);
+      if (state.Dictionary == 0)
+      {
+        allocMain-&gt;Free(state.Probs);
+        return SZE_OUTOFMEMORY;
+      }
+    }
+    LzmaDecoderInit(&amp;state);
+    #endif
+
+    result = LzmaDecode(&amp;state,
+        #ifdef _LZMA_IN_CB
+        &amp;lzmaCallback.InCallback,
+        #else
+        inBuffer, (SizeT)inSize, &amp;inProcessed,
+        #endif
+        outBuffer, (SizeT)outSize, &amp;outSizeProcessedLoc);
+    *outSizeProcessed = (size_t)outSizeProcessedLoc;
+    allocMain-&gt;Free(state.Probs);
+    #ifdef _LZMA_OUT_READ
+    allocMain-&gt;Free(state.Dictionary);
+    #endif
+    if (result == LZMA_RESULT_DATA_ERROR)
+      return SZE_DATA_ERROR;
+    if (result != LZMA_RESULT_OK)
+      return SZE_FAIL;
+    return SZ_OK;
+  }
+  return SZE_NOTIMPL;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,21 @@
+/* 7zDecode.h */
+
+#ifndef __7Z_DECODE_H
+#define __7Z_DECODE_H
+
+#include &quot;7zItem.h&quot;
+#include &quot;7zAlloc.h&quot;
+#ifdef _LZMA_IN_CB
+#include &quot;7zIn.h&quot;
+#endif
+
+SZ_RESULT SzDecode(const CFileSize *packSizes, const CFolder *folder,
+    #ifdef _LZMA_IN_CB
+    ISzInStream *stream,
+    #else
+    const Byte *inBuffer,
+    #endif
+    Byte *outBuffer, size_t outSize, 
+    size_t *outSizeProcessed, ISzAlloc *allocMain);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zDecode.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,116 @@
+/* 7zExtract.c */
+
+#include &quot;7zExtract.h&quot;
+#include &quot;7zDecode.h&quot;
+#include &quot;7zCrc.h&quot;
+
+SZ_RESULT SzExtract(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    UInt32 fileIndex,
+    UInt32 *blockIndex,
+    Byte **outBuffer, 
+    size_t *outBufferSize,
+    size_t *offset, 
+    size_t *outSizeProcessed, 
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt32 folderIndex = db-&gt;FileIndexToFolderIndexMap[fileIndex];
+  SZ_RESULT res = SZ_OK;
+  *offset = 0;
+  *outSizeProcessed = 0;
+  if (folderIndex == (UInt32)-1)
+  {
+    allocMain-&gt;Free(*outBuffer);
+    *blockIndex = folderIndex;
+    *outBuffer = 0;
+    *outBufferSize = 0;
+    return SZ_OK;
+  }
+
+  if (*outBuffer == 0 || *blockIndex != folderIndex)
+  {
+    CFolder *folder = db-&gt;Database.Folders + folderIndex;
+    CFileSize unPackSize = SzFolderGetUnPackSize(folder);
+    #ifndef _LZMA_IN_CB
+    CFileSize packSize = SzArDbGetFolderFullPackSize(db, folderIndex);
+    Byte *inBuffer = 0;
+    size_t processedSize;
+    #endif
+    *blockIndex = folderIndex;
+    allocMain-&gt;Free(*outBuffer);
+    *outBuffer = 0;
+    
+    RINOK(inStream-&gt;Seek(inStream, SzArDbGetFolderStreamPos(db, folderIndex, 0)));
+    
+    #ifndef _LZMA_IN_CB
+    if (packSize != 0)
+    {
+      inBuffer = (Byte *)allocTemp-&gt;Alloc((size_t)packSize);
+      if (inBuffer == 0)
+        return SZE_OUTOFMEMORY;
+    }
+    res = inStream-&gt;Read(inStream, inBuffer, (size_t)packSize, &amp;processedSize);
+    if (res == SZ_OK &amp;&amp; processedSize != (size_t)packSize)
+      res = SZE_FAIL;
+    #endif
+    if (res == SZ_OK)
+    {
+      *outBufferSize = (size_t)unPackSize;
+      if (unPackSize != 0)
+      {
+        *outBuffer = (Byte *)allocMain-&gt;Alloc((size_t)unPackSize);
+        if (*outBuffer == 0)
+          res = SZE_OUTOFMEMORY;
+      }
+      if (res == SZ_OK)
+      {
+        size_t outRealSize;
+        res = SzDecode(db-&gt;Database.PackSizes + 
+          db-&gt;FolderStartPackStreamIndex[folderIndex], folder, 
+          #ifdef _LZMA_IN_CB
+          inStream,
+          #else
+          inBuffer, 
+          #endif
+          *outBuffer, (size_t)unPackSize, &amp;outRealSize, allocTemp);
+        if (res == SZ_OK)
+        {
+          if (outRealSize == (size_t)unPackSize)
+          {
+            if (folder-&gt;UnPackCRCDefined)
+            {
+              if (!CrcVerifyDigest(folder-&gt;UnPackCRC, *outBuffer, (size_t)unPackSize))
+                res = SZE_FAIL;
+            }
+          }
+          else
+            res = SZE_FAIL;
+        }
+      }
+    }
+    #ifndef _LZMA_IN_CB
+    allocTemp-&gt;Free(inBuffer);
+    #endif
+  }
+  if (res == SZ_OK)
+  {
+    UInt32 i; 
+    CFileItem *fileItem = db-&gt;Database.Files + fileIndex;
+    *offset = 0;
+    for(i = db-&gt;FolderStartFileIndex[folderIndex]; i &lt; fileIndex; i++)
+      *offset += (UInt32)db-&gt;Database.Files[i].Size;
+    *outSizeProcessed = (size_t)fileItem-&gt;Size;
+    if (*offset + *outSizeProcessed &gt; *outBufferSize)
+      return SZE_FAIL;
+    {
+      if (fileItem-&gt;IsFileCRCDefined)
+      {
+        if (!CrcVerifyDigest(fileItem-&gt;FileCRC, *outBuffer + *offset, *outSizeProcessed))
+          res = SZE_FAIL;
+      }
+    }
+  }
+  return res;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,40 @@
+/* 7zExtract.h */
+
+#ifndef __7Z_EXTRACT_H
+#define __7Z_EXTRACT_H
+
+#include &quot;7zIn.h&quot;
+
+/*
+  SzExtract extracts file from archive
+
+  *outBuffer must be 0 before first call for each new archive. 
+
+  Extracting cache:
+    If you need to decompress more than one file, you can send 
+    these values from previous call:
+      *blockIndex, 
+      *outBuffer, 
+      *outBufferSize
+    You can consider &quot;*outBuffer&quot; as cache of solid block. If your archive is solid, 
+    it will increase decompression speed.
+  
+    If you use external function, you can declare these 3 cache variables 
+    (blockIndex, outBuffer, outBufferSize) as static in that external function.
+    
+    Free *outBuffer and set *outBuffer to 0, if you want to flush cache.
+*/
+
+SZ_RESULT SzExtract(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    UInt32 fileIndex,         /* index of file */
+    UInt32 *blockIndex,       /* index of solid block */
+    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    size_t *outBufferSize,    /* buffer size for output buffer */
+    size_t *offset,           /* offset of stream for required file in *outBuffer */
+    size_t *outSizeProcessed, /* size of file in *outBuffer */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zExtract.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,5 @@
+/*  7zHeader.c */
+
+#include &quot;7zHeader.h&quot;
+
+Byte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,55 @@
+/* 7zHeader.h */
+
+#ifndef __7Z_HEADER_H
+#define __7Z_HEADER_H
+
+#include &quot;7zTypes.h&quot;
+
+#define k7zSignatureSize 6
+extern Byte k7zSignature[k7zSignatureSize];
+
+#define k7zMajorVersion 0
+
+#define k7zStartHeaderSize 0x20
+
+enum EIdEnum
+{
+  k7zIdEnd,
+    
+  k7zIdHeader,
+    
+  k7zIdArchiveProperties,
+    
+  k7zIdAdditionalStreamsInfo,
+  k7zIdMainStreamsInfo,
+  k7zIdFilesInfo,
+  
+  k7zIdPackInfo,
+  k7zIdUnPackInfo,
+  k7zIdSubStreamsInfo,
+  
+  k7zIdSize,
+  k7zIdCRC,
+  
+  k7zIdFolder,
+  
+  k7zIdCodersUnPackSize,
+  k7zIdNumUnPackStream,
+  
+  k7zIdEmptyStream,
+  k7zIdEmptyFile,
+  k7zIdAnti,
+  
+  k7zIdName,
+  k7zIdCreationTime,
+  k7zIdLastAccessTime,
+  k7zIdLastWriteTime,
+  k7zIdWinAttributes,
+  k7zIdComment,
+  
+  k7zIdEncodedHeader,
+  
+  k7zIdStartPos
+};
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zHeader.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,1281 @@
+/* 7zIn.c */
+
+#include &quot;7zIn.h&quot;
+#include &quot;7zCrc.h&quot;
+#include &quot;7zDecode.h&quot;
+
+#define RINOM(x) { if((x) == 0) return SZE_OUTOFMEMORY; }
+
+void SzArDbExInit(CArchiveDatabaseEx *db)
+{
+  SzArchiveDatabaseInit(&amp;db-&gt;Database);
+  db-&gt;FolderStartPackStreamIndex = 0;
+  db-&gt;PackStreamStartPositions = 0;
+  db-&gt;FolderStartFileIndex = 0;
+  db-&gt;FileIndexToFolderIndexMap = 0;
+}
+
+void SzArDbExFree(CArchiveDatabaseEx *db, void (*freeFunc)(void *))
+{
+  freeFunc(db-&gt;FolderStartPackStreamIndex);
+  freeFunc(db-&gt;PackStreamStartPositions);
+  freeFunc(db-&gt;FolderStartFileIndex);
+  freeFunc(db-&gt;FileIndexToFolderIndexMap);
+  SzArchiveDatabaseFree(&amp;db-&gt;Database, freeFunc);
+  SzArDbExInit(db);
+}
+
+/*
+CFileSize GetFolderPackStreamSize(int folderIndex, int streamIndex) const 
+{
+  return PackSizes[FolderStartPackStreamIndex[folderIndex] + streamIndex];
+}
+
+CFileSize GetFilePackSize(int fileIndex) const
+{
+  int folderIndex = FileIndexToFolderIndexMap[fileIndex];
+  if (folderIndex &gt;= 0)
+  {
+    const CFolder &amp;folderInfo = Folders[folderIndex];
+    if (FolderStartFileIndex[folderIndex] == fileIndex)
+    return GetFolderFullPackSize(folderIndex);
+  }
+  return 0;
+}
+*/
+
+#define MY_ALLOC(T, p, size, allocFunc) { if ((size) == 0) p = 0; else \
+  if ((p = (T *)allocFunc((size) * sizeof(T))) == 0) return SZE_OUTOFMEMORY; }
+
+SZ_RESULT SzArDbExFill(CArchiveDatabaseEx *db, void * (*allocFunc)(size_t size))
+{
+  UInt32 startPos = 0;
+  CFileSize startPosSize = 0;
+  UInt32 i;
+  UInt32 folderIndex = 0;
+  UInt32 indexInFolder = 0;
+  MY_ALLOC(UInt32, db-&gt;FolderStartPackStreamIndex, db-&gt;Database.NumFolders, allocFunc);
+  for(i = 0; i &lt; db-&gt;Database.NumFolders; i++)
+  {
+    db-&gt;FolderStartPackStreamIndex[i] = startPos;
+    startPos += db-&gt;Database.Folders[i].NumPackStreams;
+  }
+
+  MY_ALLOC(CFileSize, db-&gt;PackStreamStartPositions, db-&gt;Database.NumPackStreams, allocFunc);
+
+  for(i = 0; i &lt; db-&gt;Database.NumPackStreams; i++)
+  {
+    db-&gt;PackStreamStartPositions[i] = startPosSize;
+    startPosSize += db-&gt;Database.PackSizes[i];
+  }
+
+  MY_ALLOC(UInt32, db-&gt;FolderStartFileIndex, db-&gt;Database.NumFolders, allocFunc);
+  MY_ALLOC(UInt32, db-&gt;FileIndexToFolderIndexMap, db-&gt;Database.NumFiles, allocFunc);
+
+  for (i = 0; i &lt; db-&gt;Database.NumFiles; i++)
+  {
+    CFileItem *file = db-&gt;Database.Files + i;
+    int emptyStream = !file-&gt;HasStream;
+    if (emptyStream &amp;&amp; indexInFolder == 0)
+    {
+      db-&gt;FileIndexToFolderIndexMap[i] = (UInt32)-1;
+      continue;
+    }
+    if (indexInFolder == 0)
+    {
+      /*
+      v3.13 incorrectly worked with empty folders
+      v4.07: Loop for skipping empty folders
+      */
+      while(1)
+      {
+        if (folderIndex &gt;= db-&gt;Database.NumFolders)
+          return SZE_ARCHIVE_ERROR;
+        db-&gt;FolderStartFileIndex[folderIndex] = i;
+        if (db-&gt;Database.Folders[folderIndex].NumUnPackStreams != 0)
+          break;
+        folderIndex++;
+      }
+    }
+    db-&gt;FileIndexToFolderIndexMap[i] = folderIndex;
+    if (emptyStream)
+      continue;
+    indexInFolder++;
+    if (indexInFolder &gt;= db-&gt;Database.Folders[folderIndex].NumUnPackStreams)
+    {
+      folderIndex++;
+      indexInFolder = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+
+CFileSize SzArDbGetFolderStreamPos(CArchiveDatabaseEx *db, UInt32 folderIndex, UInt32 indexInFolder)
+{
+  return db-&gt;ArchiveInfo.DataStartPosition + 
+    db-&gt;PackStreamStartPositions[db-&gt;FolderStartPackStreamIndex[folderIndex] + indexInFolder];
+}
+
+CFileSize SzArDbGetFolderFullPackSize(CArchiveDatabaseEx *db, UInt32 folderIndex)
+{
+  UInt32 packStreamIndex = db-&gt;FolderStartPackStreamIndex[folderIndex];
+  CFolder *folder = db-&gt;Database.Folders + folderIndex;
+  CFileSize size = 0;
+  UInt32 i;
+  for (i = 0; i &lt; folder-&gt;NumPackStreams; i++)
+    size += db-&gt;Database.PackSizes[packStreamIndex + i];
+  return size;
+}
+
+
+/*
+SZ_RESULT SzReadTime(const CObjectVector&lt;CSzByteBuffer&gt; &amp;dataVector,
+    CObjectVector&lt;CFileItem&gt; &amp;files, UInt64 type)
+{
+  CBoolVector boolVector;
+  RINOK(ReadBoolVector2(files.Size(), boolVector))
+
+  CStreamSwitch streamSwitch;
+  RINOK(streamSwitch.Set(this, &amp;dataVector));
+
+  for(int i = 0; i &lt; files.Size(); i++)
+  {
+    CFileItem &amp;file = files[i];
+    CArchiveFileTime fileTime;
+    bool defined = boolVector[i];
+    if (defined)
+    {
+      UInt32 low, high;
+      RINOK(SzReadUInt32(low));
+      RINOK(SzReadUInt32(high));
+      fileTime.dwLowDateTime = low;
+      fileTime.dwHighDateTime = high;
+    }
+    switch(type)
+    {
+      case k7zIdCreationTime:
+        file.IsCreationTimeDefined = defined;
+        if (defined)
+          file.CreationTime = fileTime;
+        break;
+      case k7zIdLastWriteTime:
+        file.IsLastWriteTimeDefined = defined;
+        if (defined)
+          file.LastWriteTime = fileTime;
+        break;
+      case k7zIdLastAccessTime:
+        file.IsLastAccessTimeDefined = defined;
+        if (defined)
+          file.LastAccessTime = fileTime;
+        break;
+    }
+  }
+  return SZ_OK;
+}
+*/
+
+SZ_RESULT SafeReadDirect(ISzInStream *inStream, Byte *data, size_t size)
+{
+  #ifdef _LZMA_IN_CB
+  while (size &gt; 0)
+  {
+    Byte *inBuffer;
+    size_t processedSize;
+    RINOK(inStream-&gt;Read(inStream, (void **)&amp;inBuffer, size, &amp;processedSize));
+    if (processedSize == 0 || processedSize &gt; size)
+      return SZE_FAIL;
+    size -= processedSize;
+    do
+    {
+      *data++ = *inBuffer++;
+    }
+    while (--processedSize != 0);
+  }
+  #else
+  size_t processedSize;
+  RINOK(inStream-&gt;Read(inStream, data, size, &amp;processedSize));
+  if (processedSize != size)
+    return SZE_FAIL;
+  #endif
+  return SZ_OK;
+}
+
+SZ_RESULT SafeReadDirectByte(ISzInStream *inStream, Byte *data)
+{
+  return SafeReadDirect(inStream, data, 1);
+}
+
+SZ_RESULT SafeReadDirectUInt32(ISzInStream *inStream, UInt32 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i &lt; 4; i++)
+  {
+    Byte b;
+    RINOK(SafeReadDirectByte(inStream, &amp;b));
+    *value |= ((UInt32)b &lt;&lt; (8 * i));
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SafeReadDirectUInt64(ISzInStream *inStream, UInt64 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i &lt; 8; i++)
+  {
+    Byte b;
+    RINOK(SafeReadDirectByte(inStream, &amp;b));
+    *value |= ((UInt32)b &lt;&lt; (8 * i));
+  }
+  return SZ_OK;
+}
+
+int TestSignatureCandidate(Byte *testBytes)
+{
+  size_t i;
+  for (i = 0; i &lt; k7zSignatureSize; i++)
+    if (testBytes[i] != k7zSignature[i])
+      return 0;
+  return 1;
+}
+
+typedef struct _CSzState
+{
+  Byte *Data;
+  size_t Size;
+}CSzData;
+
+SZ_RESULT SzReadByte(CSzData *sd, Byte *b)
+{
+  if (sd-&gt;Size == 0)
+    return SZE_ARCHIVE_ERROR;
+  sd-&gt;Size--;
+  *b = *sd-&gt;Data++;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadBytes(CSzData *sd, Byte *data, size_t size)
+{
+  size_t i;
+  for (i = 0; i &lt; size; i++)
+  {
+    RINOK(SzReadByte(sd, data + i));
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadUInt32(CSzData *sd, UInt32 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i &lt; 4; i++)
+  {
+    Byte b;
+    RINOK(SzReadByte(sd, &amp;b));
+    *value |= ((UInt32)(b) &lt;&lt; (8 * i));
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadNumber(CSzData *sd, UInt64 *value)
+{
+  Byte firstByte;
+  Byte mask = 0x80;
+  int i;
+  RINOK(SzReadByte(sd, &amp;firstByte));
+  *value = 0;
+  for (i = 0; i &lt; 8; i++)
+  {
+    Byte b;
+    if ((firstByte &amp; mask) == 0)
+    {
+      UInt64 highPart = firstByte &amp; (mask - 1);
+      *value += (highPart &lt;&lt; (8 * i));
+      return SZ_OK;
+    }
+    RINOK(SzReadByte(sd, &amp;b));
+    *value |= ((UInt64)b &lt;&lt; (8 * i));
+    mask &gt;&gt;= 1;
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadSize(CSzData *sd, CFileSize *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &amp;value64));
+  *value = (CFileSize)value64;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadNumber32(CSzData *sd, UInt32 *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &amp;value64));
+  if (value64 &gt;= 0x80000000)
+    return SZE_NOTIMPL;
+  if (value64 &gt;= ((UInt64)(1) &lt;&lt; ((sizeof(size_t) - 1) * 8 + 2)))
+    return SZE_NOTIMPL;
+  *value = (UInt32)value64;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadID(CSzData *sd, UInt64 *value) 
+{ 
+  return SzReadNumber(sd, value); 
+}
+
+SZ_RESULT SzSkeepDataSize(CSzData *sd, UInt64 size)
+{
+  if (size &gt; sd-&gt;Size)
+    return SZE_ARCHIVE_ERROR;
+  sd-&gt;Size -= (size_t)size;
+  sd-&gt;Data += (size_t)size;
+  return SZ_OK;
+}
+
+SZ_RESULT SzSkeepData(CSzData *sd)
+{
+  UInt64 size;
+  RINOK(SzReadNumber(sd, &amp;size));
+  return SzSkeepDataSize(sd, size);
+}
+
+SZ_RESULT SzReadArchiveProperties(CSzData *sd)
+{
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      break;
+    SzSkeepData(sd);
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzWaitAttribute(CSzData *sd, UInt64 attribute)
+{
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == attribute)
+      return SZ_OK;
+    if (type == k7zIdEnd)
+      return SZE_ARCHIVE_ERROR;
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+SZ_RESULT SzReadBoolVector(CSzData *sd, size_t numItems, Byte **v, void * (*allocFunc)(size_t size))
+{
+  Byte b = 0;
+  Byte mask = 0;
+  size_t i;
+  MY_ALLOC(Byte, *v, numItems, allocFunc);
+  for(i = 0; i &lt; numItems; i++)
+  {
+    if (mask == 0)
+    {
+      RINOK(SzReadByte(sd, &amp;b));
+      mask = 0x80;
+    }
+    (*v)[i] = (Byte)(((b &amp; mask) != 0) ? 1 : 0);
+    mask &gt;&gt;= 1;
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadBoolVector2(CSzData *sd, size_t numItems, Byte **v, void * (*allocFunc)(size_t size))
+{
+  Byte allAreDefined;
+  size_t i;
+  RINOK(SzReadByte(sd, &amp;allAreDefined));
+  if (allAreDefined == 0)
+    return SzReadBoolVector(sd, numItems, v, allocFunc);
+  MY_ALLOC(Byte, *v, numItems, allocFunc);
+  for(i = 0; i &lt; numItems; i++)
+    (*v)[i] = 1;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadHashDigests(
+    CSzData *sd, 
+    size_t numItems,
+    Byte **digestsDefined, 
+    UInt32 **digests, 
+    void * (*allocFunc)(size_t size))
+{
+  size_t i;
+  RINOK(SzReadBoolVector2(sd, numItems, digestsDefined, allocFunc));
+  MY_ALLOC(UInt32, *digests, numItems, allocFunc);
+  for(i = 0; i &lt; numItems; i++)
+    if ((*digestsDefined)[i])
+    {
+      RINOK(SzReadUInt32(sd, (*digests) + i));
+    }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadPackInfo(
+    CSzData *sd, 
+    CFileSize *dataOffset,
+    UInt32 *numPackStreams,
+    CFileSize **packSizes,
+    Byte **packCRCsDefined,
+    UInt32 **packCRCs,
+    void * (*allocFunc)(size_t size))
+{
+  UInt32 i;
+  RINOK(SzReadSize(sd, dataOffset));
+  RINOK(SzReadNumber32(sd, numPackStreams));
+
+  RINOK(SzWaitAttribute(sd, k7zIdSize));
+
+  MY_ALLOC(CFileSize, *packSizes, (size_t)*numPackStreams, allocFunc);
+
+  for(i = 0; i &lt; *numPackStreams; i++)
+  {
+    RINOK(SzReadSize(sd, (*packSizes) + i));
+  }
+
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      break;
+    if (type == k7zIdCRC)
+    {
+      RINOK(SzReadHashDigests(sd, (size_t)*numPackStreams, packCRCsDefined, packCRCs, allocFunc)); 
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+  if (*packCRCsDefined == 0)
+  {
+    MY_ALLOC(Byte, *packCRCsDefined, (size_t)*numPackStreams, allocFunc);
+    MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, allocFunc);
+    for(i = 0; i &lt; *numPackStreams; i++)
+    {
+      (*packCRCsDefined)[i] = 0;
+      (*packCRCs)[i] = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadSwitch(CSzData *sd)
+{
+  Byte external;
+  RINOK(SzReadByte(sd, &amp;external));
+  return (external == 0) ? SZ_OK: SZE_ARCHIVE_ERROR;
+}
+
+SZ_RESULT SzGetNextFolderItem(CSzData *sd, CFolder *folder, void * (*allocFunc)(size_t size))
+{
+  UInt32 numCoders;
+  UInt32 numBindPairs;
+  UInt32 numPackedStreams;
+  UInt32 i;
+  UInt32 numInStreams = 0;
+  UInt32 numOutStreams = 0;
+  RINOK(SzReadNumber32(sd, &amp;numCoders));
+  folder-&gt;NumCoders = numCoders;
+
+  MY_ALLOC(CCoderInfo, folder-&gt;Coders, (size_t)numCoders, allocFunc);
+
+  for (i = 0; i &lt; numCoders; i++)
+    SzCoderInfoInit(folder-&gt;Coders + i);
+
+  for (i = 0; i &lt; numCoders; i++)
+  {
+    Byte mainByte;
+    CCoderInfo *coder = folder-&gt;Coders + i;
+    {
+      RINOK(SzReadByte(sd, &amp;mainByte));
+      coder-&gt;MethodID.IDSize = (Byte)(mainByte &amp; 0xF);
+      RINOK(SzReadBytes(sd, coder-&gt;MethodID.ID, coder-&gt;MethodID.IDSize));
+      if ((mainByte &amp; 0x10) != 0)
+      {
+        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumInStreams));
+        RINOK(SzReadNumber32(sd, &amp;coder-&gt;NumOutStreams));
+      }
+      else
+      {
+        coder-&gt;NumInStreams = 1;
+        coder-&gt;NumOutStreams = 1;
+      }
+      if ((mainByte &amp; 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &amp;propertiesSize));
+        if (!SzByteBufferCreate(&amp;coder-&gt;Properties, (size_t)propertiesSize, allocFunc))
+          return SZE_OUTOFMEMORY;
+        RINOK(SzReadBytes(sd, coder-&gt;Properties.Items, (size_t)propertiesSize));
+      }
+    }
+    while ((mainByte &amp; 0x80) != 0)
+    {
+      RINOK(SzReadByte(sd, &amp;mainByte));
+      RINOK(SzSkeepDataSize(sd, (mainByte &amp; 0xF)));
+      if ((mainByte &amp; 0x10) != 0)
+      {
+        UInt32 n;
+        RINOK(SzReadNumber32(sd, &amp;n));
+        RINOK(SzReadNumber32(sd, &amp;n));
+      }
+      if ((mainByte &amp; 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &amp;propertiesSize));
+        RINOK(SzSkeepDataSize(sd, propertiesSize));
+      }
+    }
+    numInStreams += (UInt32)coder-&gt;NumInStreams;
+    numOutStreams += (UInt32)coder-&gt;NumOutStreams;
+  }
+
+  numBindPairs = numOutStreams - 1;
+  folder-&gt;NumBindPairs = numBindPairs;
+
+
+  MY_ALLOC(CBindPair, folder-&gt;BindPairs, (size_t)numBindPairs, allocFunc);
+
+  for (i = 0; i &lt; numBindPairs; i++)
+  {
+    CBindPair *bindPair = folder-&gt;BindPairs + i;;
+    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;InIndex));
+    RINOK(SzReadNumber32(sd, &amp;bindPair-&gt;OutIndex)); 
+  }
+
+  numPackedStreams = numInStreams - (UInt32)numBindPairs;
+
+  folder-&gt;NumPackStreams = numPackedStreams;
+  MY_ALLOC(UInt32, folder-&gt;PackStreams, (size_t)numPackedStreams, allocFunc);
+
+  if (numPackedStreams == 1)
+  {
+    UInt32 j;
+    UInt32 pi = 0;
+    for (j = 0; j &lt; numInStreams; j++)
+      if (SzFolderFindBindPairForInStream(folder, j) &lt; 0)
+      {
+        folder-&gt;PackStreams[pi++] = j;
+        break;
+      }
+  }
+  else
+    for(i = 0; i &lt; numPackedStreams; i++)
+    {
+      RINOK(SzReadNumber32(sd, folder-&gt;PackStreams + i));
+    }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadUnPackInfo(
+    CSzData *sd, 
+    UInt32 *numFolders,
+    CFolder **folders,  /* for allocFunc */
+    void * (*allocFunc)(size_t size),
+    ISzAlloc *allocTemp)
+{
+  UInt32 i;
+  RINOK(SzWaitAttribute(sd, k7zIdFolder));
+  RINOK(SzReadNumber32(sd, numFolders));
+  {
+    RINOK(SzReadSwitch(sd));
+
+    MY_ALLOC(CFolder, *folders, (size_t)*numFolders, allocFunc);
+
+    for(i = 0; i &lt; *numFolders; i++)
+      SzFolderInit((*folders) + i);
+
+    for(i = 0; i &lt; *numFolders; i++)
+    {
+      RINOK(SzGetNextFolderItem(sd, (*folders) + i, allocFunc));
+    }
+  }
+
+  RINOK(SzWaitAttribute(sd, k7zIdCodersUnPackSize));
+
+  for(i = 0; i &lt; *numFolders; i++)
+  {
+    UInt32 j;
+    CFolder *folder = (*folders) + i;
+    UInt32 numOutStreams = SzFolderGetNumOutStreams(folder);
+
+    MY_ALLOC(CFileSize, folder-&gt;UnPackSizes, (size_t)numOutStreams, allocFunc);
+
+    for(j = 0; j &lt; numOutStreams; j++)
+    {
+      RINOK(SzReadSize(sd, folder-&gt;UnPackSizes + j));
+    }
+  }
+
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      return SZ_OK;
+    if (type == k7zIdCRC)
+    {
+      SZ_RESULT res;
+      Byte *crcsDefined = 0;
+      UInt32 *crcs = 0;
+      res = SzReadHashDigests(sd, *numFolders, &amp;crcsDefined, &amp;crcs, allocTemp-&gt;Alloc); 
+      if (res == SZ_OK)
+      {
+        for(i = 0; i &lt; *numFolders; i++)
+        {
+          CFolder *folder = (*folders) + i;
+          folder-&gt;UnPackCRCDefined = crcsDefined[i];
+          folder-&gt;UnPackCRC = crcs[i];
+        }
+      }
+      allocTemp-&gt;Free(crcs);
+      allocTemp-&gt;Free(crcsDefined);
+      RINOK(res);
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+SZ_RESULT SzReadSubStreamsInfo(
+    CSzData *sd, 
+    UInt32 numFolders,
+    CFolder *folders,
+    UInt32 *numUnPackStreams,
+    CFileSize **unPackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type = 0;
+  UInt32 i;
+  UInt32 si = 0;
+  UInt32 numDigests = 0;
+
+  for(i = 0; i &lt; numFolders; i++)
+    folders[i].NumUnPackStreams = 1;
+  *numUnPackStreams = numFolders;
+
+  while(1)
+  {
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdNumUnPackStream)
+    {
+      *numUnPackStreams = 0;
+      for(i = 0; i &lt; numFolders; i++)
+      {
+        UInt32 numStreams;
+        RINOK(SzReadNumber32(sd, &amp;numStreams));
+        folders[i].NumUnPackStreams = numStreams;
+        *numUnPackStreams += numStreams;
+      }
+      continue;
+    }
+    if (type == k7zIdCRC || type == k7zIdSize)
+      break;
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzSkeepData(sd));
+  }
+
+  if (*numUnPackStreams == 0)
+  {
+    *unPackSizes = 0;
+    *digestsDefined = 0;
+    *digests = 0;
+  }
+  else
+  {
+    *unPackSizes = (CFileSize *)allocTemp-&gt;Alloc((size_t)*numUnPackStreams * sizeof(CFileSize));
+    RINOM(*unPackSizes);
+    *digestsDefined = (Byte *)allocTemp-&gt;Alloc((size_t)*numUnPackStreams * sizeof(Byte));
+    RINOM(*digestsDefined);
+    *digests = (UInt32 *)allocTemp-&gt;Alloc((size_t)*numUnPackStreams * sizeof(UInt32));
+    RINOM(*digests);
+  }
+
+  for(i = 0; i &lt; numFolders; i++)
+  {
+    /*
+    v3.13 incorrectly worked with empty folders
+    v4.07: we check that folder is empty
+    */
+    CFileSize sum = 0;
+    UInt32 j;
+    UInt32 numSubstreams = folders[i].NumUnPackStreams;
+    if (numSubstreams == 0)
+      continue;
+    if (type == k7zIdSize)
+    for (j = 1; j &lt; numSubstreams; j++)
+    {
+      CFileSize size;
+      RINOK(SzReadSize(sd, &amp;size));
+      (*unPackSizes)[si++] = size;
+      sum += size;
+    }
+    (*unPackSizes)[si++] = SzFolderGetUnPackSize(folders + i) - sum;
+  }
+  if (type == k7zIdSize)
+  {
+    RINOK(SzReadID(sd, &amp;type));
+  }
+
+  for(i = 0; i &lt; *numUnPackStreams; i++)
+  {
+    (*digestsDefined)[i] = 0;
+    (*digests)[i] = 0;
+  }
+
+
+  for(i = 0; i &lt; numFolders; i++)
+  {
+    UInt32 numSubstreams = folders[i].NumUnPackStreams;
+    if (numSubstreams != 1 || !folders[i].UnPackCRCDefined)
+      numDigests += numSubstreams;
+  }
+
+ 
+  si = 0;
+  while(1)
+  {
+    if (type == k7zIdCRC)
+    {
+      int digestIndex = 0;
+      Byte *digestsDefined2 = 0; 
+      UInt32 *digests2 = 0;
+      SZ_RESULT res = SzReadHashDigests(sd, numDigests, &amp;digestsDefined2, &amp;digests2, allocTemp-&gt;Alloc);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i &lt; numFolders; i++)
+        {
+          CFolder *folder = folders + i;
+          UInt32 numSubstreams = folder-&gt;NumUnPackStreams;
+          if (numSubstreams == 1 &amp;&amp; folder-&gt;UnPackCRCDefined)
+          {
+            (*digestsDefined)[si] = 1;
+            (*digests)[si] = folder-&gt;UnPackCRC;
+            si++;
+          }
+          else
+          {
+            UInt32 j;
+            for (j = 0; j &lt; numSubstreams; j++, digestIndex++)
+            {
+              (*digestsDefined)[si] = digestsDefined2[digestIndex];
+              (*digests)[si] = digests2[digestIndex];
+              si++;
+            }
+          }
+        }
+      }
+      allocTemp-&gt;Free(digestsDefined2);
+      allocTemp-&gt;Free(digests2);
+      RINOK(res);
+    }
+    else if (type == k7zIdEnd)
+      return SZ_OK;
+    else
+    {
+      RINOK(SzSkeepData(sd));
+    }
+    RINOK(SzReadID(sd, &amp;type));
+  }
+}
+
+
+SZ_RESULT SzReadStreamsInfo(
+    CSzData *sd, 
+    CFileSize *dataOffset,
+    CArchiveDatabase *db,
+    UInt32 *numUnPackStreams,
+    CFileSize **unPackSizes, /* allocTemp */
+    Byte **digestsDefined,   /* allocTemp */
+    UInt32 **digests,        /* allocTemp */
+    void * (*allocFunc)(size_t size),
+    ISzAlloc *allocTemp)
+{
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &amp;type));
+    if ((UInt64)(int)type != type)
+      return SZE_FAIL;
+    switch((int)type)
+    {
+      case k7zIdEnd:
+        return SZ_OK;
+      case k7zIdPackInfo:
+      {
+        RINOK(SzReadPackInfo(sd, dataOffset, &amp;db-&gt;NumPackStreams, 
+            &amp;db-&gt;PackSizes, &amp;db-&gt;PackCRCsDefined, &amp;db-&gt;PackCRCs, allocFunc));
+        break;
+      }
+      case k7zIdUnPackInfo:
+      {
+        RINOK(SzReadUnPackInfo(sd, &amp;db-&gt;NumFolders, &amp;db-&gt;Folders, allocFunc, allocTemp));
+        break;
+      }
+      case k7zIdSubStreamsInfo:
+      {
+        RINOK(SzReadSubStreamsInfo(sd, db-&gt;NumFolders, db-&gt;Folders, 
+            numUnPackStreams, unPackSizes, digestsDefined, digests, allocTemp));
+        break;
+      }
+      default:
+        return SZE_FAIL;
+    }
+  }
+}
+
+Byte kUtf8Limits[5] = { 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+SZ_RESULT SzReadFileNames(CSzData *sd, UInt32 numFiles, CFileItem *files, 
+    void * (*allocFunc)(size_t size))
+{
+  UInt32 i;
+  for(i = 0; i &lt; numFiles; i++)
+  {
+    UInt32 len = 0;
+    UInt32 pos = 0;
+    CFileItem *file = files + i;
+    while(pos + 2 &lt;= sd-&gt;Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
+      pos += 2;
+      len++;
+      if (value == 0)
+        break;
+      if (value &lt; 0x80)
+        continue;
+      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
+      {
+        UInt32 c2;
+        if (value &gt;= 0xDC00)
+          return SZE_ARCHIVE_ERROR;
+        if (pos + 2 &gt; sd-&gt;Size)
+          return SZE_ARCHIVE_ERROR;
+        c2 = (UInt32)(sd-&gt;Data[pos] | (((UInt32)sd-&gt;Data[pos + 1]) &lt;&lt; 8));
+        pos += 2;
+        if (c2 &lt; 0xDC00 || c2 &gt;= 0xE000)
+          return SZE_ARCHIVE_ERROR;
+        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds &lt; 5; numAdds++)
+        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
+          break;
+      len += numAdds;
+    }
+
+    MY_ALLOC(char, file-&gt;Name, (size_t)len, allocFunc);
+
+    len = 0;
+    while(2 &lt;= sd-&gt;Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
+      SzSkeepDataSize(sd, 2);
+      if (value &lt; 0x80)
+      {
+        file-&gt;Name[len++] = (char)value;
+        if (value == 0)
+          break;
+        continue;
+      }
+      if (value &gt;= 0xD800 &amp;&amp; value &lt; 0xE000)
+      {
+        UInt32 c2 = (UInt32)(sd-&gt;Data[0] | (((UInt32)sd-&gt;Data[1]) &lt;&lt; 8));
+        SzSkeepDataSize(sd, 2);
+        value = ((value - 0xD800) &lt;&lt; 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds &lt; 5; numAdds++)
+        if (value &lt; (((UInt32)1) &lt;&lt; (numAdds * 5 + 6)))
+          break;
+      file-&gt;Name[len++] = (char)(kUtf8Limits[numAdds - 1] + (value &gt;&gt; (6 * numAdds)));
+      do
+      {
+        numAdds--;
+        file-&gt;Name[len++] = (char)(0x80 + ((value &gt;&gt; (6 * numAdds)) &amp; 0x3F));
+      }
+      while(numAdds &gt; 0);
+
+      len += numAdds;
+    }
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadHeader2(
+    CSzData *sd, 
+    CArchiveDatabaseEx *db,   /* allocMain */
+    CFileSize **unPackSizes,  /* allocTemp */
+    Byte **digestsDefined,    /* allocTemp */
+    UInt32 **digests,         /* allocTemp */
+    Byte **emptyStreamVector, /* allocTemp */
+    Byte **emptyFileVector,   /* allocTemp */
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp)
+{
+  UInt64 type;
+  UInt32 numUnPackStreams = 0;
+  UInt32 numFiles = 0;
+  CFileItem *files = 0;
+  UInt32 numEmptyStreams = 0;
+  UInt32 i;
+
+  RINOK(SzReadID(sd, &amp;type));
+
+  if (type == k7zIdArchiveProperties)
+  {
+    RINOK(SzReadArchiveProperties(sd));
+    RINOK(SzReadID(sd, &amp;type));
+  }
+ 
+ 
+  if (type == k7zIdMainStreamsInfo)
+  {
+    RINOK(SzReadStreamsInfo(sd,
+        &amp;db-&gt;ArchiveInfo.DataStartPosition,
+        &amp;db-&gt;Database, 
+        &amp;numUnPackStreams,
+        unPackSizes,
+        digestsDefined,
+        digests, allocMain-&gt;Alloc, allocTemp));
+    db-&gt;ArchiveInfo.DataStartPosition += db-&gt;ArchiveInfo.StartPositionAfterHeader;
+    RINOK(SzReadID(sd, &amp;type));
+  }
+
+  if (type == k7zIdEnd)
+    return SZ_OK;
+  if (type != k7zIdFilesInfo)
+    return SZE_ARCHIVE_ERROR;
+  
+  RINOK(SzReadNumber32(sd, &amp;numFiles));
+  db-&gt;Database.NumFiles = numFiles;
+
+  MY_ALLOC(CFileItem, files, (size_t)numFiles, allocMain-&gt;Alloc);
+
+  db-&gt;Database.Files = files;
+  for(i = 0; i &lt; numFiles; i++)
+    SzFileInit(files + i);
+
+  while(1)
+  {
+    UInt64 type;
+    UInt64 size;
+    RINOK(SzReadID(sd, &amp;type));
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzReadNumber(sd, &amp;size));
+
+    if ((UInt64)(int)type != type)
+    {
+      RINOK(SzSkeepDataSize(sd, size));
+    }
+    else
+    switch((int)type)
+    {
+      case k7zIdName:
+      {
+        RINOK(SzReadSwitch(sd));
+        RINOK(SzReadFileNames(sd, numFiles, files, allocMain-&gt;Alloc))
+        break;
+      }
+      case k7zIdEmptyStream:
+      {
+        RINOK(SzReadBoolVector(sd, numFiles, emptyStreamVector, allocTemp-&gt;Alloc));
+        numEmptyStreams = 0;
+        for (i = 0; i &lt; numFiles; i++)
+          if ((*emptyStreamVector)[i])
+            numEmptyStreams++;
+        break;
+      }
+      case k7zIdEmptyFile:
+      {
+        RINOK(SzReadBoolVector(sd, numEmptyStreams, emptyFileVector, allocTemp-&gt;Alloc));
+        break;
+      }
+      default:
+      {
+        RINOK(SzSkeepDataSize(sd, size));
+      }
+    }
+  }
+
+  {
+    UInt32 emptyFileIndex = 0;
+    UInt32 sizeIndex = 0;
+    for(i = 0; i &lt; numFiles; i++)
+    {
+      CFileItem *file = files + i;
+      file-&gt;IsAnti = 0;
+      if (*emptyStreamVector == 0)
+        file-&gt;HasStream = 1;
+      else
+        file-&gt;HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);
+      if(file-&gt;HasStream)
+      {
+        file-&gt;IsDirectory = 0;
+        file-&gt;Size = (*unPackSizes)[sizeIndex];
+        file-&gt;FileCRC = (*digests)[sizeIndex];
+        file-&gt;IsFileCRCDefined = (Byte)(*digestsDefined)[sizeIndex];
+        sizeIndex++;
+      }
+      else
+      {
+        if (*emptyFileVector == 0)
+          file-&gt;IsDirectory = 1;
+        else
+          file-&gt;IsDirectory = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
+        emptyFileIndex++;
+        file-&gt;Size = 0;
+        file-&gt;IsFileCRCDefined = 0;
+      }
+    }
+  }
+  return SzArDbExFill(db, allocMain-&gt;Alloc);
+}
+
+SZ_RESULT SzReadHeader(
+    CSzData *sd, 
+    CArchiveDatabaseEx *db, 
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp)
+{
+  CFileSize *unPackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  Byte *emptyStreamVector = 0;
+  Byte *emptyFileVector = 0;
+  SZ_RESULT res = SzReadHeader2(sd, db, 
+      &amp;unPackSizes, &amp;digestsDefined, &amp;digests,
+      &amp;emptyStreamVector, &amp;emptyFileVector,
+      allocMain, allocTemp);
+  allocTemp-&gt;Free(unPackSizes);
+  allocTemp-&gt;Free(digestsDefined);
+  allocTemp-&gt;Free(digests);
+  allocTemp-&gt;Free(emptyStreamVector);
+  allocTemp-&gt;Free(emptyFileVector);
+  return res;
+} 
+
+SZ_RESULT SzReadAndDecodePackedStreams2(
+    ISzInStream *inStream, 
+    CSzData *sd,
+    CSzByteBuffer *outBuffer,
+    CFileSize baseOffset, 
+    CArchiveDatabase *db,
+    CFileSize **unPackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    #ifndef _LZMA_IN_CB
+    Byte **inBuffer,
+    #endif
+    ISzAlloc *allocTemp)
+{
+
+  UInt32 numUnPackStreams = 0;
+  CFileSize dataStartPos;
+  CFolder *folder;
+  #ifndef _LZMA_IN_CB
+  CFileSize packSize = 0;
+  UInt32 i = 0;
+  #endif
+  CFileSize unPackSize;
+  size_t outRealSize;
+  SZ_RESULT res;
+
+  RINOK(SzReadStreamsInfo(sd, &amp;dataStartPos, db,
+      &amp;numUnPackStreams,  unPackSizes, digestsDefined, digests, 
+      allocTemp-&gt;Alloc, allocTemp));
+  
+  dataStartPos += baseOffset;
+  if (db-&gt;NumFolders != 1)
+    return SZE_ARCHIVE_ERROR;
+
+  folder = db-&gt;Folders;
+  unPackSize = SzFolderGetUnPackSize(folder);
+  
+  RINOK(inStream-&gt;Seek(inStream, dataStartPos));
+
+  #ifndef _LZMA_IN_CB
+  for (i = 0; i &lt; db-&gt;NumPackStreams; i++)
+    packSize += db-&gt;PackSizes[i];
+
+  MY_ALLOC(Byte, *inBuffer, (size_t)packSize, allocTemp-&gt;Alloc);
+
+  RINOK(SafeReadDirect(inStream, *inBuffer, (size_t)packSize));
+  #endif
+
+  if (!SzByteBufferCreate(outBuffer, (size_t)unPackSize, allocTemp-&gt;Alloc))
+    return SZE_OUTOFMEMORY;
+  
+  res = SzDecode(db-&gt;PackSizes, folder, 
+          #ifdef _LZMA_IN_CB
+          inStream,
+          #else
+          *inBuffer, 
+          #endif
+          outBuffer-&gt;Items, (size_t)unPackSize,
+          &amp;outRealSize, allocTemp);
+  RINOK(res)
+  if (outRealSize != (UInt32)unPackSize)
+    return SZE_FAIL;
+  if (folder-&gt;UnPackCRCDefined)
+    if (!CrcVerifyDigest(folder-&gt;UnPackCRC, outBuffer-&gt;Items, (size_t)unPackSize))
+      return SZE_FAIL;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadAndDecodePackedStreams(
+    ISzInStream *inStream, 
+    CSzData *sd,
+    CSzByteBuffer *outBuffer,
+    CFileSize baseOffset, 
+    ISzAlloc *allocTemp)
+{
+  CArchiveDatabase db;
+  CFileSize *unPackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  #ifndef _LZMA_IN_CB
+  Byte *inBuffer = 0;
+  #endif
+  SZ_RESULT res;
+  SzArchiveDatabaseInit(&amp;db);
+  res = SzReadAndDecodePackedStreams2(inStream, sd, outBuffer, baseOffset, 
+    &amp;db, &amp;unPackSizes, &amp;digestsDefined, &amp;digests, 
+    #ifndef _LZMA_IN_CB
+    &amp;inBuffer,
+    #endif
+    allocTemp);
+  SzArchiveDatabaseFree(&amp;db, allocTemp-&gt;Free);
+  allocTemp-&gt;Free(unPackSizes);
+  allocTemp-&gt;Free(digestsDefined);
+  allocTemp-&gt;Free(digests);
+  #ifndef _LZMA_IN_CB
+  allocTemp-&gt;Free(inBuffer);
+  #endif
+  return res;
+}
+
+SZ_RESULT SzArchiveOpen2(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp)
+{
+  Byte signature[k7zSignatureSize];
+  Byte version;
+  UInt32 crcFromArchive;
+  UInt64 nextHeaderOffset;
+  UInt64 nextHeaderSize;
+  UInt32 nextHeaderCRC;
+  UInt32 crc;
+  CFileSize pos = 0;
+  CSzByteBuffer buffer;
+  CSzData sd;
+  SZ_RESULT res;
+
+  RINOK(SafeReadDirect(inStream, signature, k7zSignatureSize));
+
+  if (!TestSignatureCandidate(signature))
+    return SZE_ARCHIVE_ERROR;
+
+  /*
+  db.Clear();
+  db.ArchiveInfo.StartPosition = _arhiveBeginStreamPosition;
+  */
+  RINOK(SafeReadDirectByte(inStream, &amp;version));
+  if (version != k7zMajorVersion)
+    return SZE_ARCHIVE_ERROR;
+  RINOK(SafeReadDirectByte(inStream, &amp;version));
+
+  RINOK(SafeReadDirectUInt32(inStream, &amp;crcFromArchive));
+
+  CrcInit(&amp;crc);
+  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderOffset));
+  CrcUpdateUInt64(&amp;crc, nextHeaderOffset);
+  RINOK(SafeReadDirectUInt64(inStream, &amp;nextHeaderSize));
+  CrcUpdateUInt64(&amp;crc, nextHeaderSize);
+  RINOK(SafeReadDirectUInt32(inStream, &amp;nextHeaderCRC));
+  CrcUpdateUInt32(&amp;crc, nextHeaderCRC);
+
+  pos = k7zStartHeaderSize;
+  db-&gt;ArchiveInfo.StartPositionAfterHeader = pos;
+  
+  if (CrcGetDigest(&amp;crc) != crcFromArchive)
+    return SZE_ARCHIVE_ERROR;
+
+  if (nextHeaderSize == 0)
+    return SZ_OK;
+
+  RINOK(inStream-&gt;Seek(inStream, (CFileSize)(pos + nextHeaderOffset)));
+
+  if (!SzByteBufferCreate(&amp;buffer, (size_t)nextHeaderSize, allocTemp-&gt;Alloc))
+    return SZE_OUTOFMEMORY;
+
+  res = SafeReadDirect(inStream, buffer.Items, (size_t)nextHeaderSize);
+  if (res == SZ_OK)
+  {
+    if (CrcVerifyDigest(nextHeaderCRC, buffer.Items, (UInt32)nextHeaderSize))
+    {
+      while (1)
+      {
+        UInt64 type;
+        sd.Data = buffer.Items;
+        sd.Size = buffer.Capacity;
+        res = SzReadID(&amp;sd, &amp;type);
+        if (res != SZ_OK)
+          break;
+        if (type == k7zIdHeader)
+        {
+          res = SzReadHeader(&amp;sd, db, allocMain, allocTemp);
+          break;
+        }
+        if (type != k7zIdEncodedHeader)
+        {
+          res = SZE_ARCHIVE_ERROR;
+          break;
+        }
+        {
+          CSzByteBuffer outBuffer;
+          res = SzReadAndDecodePackedStreams(inStream, &amp;sd, &amp;outBuffer, 
+              db-&gt;ArchiveInfo.StartPositionAfterHeader, 
+              allocTemp);
+          if (res != SZ_OK)
+          {
+            SzByteBufferFree(&amp;outBuffer, allocTemp-&gt;Free);
+            break;
+          }
+          SzByteBufferFree(&amp;buffer, allocTemp-&gt;Free);
+          buffer.Items = outBuffer.Items;
+          buffer.Capacity = outBuffer.Capacity;
+        }
+      }
+    }
+  }
+  SzByteBufferFree(&amp;buffer, allocTemp-&gt;Free);
+  return res;
+}
+
+SZ_RESULT SzArchiveOpen(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp)
+{
+  SZ_RESULT res = SzArchiveOpen2(inStream, db, allocMain, allocTemp);
+  if (res != SZ_OK)
+    SzArDbExFree(db, allocMain-&gt;Free);
+  return res;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,55 @@
+/* 7zIn.h */
+
+#ifndef __7Z_IN_H
+#define __7Z_IN_H
+
+#include &quot;7zHeader.h&quot;
+#include &quot;7zItem.h&quot;
+#include &quot;7zAlloc.h&quot;
+ 
+typedef struct _CInArchiveInfo
+{
+  CFileSize StartPositionAfterHeader; 
+  CFileSize DataStartPosition;
+}CInArchiveInfo;
+
+typedef struct _CArchiveDatabaseEx
+{
+  CArchiveDatabase Database;
+  CInArchiveInfo ArchiveInfo;
+  UInt32 *FolderStartPackStreamIndex;
+  CFileSize *PackStreamStartPositions;
+  UInt32 *FolderStartFileIndex;
+  UInt32 *FileIndexToFolderIndexMap;
+}CArchiveDatabaseEx;
+
+void SzArDbExInit(CArchiveDatabaseEx *db);
+void SzArDbExFree(CArchiveDatabaseEx *db, void (*freeFunc)(void *));
+CFileSize SzArDbGetFolderStreamPos(CArchiveDatabaseEx *db, UInt32 folderIndex, UInt32 indexInFolder);
+CFileSize SzArDbGetFolderFullPackSize(CArchiveDatabaseEx *db, UInt32 folderIndex);
+
+typedef struct _ISzInStream
+{
+  #ifdef _LZMA_IN_CB
+  SZ_RESULT (*Read)(
+      void *object,           /* pointer to ISzInStream itself */
+      void **buffer,          /* out: pointer to buffer with data */
+      size_t maxRequiredSize, /* max required size to read */
+      size_t *processedSize); /* real processed size. 
+                                 processedSize can be less than maxRequiredSize.
+                                 If processedSize == 0, then there are no more 
+                                 bytes in stream. */
+  #else
+  SZ_RESULT (*Read)(void *object, void *buffer, size_t size, size_t *processedSize);
+  #endif
+  SZ_RESULT (*Seek)(void *object, CFileSize pos);
+} ISzInStream;
+
+ 
+int SzArchiveOpen(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp);
+ 
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zIn.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,133 @@
+/* 7zItem.c */
+
+#include &quot;7zItem.h&quot;
+#include &quot;7zAlloc.h&quot;
+
+void SzCoderInfoInit(CCoderInfo *coder)
+{
+  SzByteBufferInit(&amp;coder-&gt;Properties);
+}
+
+void SzCoderInfoFree(CCoderInfo *coder, void (*freeFunc)(void *p))
+{
+  SzByteBufferFree(&amp;coder-&gt;Properties, freeFunc);
+  SzCoderInfoInit(coder);
+}
+
+void SzFolderInit(CFolder *folder)
+{
+  folder-&gt;NumCoders = 0;
+  folder-&gt;Coders = 0;
+  folder-&gt;NumBindPairs = 0;
+  folder-&gt;BindPairs = 0;
+  folder-&gt;NumPackStreams = 0;
+  folder-&gt;PackStreams = 0;
+  folder-&gt;UnPackSizes = 0;
+  folder-&gt;UnPackCRCDefined = 0;
+  folder-&gt;UnPackCRC = 0;
+  folder-&gt;NumUnPackStreams = 0;
+}
+
+void SzFolderFree(CFolder *folder, void (*freeFunc)(void *p))
+{
+  UInt32 i;
+  for (i = 0; i &lt; folder-&gt;NumCoders; i++)
+    SzCoderInfoFree(&amp;folder-&gt;Coders[i], freeFunc);
+  freeFunc(folder-&gt;Coders);
+  freeFunc(folder-&gt;BindPairs);
+  freeFunc(folder-&gt;PackStreams);
+  freeFunc(folder-&gt;UnPackSizes);
+  SzFolderInit(folder);
+}
+
+UInt32 SzFolderGetNumOutStreams(CFolder *folder)
+{
+  UInt32 result = 0;
+  UInt32 i;
+  for (i = 0; i &lt; folder-&gt;NumCoders; i++)
+    result += folder-&gt;Coders[i].NumOutStreams;
+  return result;
+}
+
+int SzFolderFindBindPairForInStream(CFolder *folder, UInt32 inStreamIndex)
+{
+  UInt32 i;
+  for(i = 0; i &lt; folder-&gt;NumBindPairs; i++)
+    if (folder-&gt;BindPairs[i].InIndex == inStreamIndex)
+      return i;
+  return -1;
+}
+
+
+int SzFolderFindBindPairForOutStream(CFolder *folder, UInt32 outStreamIndex)
+{
+  UInt32 i;
+  for(i = 0; i &lt; folder-&gt;NumBindPairs; i++)
+    if (folder-&gt;BindPairs[i].OutIndex == outStreamIndex)
+      return i;
+  return -1;
+}
+
+CFileSize SzFolderGetUnPackSize(CFolder *folder)
+{ 
+  int i = (int)SzFolderGetNumOutStreams(folder);
+  if (i == 0)
+    return 0;
+  for (i--; i &gt;= 0; i--)
+    if (SzFolderFindBindPairForOutStream(folder, i) &lt; 0)
+      return folder-&gt;UnPackSizes[i];
+  /* throw 1; */
+  return 0;
+}
+
+/*
+int FindPackStreamArrayIndex(int inStreamIndex) const
+{
+  for(int i = 0; i &lt; PackStreams.Size(); i++)
+  if (PackStreams[i] == inStreamIndex)
+    return i;
+  return -1;
+}
+*/
+
+void SzFileInit(CFileItem *fileItem)
+{
+  fileItem-&gt;IsFileCRCDefined = 0;
+  fileItem-&gt;HasStream = 1;
+  fileItem-&gt;IsDirectory = 0;
+  fileItem-&gt;IsAnti = 0;
+  fileItem-&gt;Name = 0;
+}
+
+void SzFileFree(CFileItem *fileItem, void (*freeFunc)(void *p))
+{
+  freeFunc(fileItem-&gt;Name);
+  SzFileInit(fileItem);
+}
+
+void SzArchiveDatabaseInit(CArchiveDatabase *db)
+{
+  db-&gt;NumPackStreams = 0;
+  db-&gt;PackSizes = 0;
+  db-&gt;PackCRCsDefined = 0;
+  db-&gt;PackCRCs = 0;
+  db-&gt;NumFolders = 0;
+  db-&gt;Folders = 0;
+  db-&gt;NumFiles = 0;
+  db-&gt;Files = 0;
+}
+
+void SzArchiveDatabaseFree(CArchiveDatabase *db, void (*freeFunc)(void *))
+{
+  UInt32 i;
+  for (i = 0; i &lt; db-&gt;NumFolders; i++)
+    SzFolderFree(&amp;db-&gt;Folders[i], freeFunc);
+  for (i = 0; i &lt; db-&gt;NumFiles; i++)
+    SzFileFree(&amp;db-&gt;Files[i], freeFunc);
+  freeFunc(db-&gt;PackSizes);
+  freeFunc(db-&gt;PackCRCsDefined);
+  freeFunc(db-&gt;PackCRCs);
+  freeFunc(db-&gt;Folders);
+  freeFunc(db-&gt;Files);
+  SzArchiveDatabaseInit(db);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,90 @@
+/* 7zItem.h */
+
+#ifndef __7Z_ITEM_H
+#define __7Z_ITEM_H
+
+#include &quot;7zMethodID.h&quot;
+#include &quot;7zHeader.h&quot;
+#include &quot;7zBuffer.h&quot;
+
+typedef struct _CCoderInfo
+{
+  UInt32 NumInStreams;
+  UInt32 NumOutStreams;
+  CMethodID MethodID;
+  CSzByteBuffer Properties;
+}CCoderInfo;
+
+void SzCoderInfoInit(CCoderInfo *coder);
+void SzCoderInfoFree(CCoderInfo *coder, void (*freeFunc)(void *p));
+
+typedef struct _CBindPair
+{
+  UInt32 InIndex;
+  UInt32 OutIndex;
+}CBindPair;
+
+typedef struct _CFolder
+{
+  UInt32 NumCoders;
+  CCoderInfo *Coders;
+  UInt32 NumBindPairs;
+  CBindPair *BindPairs;
+  UInt32 NumPackStreams; 
+  UInt32 *PackStreams;
+  CFileSize *UnPackSizes;
+  int UnPackCRCDefined;
+  UInt32 UnPackCRC;
+
+  UInt32 NumUnPackStreams;
+}CFolder;
+
+void SzFolderInit(CFolder *folder);
+CFileSize SzFolderGetUnPackSize(CFolder *folder);
+int SzFolderFindBindPairForInStream(CFolder *folder, UInt32 inStreamIndex);
+UInt32 SzFolderGetNumOutStreams(CFolder *folder);
+CFileSize SzFolderGetUnPackSize(CFolder *folder);
+
+/* #define CArchiveFileTime UInt64 */
+
+typedef struct _CFileItem
+{
+  /*
+  CArchiveFileTime LastWriteTime;
+  CFileSize StartPos;
+  UInt32 Attributes; 
+  */
+  CFileSize Size;
+  UInt32 FileCRC;
+  char *Name;
+
+  Byte IsFileCRCDefined;
+  Byte HasStream;
+  Byte IsDirectory;
+  Byte IsAnti;
+  /*
+  int AreAttributesDefined;
+  int IsLastWriteTimeDefined;
+  int IsStartPosDefined;
+  */
+}CFileItem;
+
+void SzFileInit(CFileItem *fileItem);
+
+typedef struct _CArchiveDatabase
+{
+  UInt32 NumPackStreams;
+  CFileSize *PackSizes;
+  Byte *PackCRCsDefined;
+  UInt32 *PackCRCs;
+  UInt32 NumFolders;
+  CFolder *Folders;
+  UInt32 NumFiles;
+  CFileItem *Files;
+}CArchiveDatabase;
+
+void SzArchiveDatabaseInit(CArchiveDatabase *db);
+void SzArchiveDatabaseFree(CArchiveDatabase *db, void (*freeFunc)(void *));
+
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zItem.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMain.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMain.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMain.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,225 @@
+/* 
+7zMain.c
+Test application for 7z Decoder
+LZMA SDK 4.43 Copyright (c) 1999-2006 Igor Pavlov (2006-06-04)
+*/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;7zCrc.h&quot;
+#include &quot;7zIn.h&quot;
+#include &quot;7zExtract.h&quot;
+
+typedef struct _CFileInStream
+{
+  ISzInStream InStream;
+  FILE *File;
+} CFileInStream;
+
+#ifdef _LZMA_IN_CB
+
+#define kBufferSize (1 &lt;&lt; 12)
+Byte g_Buffer[kBufferSize];
+
+SZ_RESULT SzFileReadImp(void *object, void **buffer, size_t maxRequiredSize, size_t *processedSize)
+{
+  CFileInStream *s = (CFileInStream *)object;
+  size_t processedSizeLoc;
+  if (maxRequiredSize &gt; kBufferSize)
+    maxRequiredSize = kBufferSize;
+  processedSizeLoc = fread(g_Buffer, 1, maxRequiredSize, s-&gt;File);
+  *buffer = g_Buffer;
+  if (processedSize != 0)
+    *processedSize = processedSizeLoc;
+  return SZ_OK;
+}
+
+#else
+
+SZ_RESULT SzFileReadImp(void *object, void *buffer, size_t size, size_t *processedSize)
+{
+  CFileInStream *s = (CFileInStream *)object;
+  size_t processedSizeLoc = fread(buffer, 1, size, s-&gt;File);
+  if (processedSize != 0)
+    *processedSize = processedSizeLoc;
+  return SZ_OK;
+}
+
+#endif
+
+SZ_RESULT SzFileSeekImp(void *object, CFileSize pos)
+{
+  CFileInStream *s = (CFileInStream *)object;
+  int res = fseek(s-&gt;File, (long)pos, SEEK_SET);
+  if (res == 0)
+    return SZ_OK;
+  return SZE_FAIL;
+}
+
+void PrintError(char *sz)
+{
+  printf(&quot;\nERROR: %s\n&quot;, sz);
+}
+
+int main(int numargs, char *args[])
+{
+  CFileInStream archiveStream;
+  CArchiveDatabaseEx db;
+  SZ_RESULT res;
+  ISzAlloc allocImp;
+  ISzAlloc allocTempImp;
+
+  printf(&quot;\n7z ANSI-C Decoder 4.43  Copyright (c) 1999-2006 Igor Pavlov  2006-06-04\n&quot;);
+  if (numargs == 1)
+  {
+    printf(
+      &quot;\nUsage: 7zDec &lt;command&gt; &lt;archive_name&gt;\n\n&quot;
+      &quot;&lt;Commands&gt;\n&quot;
+      &quot;  e: Extract files from archive\n&quot;
+      &quot;  l: List contents of archive\n&quot;
+      &quot;  t: Test integrity of archive\n&quot;);
+    return 0;
+  }
+  if (numargs &lt; 3)
+  {
+    PrintError(&quot;incorrect command&quot;);
+    return 1;
+  }
+
+  archiveStream.File = fopen(args[2], &quot;rb&quot;);
+  if (archiveStream.File == 0)
+  {
+    PrintError(&quot;can not open input file&quot;);
+    return 1;
+  }
+
+  archiveStream.InStream.Read = SzFileReadImp;
+  archiveStream.InStream.Seek = SzFileSeekImp;
+
+  allocImp.Alloc = SzAlloc;
+  allocImp.Free = SzFree;
+
+  allocTempImp.Alloc = SzAllocTemp;
+  allocTempImp.Free = SzFreeTemp;
+
+  InitCrcTable();
+  SzArDbExInit(&amp;db);
+  res = SzArchiveOpen(&amp;archiveStream.InStream, &amp;db, &amp;allocImp, &amp;allocTempImp);
+  if (res == SZ_OK)
+  {
+    char *command = args[1];
+    int listCommand = 0;
+    int testCommand = 0;
+    int extractCommand = 0;
+    if (strcmp(command, &quot;l&quot;) == 0)
+      listCommand = 1;
+    if (strcmp(command, &quot;t&quot;) == 0)
+      testCommand = 1;
+    else if (strcmp(command, &quot;e&quot;) == 0)
+      extractCommand = 1;
+
+    if (listCommand)
+    {
+      UInt32 i;
+      for (i = 0; i &lt; db.Database.NumFiles; i++)
+      {
+        CFileItem *f = db.Database.Files + i;
+        printf(&quot;%10d  %s\n&quot;, (int)f-&gt;Size, f-&gt;Name);
+      }
+    }
+    else if (testCommand || extractCommand)
+    {
+      UInt32 i;
+
+      /*
+      if you need cache, use these 3 variables.
+      if you use external function, you can make these variable as static.
+      */
+      UInt32 blockIndex = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */
+      Byte *outBuffer = 0; /* it must be 0 before first call for each new archive. */
+      size_t outBufferSize = 0;  /* it can have any value before first call (if outBuffer = 0) */
+
+      printf(&quot;\n&quot;);
+      for (i = 0; i &lt; db.Database.NumFiles; i++)
+      {
+        size_t offset;
+        size_t outSizeProcessed;
+        CFileItem *f = db.Database.Files + i;
+        if (f-&gt;IsDirectory)
+          printf(&quot;Directory &quot;);
+        else
+          printf(testCommand ? 
+            &quot;Testing   &quot;:
+            &quot;Extracting&quot;);
+        printf(&quot; %s&quot;, f-&gt;Name);
+        if (f-&gt;IsDirectory)
+        {
+          printf(&quot;\n&quot;);
+          continue;
+        }
+        res = SzExtract(&amp;archiveStream.InStream, &amp;db, i, 
+            &amp;blockIndex, &amp;outBuffer, &amp;outBufferSize, 
+            &amp;offset, &amp;outSizeProcessed, 
+            &amp;allocImp, &amp;allocTempImp);
+        if (res != SZ_OK)
+          break;
+        if (!testCommand)
+        {
+          FILE *outputHandle;
+          UInt32 processedSize;
+          char *fileName = f-&gt;Name;
+          size_t nameLen = strlen(f-&gt;Name);
+          for (; nameLen &gt; 0; nameLen--)
+            if (f-&gt;Name[nameLen - 1] == '/')
+            {
+              fileName = f-&gt;Name + nameLen;
+              break;
+            }
+            
+          outputHandle = fopen(fileName, &quot;wb+&quot;);
+          if (outputHandle == 0)
+          {
+            PrintError(&quot;can not open output file&quot;);
+            res = SZE_FAIL;
+            break;
+          }
+          processedSize = fwrite(outBuffer + offset, 1, outSizeProcessed, outputHandle);
+          if (processedSize != outSizeProcessed)
+          {
+            PrintError(&quot;can not write output file&quot;);
+            res = SZE_FAIL;
+            break;
+          }
+          if (fclose(outputHandle))
+          {
+            PrintError(&quot;can not close output file&quot;);
+            res = SZE_FAIL;
+            break;
+          }
+        }
+        printf(&quot;\n&quot;);
+      }
+      allocImp.Free(outBuffer);
+    }
+    else
+    {
+      PrintError(&quot;incorrect command&quot;);
+      res = SZE_FAIL;
+    }
+  }
+  SzArDbExFree(&amp;db, allocImp.Free);
+
+  fclose(archiveStream.File);
+  if (res == SZ_OK)
+  {
+    printf(&quot;\nEverything is Ok\n&quot;);
+    return 0;
+  }
+  if (res == SZE_OUTOFMEMORY)
+    PrintError(&quot;can not allocate memory&quot;);
+  else     
+    printf(&quot;\nERROR #%d\n&quot;, res);
+  return 1;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMain.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,14 @@
+/* 7zMethodID.c */
+
+#include &quot;7zMethodID.h&quot;
+
+int AreMethodsEqual(CMethodID *a1, CMethodID *a2)
+{
+  int i;
+  if (a1-&gt;IDSize != a2-&gt;IDSize)
+    return 0;
+  for (i = 0; i &lt; a1-&gt;IDSize; i++)
+    if (a1-&gt;ID[i] != a2-&gt;ID[i])
+      return 0;
+  return 1;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,18 @@
+/* 7zMethodID.h */
+
+#ifndef __7Z_METHOD_ID_H
+#define __7Z_METHOD_ID_H
+
+#include &quot;7zTypes.h&quot;
+
+#define kMethodIDSize 15
+  
+typedef struct _CMethodID
+{
+  Byte ID[kMethodIDSize];
+  Byte IDSize;
+} CMethodID;
+
+int AreMethodsEqual(CMethodID *a1, CMethodID *a2);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zMethodID.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zTypes.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zTypes.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zTypes.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,67 @@
+/* 7zTypes.h */
+
+#ifndef __COMMON_TYPES_H
+#define __COMMON_TYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _SZ_NO_INT_64 */
+/* define it your compiler doesn't support long long int */
+
+#ifndef _7ZIP_UINT64_DEFINED
+#define _7ZIP_UINT64_DEFINED
+#ifdef _SZ_NO_INT_64
+typedef unsigned long UInt64;
+#else
+#ifdef _MSC_VER
+typedef unsigned __int64 UInt64;
+#else
+typedef unsigned long long int UInt64;
+#endif
+#endif
+#endif
+
+
+/* #define _SZ_FILE_SIZE_64 */
+/* Use _SZ_FILE_SIZE_64 if you need support for files larger than 4 GB*/
+
+#ifndef CFileSize
+#ifdef _SZ_FILE_SIZE_64
+typedef UInt64 CFileSize; 
+#else
+typedef UInt32 CFileSize; 
+#endif
+#endif
+
+#define SZ_RESULT int
+
+#define SZ_OK (0)
+#define SZE_DATA_ERROR (1)
+#define SZE_OUTOFMEMORY (2)
+#define SZE_CRC_ERROR (3)
+
+#define SZE_NOTIMPL (4)
+#define SZE_FAIL (5)
+
+#define SZE_ARCHIVE_ERROR (6)
+
+#define RINOK(x) { int __result_ = (x); if(__result_ != 0) return __result_; }
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7zTypes.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,182 @@
+# Microsoft Developer Studio Project File - Name=&quot;7z_C&quot; - Package Owner=&lt;4&gt;
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
+
+CFG=7z_C - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;7z_C.mak&quot;.
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;7z_C.mak&quot; CFG=&quot;7z_C - Win32 Debug&quot;
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE &quot;7z_C - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE &quot;7z_C - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName &quot;&quot;
+# PROP Scc_LocalPath &quot;&quot;
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  &quot;$(CFG)&quot; == &quot;7z_C - Win32 Release&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;Release&quot;
+# PROP BASE Intermediate_Dir &quot;Release&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;Release&quot;
+# PROP Intermediate_Dir &quot;Release&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
+# ADD CPP /nologo /W4 /GX /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /D &quot;_LZMA_PROB32&quot; /D &quot;_LZMA_IN_CB&quot; /YX /FD /c
+# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;Release/7zDec.exe&quot;
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;7z_C - Win32 Debug&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;Debug&quot;
+# PROP BASE Intermediate_Dir &quot;Debug&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;Debug&quot;
+# PROP Intermediate_Dir &quot;Debug&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /D &quot;_LZMA_PROB32&quot; /D &quot;_LZMA_IN_CB&quot; /YX /FD /GZ /c
+# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;Debug/7zDec.exe&quot; /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name &quot;7z_C - Win32 Release&quot;
+# Name &quot;7z_C - Win32 Debug&quot;
+# Begin Group &quot;LZMA&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\..\Compress\LZMA_C\LzmaDecode.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Compress\LZMA_C\LzmaDecode.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Compress\LZMA_C\LzmaTypes.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\7zAlloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zAlloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zBuffer.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zBuffer.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zCrc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zCrc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zMain.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zMethodID.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zMethodID.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zTypes.h
+# End Source File
+# End Target
+# End Project


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsw
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsw	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsw	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: &quot;7z_C&quot;=.\7z_C.dsp - Package Owner=&lt;4&gt;
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;4&gt;
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;3&gt;
+{{{
+}}}
+
+###############################################################################
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/7z_C.dsw
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,55 @@
+PROG = 7zDec.exe
+
+!IFNDEF O
+!IFDEF CPU
+O=$(CPU)
+!ELSE
+O=O
+!ENDIF
+!ENDIF
+
+CFLAGS = $(CFLAGS) -nologo -c -Fo$O/ -GS- 
+CFLAGS_O1 = $(CFLAGS) -O1
+CFLAGS_O2 = $(CFLAGS) -O2
+
+LFLAGS = $(LFLAGS) -nologo -OPT:NOWIN98
+
+PROGPATH = $O\$(PROG)
+
+COMPL_O1   = $(CPP) $(CFLAGS_O1) $**
+COMPL_O2   = $(CPP) $(CFLAGS_O2) $**
+COMPL      = $(CPP) $(CFLAGS_O1) $**
+
+
+7Z_OBJS = \
+  $O\7zAlloc.obj \
+  $O\7zBuffer.obj \
+  $O\7zCrc.obj \
+  $O\7zDecode.obj \
+  $O\7zExtract.obj \
+  $O\7zHeader.obj \
+  $O\7zIn.obj \
+  $O\7zItem.obj \
+  $O\7zMain.obj \
+  $O\7zMethodID.obj \
+
+OBJS = \
+  $(7Z_OBJS) \
+  $O\LzmaDecode.obj \
+
+all: $(PROGPATH) 
+
+clean:
+	-del /Q $(PROGPATH) $O\*.exe $O\*.dll $O\*.obj $O\*.lib $O\*.exp $O\*.res $O\*.pch 
+
+$O:
+	if not exist &quot;$O&quot; mkdir &quot;$O&quot;
+
+$(PROGPATH): $O $(OBJS)
+	link $(LFLAGS) -out:$(PROGPATH) $(OBJS) $(LIBS)
+
+
+$(7Z_OBJS): $(*B).c
+	$(COMPL)
+$O\LzmaDecode.obj: ../../Compress/LZMA_C/$(*B).c
+	$(COMPL_O2)


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile.gcc
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile.gcc	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile.gcc	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,50 @@
+PROG = 7zDec
+CXX = g++
+LIB = 
+RM = rm -f
+CFLAGS = -c -O2 -Wall
+
+OBJS = 7zAlloc.o 7zBuffer.o 7zCrc.o 7zDecode.o 7zExtract.o 7zHeader.o 7zIn.o 7zItem.o 7zMain.o 7zMethodID.o LzmaDecode.o 
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB)
+
+7zAlloc.o: 7zAlloc.c
+	$(CXX) $(CFLAGS) 7zAlloc.c
+
+7zBuffer.o: 7zBuffer.c
+	$(CXX) $(CFLAGS) 7zBuffer.c
+
+7zCrc.o: 7zCrc.c
+	$(CXX) $(CFLAGS) 7zCrc.c
+
+7zDecode.o: 7zDecode.c
+	$(CXX) $(CFLAGS) 7zDecode.c
+
+7zExtract.o: 7zExtract.c
+	$(CXX) $(CFLAGS) 7zExtract.c
+
+7zHeader.o: 7zHeader.c
+	$(CXX) $(CFLAGS) 7zHeader.c
+
+7zIn.o: 7zIn.c
+	$(CXX) $(CFLAGS) 7zIn.c
+
+7zItem.o: 7zItem.c
+	$(CXX) $(CFLAGS) 7zItem.c
+
+7zMain.o: 7zMain.c
+	$(CXX) $(CFLAGS) 7zMain.c
+
+7zMethodID.o: 7zMethodID.c
+	$(CXX) $(CFLAGS) 7zMethodID.c
+
+LzmaDecode.o: ../../Compress/LZMA_C/LzmaDecode.c
+	$(CXX) $(CFLAGS) ../../Compress/LZMA_C/LzmaDecode.c
+
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Archive/7z_C/makefile.gcc
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,251 @@
+// FileStreams.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#ifndef _WIN32
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;errno.h&gt;
+#endif
+
+#include &quot;FileStreams.h&quot;
+
+static inline HRESULT ConvertBoolToHRESULT(bool result)
+{
+  // return result ? S_OK: E_FAIL;
+  #ifdef _WIN32
+  return result ? S_OK: (::GetLastError());
+  #else
+  return result ? S_OK: E_FAIL;
+  #endif
+}
+
+bool CInFileStream::Open(LPCTSTR fileName)
+{
+  return File.Open(fileName);
+}
+
+#ifdef _WIN32
+#ifndef _UNICODE
+bool CInFileStream::Open(LPCWSTR fileName)
+{
+  return File.Open(fileName);
+}
+#endif
+#endif
+
+STDMETHODIMP CInFileStream::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  #ifdef _WIN32
+  
+  UInt32 realProcessedSize;
+  bool result = File.ReadPart(data, size, realProcessedSize);
+  if(processedSize != NULL)
+    *processedSize = realProcessedSize;
+  return ConvertBoolToHRESULT(result);
+  
+  #else
+  
+  if(processedSize != NULL)
+    *processedSize = 0;
+  ssize_t res = File.Read(data, (size_t)size);
+  if (res == -1)
+    return E_FAIL;
+  if(processedSize != NULL)
+    *processedSize = (UInt32)res;
+  return S_OK;
+
+  #endif
+}
+
+#ifndef _WIN32_WCE
+STDMETHODIMP CStdInFileStream::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  #ifdef _WIN32
+  UInt32 realProcessedSize;
+  BOOL res = ::ReadFile(GetStdHandle(STD_INPUT_HANDLE), 
+      data, size, (DWORD *)&amp;realProcessedSize, NULL);
+  if(processedSize != NULL)
+    *processedSize = realProcessedSize;
+  if (res == FALSE &amp;&amp; GetLastError() == ERROR_BROKEN_PIPE)
+    return S_OK;
+  return ConvertBoolToHRESULT(res != FALSE);
+  
+  #else
+
+  if(processedSize != NULL)
+    *processedSize = 0;
+  ssize_t res;
+  do 
+  {
+    res = read(0, data, (size_t)size);
+  } 
+  while (res &lt; 0 &amp;&amp; (errno == EINTR));
+  if (res == -1)
+    return E_FAIL;
+  if(processedSize != NULL)
+    *processedSize = (UInt32)res;
+  return S_OK;
+  
+  #endif
+}
+  
+#endif
+
+STDMETHODIMP CInFileStream::Seek(Int64 offset, UInt32 seekOrigin, 
+    UInt64 *newPosition)
+{
+  if(seekOrigin &gt;= 3)
+    return STG_E_INVALIDFUNCTION;
+
+  #ifdef _WIN32
+
+  UInt64 realNewPosition;
+  bool result = File.Seek(offset, seekOrigin, realNewPosition);
+  if(newPosition != NULL)
+    *newPosition = realNewPosition;
+  return ConvertBoolToHRESULT(result);
+  
+  #else
+  
+  off_t res = File.Seek(offset, seekOrigin);
+  if (res == -1)
+    return E_FAIL;
+  if(newPosition != NULL)
+    *newPosition = (UInt64)res;
+  return S_OK;
+  
+  #endif
+}
+
+STDMETHODIMP CInFileStream::GetSize(UInt64 *size)
+{
+  return ConvertBoolToHRESULT(File.GetLength(*size));
+}
+
+
+//////////////////////////
+// COutFileStream
+
+bool COutFileStream::Create(LPCTSTR fileName, bool createAlways)
+{
+  return File.Create(fileName, createAlways);
+}
+
+#ifdef _WIN32
+#ifndef _UNICODE
+bool COutFileStream::Create(LPCWSTR fileName, bool createAlways)
+{
+  return File.Create(fileName, createAlways);
+}
+#endif
+#endif
+
+STDMETHODIMP COutFileStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  #ifdef _WIN32
+
+  UInt32 realProcessedSize;
+  bool result = File.WritePart(data, size, realProcessedSize);
+  if(processedSize != NULL)
+    *processedSize = realProcessedSize;
+  return ConvertBoolToHRESULT(result);
+  
+  #else
+  
+  if(processedSize != NULL)
+    *processedSize = 0;
+  ssize_t res = File.Write(data, (size_t)size);
+  if (res == -1)
+    return E_FAIL;
+  if(processedSize != NULL)
+    *processedSize = (UInt32)res;
+  return S_OK;
+  
+  #endif
+}
+  
+STDMETHODIMP COutFileStream::Seek(Int64 offset, UInt32 seekOrigin, 
+    UInt64 *newPosition)
+{
+  if(seekOrigin &gt;= 3)
+    return STG_E_INVALIDFUNCTION;
+  #ifdef _WIN32
+
+  UInt64 realNewPosition;
+  bool result = File.Seek(offset, seekOrigin, realNewPosition);
+  if(newPosition != NULL)
+    *newPosition = realNewPosition;
+  return ConvertBoolToHRESULT(result);
+  
+  #else
+  
+  off_t res = File.Seek(offset, seekOrigin);
+  if (res == -1)
+    return E_FAIL;
+  if(newPosition != NULL)
+    *newPosition = (UInt64)res;
+  return S_OK;
+  
+  #endif
+}
+
+STDMETHODIMP COutFileStream::SetSize(Int64 newSize)
+{
+  #ifdef _WIN32
+  UInt64 currentPos;
+  if(!File.Seek(0, FILE_CURRENT, currentPos))
+    return E_FAIL;
+  bool result = File.SetLength(newSize);
+  UInt64 currentPos2;
+  result = result &amp;&amp; File.Seek(currentPos, currentPos2);
+  return result ? S_OK : E_FAIL;
+  #else
+  return E_FAIL;
+  #endif
+}
+
+#ifndef _WIN32_WCE
+STDMETHODIMP CStdOutFileStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  if(processedSize != NULL)
+    *processedSize = 0;
+
+  #ifdef _WIN32
+  UInt32 realProcessedSize;
+  BOOL res = TRUE;
+  if (size &gt; 0)
+  {
+    // Seems that Windows doesn't like big amounts writing to stdout.
+    // So we limit portions by 32KB.
+    UInt32 sizeTemp = (1 &lt;&lt; 15); 
+    if (sizeTemp &gt; size)
+      sizeTemp = size;
+    res = ::WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), 
+        data, sizeTemp, (DWORD *)&amp;realProcessedSize, NULL);
+    size -= realProcessedSize;
+    data = (const void *)((const Byte *)data + realProcessedSize);
+    if(processedSize != NULL)
+      *processedSize += realProcessedSize;
+  }
+  return ConvertBoolToHRESULT(res != FALSE);
+
+  #else
+  
+  ssize_t res;
+  do 
+  {
+    res = write(1, data, (size_t)size);
+  } 
+  while (res &lt; 0 &amp;&amp; (errno == EINTR));
+  if (res == -1)
+    return E_FAIL;
+  if(processedSize != NULL)
+    *processedSize = (UInt32)res;
+  return S_OK;
+  
+  return S_OK;
+  #endif
+}
+  
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,98 @@
+// FileStreams.h
+
+#ifndef __FILESTREAMS_H
+#define __FILESTREAMS_H
+
+#ifdef _WIN32
+#include &quot;../../Windows/FileIO.h&quot;
+#else
+#include &quot;../../Common/C_FileIO.h&quot;
+#endif
+
+#include &quot;../IStream.h&quot;
+#include &quot;../../Common/MyCom.h&quot;
+
+class CInFileStream: 
+  public IInStream,
+  public IStreamGetSize,
+  public CMyUnknownImp
+{
+public:
+  #ifdef _WIN32
+  NWindows::NFile::NIO::CInFile File;
+  #else
+  NC::NFile::NIO::CInFile File;
+  #endif
+  CInFileStream() {}
+  virtual ~CInFileStream() {}
+
+  bool Open(LPCTSTR fileName);
+  #ifdef _WIN32
+  #ifndef _UNICODE
+  bool Open(LPCWSTR fileName);
+  #endif
+  #endif
+
+  MY_UNKNOWN_IMP2(IInStream, IStreamGetSize)
+
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
+
+  STDMETHOD(GetSize)(UInt64 *size);
+};
+
+#ifndef _WIN32_WCE
+class CStdInFileStream: 
+  public ISequentialInStream,
+  public CMyUnknownImp
+{
+public:
+  // HANDLE File;
+  // CStdInFileStream() File(INVALID_HANDLE_VALUE): {}
+  // void Open() { File = GetStdHandle(STD_INPUT_HANDLE); };
+  MY_UNKNOWN_IMP
+
+  virtual ~CStdInFileStream() {}
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+};
+#endif
+
+class COutFileStream: 
+  public IOutStream,
+  public CMyUnknownImp
+{
+public:
+  #ifdef _WIN32
+  NWindows::NFile::NIO::COutFile File;
+  #else
+  NC::NFile::NIO::COutFile File;
+  #endif
+  virtual ~COutFileStream() {}
+  bool Create(LPCTSTR fileName, bool createAlways);
+  #ifdef _WIN32
+  #ifndef _UNICODE
+  bool Create(LPCWSTR fileName, bool createAlways);
+  #endif
+  #endif
+  
+  MY_UNKNOWN_IMP1(IOutStream)
+
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
+  STDMETHOD(SetSize)(Int64 newSize);
+};
+
+#ifndef _WIN32_WCE
+class CStdOutFileStream: 
+  public ISequentialOutStream,
+  public CMyUnknownImp
+{
+public:
+  MY_UNKNOWN_IMP
+
+  virtual ~CStdOutFileStream() {}
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+};
+#endif
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/FileStreams.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,80 @@
+// InBuffer.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;InBuffer.h&quot;
+
+#include &quot;../../Common/Alloc.h&quot;
+
+CInBuffer::CInBuffer(): 
+  _buffer(0), 
+  _bufferLimit(0), 
+  _bufferBase(0), 
+  _stream(0),
+  _bufferSize(0)
+{}
+
+bool CInBuffer::Create(UInt32 bufferSize)
+{
+  const UInt32 kMinBlockSize = 1;
+  if (bufferSize &lt; kMinBlockSize)
+    bufferSize = kMinBlockSize;
+  if (_bufferBase != 0 &amp;&amp; _bufferSize == bufferSize)
+    return true;
+  Free();
+  _bufferSize = bufferSize;
+  _bufferBase = (Byte *)::MidAlloc(bufferSize);
+  return (_bufferBase != 0);
+}
+
+void CInBuffer::Free()
+{
+  ::MidFree(_bufferBase);
+  _bufferBase = 0;
+}
+
+void CInBuffer::SetStream(ISequentialInStream *stream)
+{
+  _stream = stream;
+}
+
+void CInBuffer::Init()
+{
+  _processedSize = 0;
+  _buffer = _bufferBase;
+  _bufferLimit = _buffer;
+  _wasFinished = false;
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = S_OK;
+  #endif
+}
+
+bool CInBuffer::ReadBlock()
+{
+  #ifdef _NO_EXCEPTIONS
+  if (ErrorCode != S_OK)
+    return false;
+  #endif
+  if (_wasFinished)
+    return false;
+  _processedSize += (_buffer - _bufferBase);
+  UInt32 numProcessedBytes;
+  HRESULT result = _stream-&gt;Read(_bufferBase, _bufferSize, &amp;numProcessedBytes);
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = result;
+  #else
+  if (result != S_OK)
+    throw CInBufferException(result);
+  #endif
+  _buffer = _bufferBase;
+  _bufferLimit = _buffer + numProcessedBytes;
+  _wasFinished = (numProcessedBytes == 0);
+  return (!_wasFinished);
+}
+
+Byte CInBuffer::ReadBlock2()
+{
+  if(!ReadBlock())
+    return 0xFF;
+  return *_buffer++;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,76 @@
+// InBuffer.h
+
+#ifndef __INBUFFER_H
+#define __INBUFFER_H
+
+#include &quot;../IStream.h&quot;
+#include &quot;../../Common/MyCom.h&quot;
+
+#ifndef _NO_EXCEPTIONS
+class CInBufferException
+{
+public:
+  HRESULT ErrorCode;
+  CInBufferException(HRESULT errorCode): ErrorCode(errorCode) {}
+};
+#endif
+
+class CInBuffer
+{
+  Byte *_buffer;
+  Byte *_bufferLimit;
+  Byte *_bufferBase;
+  CMyComPtr&lt;ISequentialInStream&gt; _stream;
+  UInt64 _processedSize;
+  UInt32 _bufferSize;
+  bool _wasFinished;
+
+  bool ReadBlock();
+  Byte ReadBlock2();
+
+public:
+  #ifdef _NO_EXCEPTIONS
+  HRESULT ErrorCode;
+  #endif
+
+  CInBuffer();
+  ~CInBuffer() { Free(); }
+
+  bool Create(UInt32 bufferSize);
+  void Free();
+  
+  void SetStream(ISequentialInStream *stream);
+  void Init();
+  void ReleaseStream() { _stream.Release(); }
+
+  bool ReadByte(Byte &amp;b)
+  {
+    if(_buffer &gt;= _bufferLimit)
+      if(!ReadBlock())
+        return false;
+    b = *_buffer++;
+    return true;
+  }
+  Byte ReadByte()
+  {
+    if(_buffer &gt;= _bufferLimit)
+      return ReadBlock2();
+    return *_buffer++;
+  }
+  void ReadBytes(void *data, UInt32 size, UInt32 &amp;processedSize)
+  {
+    for(processedSize = 0; processedSize &lt; size; processedSize++)
+      if (!ReadByte(((Byte *)data)[processedSize]))
+        return;
+  }
+  bool ReadBytes(void *data, UInt32 size)
+  {
+    UInt32 processedSize;
+    ReadBytes(data, size, processedSize);
+    return (processedSize == size);
+  }
+  UInt64 GetProcessedSize() const { return _processedSize + (_buffer - _bufferBase); }
+  bool WasFinished() const { return _wasFinished; }
+};
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/InBuffer.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,116 @@
+// OutByte.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;OutBuffer.h&quot;
+
+#include &quot;../../Common/Alloc.h&quot;
+
+bool COutBuffer::Create(UInt32 bufferSize)
+{
+  const UInt32 kMinBlockSize = 1;
+  if (bufferSize &lt; kMinBlockSize)
+    bufferSize = kMinBlockSize;
+  if (_buffer != 0 &amp;&amp; _bufferSize == bufferSize)
+    return true;
+  Free();
+  _bufferSize = bufferSize;
+  _buffer = (Byte *)::MidAlloc(bufferSize);
+  return (_buffer != 0);
+}
+
+void COutBuffer::Free()
+{
+  ::MidFree(_buffer);
+  _buffer = 0;
+}
+
+void COutBuffer::SetStream(ISequentialOutStream *stream)
+{
+  _stream = stream;
+}
+
+void COutBuffer::Init()
+{
+  _streamPos = 0;
+  _limitPos = _bufferSize;
+  _pos = 0;
+  _processedSize = 0;
+  _overDict = false;
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = S_OK;
+  #endif
+}
+
+UInt64 COutBuffer::GetProcessedSize() const
+{ 
+  UInt64 res = _processedSize + _pos - _streamPos;
+  if (_streamPos &gt; _pos) 
+    res += _bufferSize;
+  return res;
+}
+
+
+HRESULT COutBuffer::FlushPart()
+{
+  // _streamPos &lt; _bufferSize
+  UInt32 size = (_streamPos &gt;= _pos) ? (_bufferSize - _streamPos) : (_pos - _streamPos);
+  HRESULT result = S_OK;
+  #ifdef _NO_EXCEPTIONS
+  result = ErrorCode;
+  #endif
+  if (_buffer2 != 0)
+  {
+    memmove(_buffer2, _buffer + _streamPos, size);
+    _buffer2 += size;
+  }
+
+  if (_stream != 0
+      #ifdef _NO_EXCEPTIONS
+      &amp;&amp; (ErrorCode == S_OK)
+      #endif
+     )
+  {
+    UInt32 processedSize = 0;
+    result = _stream-&gt;Write(_buffer + _streamPos, size, &amp;processedSize);
+    size = processedSize;
+  }
+  _streamPos += size;
+  if (_streamPos == _bufferSize)
+    _streamPos = 0;
+  if (_pos == _bufferSize)
+  {
+    _overDict = true;
+    _pos = 0;
+  }
+  _limitPos = (_streamPos &gt; _pos) ? _streamPos : _bufferSize;
+  _processedSize += size;
+  return result;
+}
+
+HRESULT COutBuffer::Flush()
+{
+  #ifdef _NO_EXCEPTIONS
+  if (ErrorCode != S_OK)
+    return ErrorCode;
+  #endif
+
+  while(_streamPos != _pos)
+  {
+    HRESULT result = FlushPart();
+    if (result != S_OK)
+      return result;
+  }
+  return S_OK;
+}
+
+void COutBuffer::FlushWithCheck()
+{
+  HRESULT result = FlushPart();
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = result;
+  #else
+  if (result != S_OK)
+    throw COutBufferException(result);
+  #endif
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,64 @@
+// OutBuffer.h
+
+#ifndef __OUTBUFFER_H
+#define __OUTBUFFER_H
+
+#include &quot;../IStream.h&quot;
+#include &quot;../../Common/MyCom.h&quot;
+
+#ifndef _NO_EXCEPTIONS
+struct COutBufferException
+{
+  HRESULT ErrorCode;
+  COutBufferException(HRESULT errorCode): ErrorCode(errorCode) {}
+};
+#endif
+
+class COutBuffer
+{
+protected:
+  Byte *_buffer;
+  UInt32 _pos;
+  UInt32 _limitPos;
+  UInt32 _streamPos;
+  UInt32 _bufferSize;
+  CMyComPtr&lt;ISequentialOutStream&gt; _stream;
+  UInt64 _processedSize;
+  Byte  *_buffer2;
+  bool _overDict;
+
+  HRESULT FlushPart();
+  void FlushWithCheck();
+public:
+  #ifdef _NO_EXCEPTIONS
+  HRESULT ErrorCode;
+  #endif
+
+  COutBuffer(): _buffer(0), _pos(0), _stream(0), _buffer2(0) {}
+  ~COutBuffer() { Free(); }
+  
+  bool Create(UInt32 bufferSize);
+  void Free();
+
+  void SetMemStream(Byte *buffer) { _buffer2 = buffer; }
+  void SetStream(ISequentialOutStream *stream);
+  void Init();
+  HRESULT Flush();
+  void ReleaseStream() {  _stream.Release(); }
+
+  void WriteByte(Byte b)
+  {
+    _buffer[_pos++] = b;
+    if(_pos == _limitPos)
+      FlushWithCheck();
+  }
+  void WriteBytes(const void *data, size_t size)
+  {
+    for (size_t i = 0; i &lt; size; i++)
+      WriteByte(((const Byte *)data)[i]);
+  }
+
+  UInt64 GetProcessedSize() const;
+};
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/OutBuffer.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StdAfx.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StdAfx.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StdAfx.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,9 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include &quot;../../Common/MyWindows.h&quot;
+#include &quot;../../Common/NewHandler.h&quot;
+
+#endif 


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StdAfx.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,44 @@
+// StreamUtils.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;../../Common/MyCom.h&quot;
+#include &quot;StreamUtils.h&quot;
+
+HRESULT ReadStream(ISequentialInStream *stream, void *data, UInt32 size, UInt32 *processedSize)
+{
+  if (processedSize != 0)
+    *processedSize = 0;
+  while(size != 0)
+  {
+    UInt32 processedSizeLoc; 
+    HRESULT res = stream-&gt;Read(data, size, &amp;processedSizeLoc);
+    if (processedSize != 0)
+      *processedSize += processedSizeLoc;
+    data = (Byte *)((Byte *)data + processedSizeLoc);
+    size -= processedSizeLoc;
+    RINOK(res);
+    if (processedSizeLoc == 0)
+      return S_OK;
+  }
+  return S_OK;
+}
+
+HRESULT WriteStream(ISequentialOutStream *stream, const void *data, UInt32 size, UInt32 *processedSize)
+{
+  if (processedSize != 0)
+    *processedSize = 0;
+  while(size != 0)
+  {
+    UInt32 processedSizeLoc; 
+    HRESULT res = stream-&gt;Write(data, size, &amp;processedSizeLoc);
+    if (processedSize != 0)
+      *processedSize += processedSizeLoc;
+    data = (const void *)((const Byte *)data + processedSizeLoc);
+    size -= processedSizeLoc;
+    RINOK(res);
+    if (processedSizeLoc == 0)
+      break;
+  }
+  return S_OK;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,11 @@
+// StreamUtils.h
+
+#ifndef __STREAMUTILS_H
+#define __STREAMUTILS_H
+
+#include &quot;../IStream.h&quot;
+
+HRESULT ReadStream(ISequentialInStream *stream, void *data, UInt32 size, UInt32 *processedSize);
+HRESULT WriteStream(ISequentialOutStream *stream, const void *data, UInt32 size, UInt32 *processedSize);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Common/StreamUtils.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,16 @@
+// ARM.cpp
+
+#include &quot;StdAfx.h&quot;
+#include &quot;ARM.h&quot;
+
+#include &quot;BranchARM.c&quot;
+
+UInt32 CBC_ARM_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::ARM_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_ARM_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::ARM_Convert(data, size, _bufferPos, 0);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// ARM.h
+
+#ifndef __ARM_H
+#define __ARM_H
+
+#include &quot;BranchCoder.h&quot;
+
+MyClassA(BC_ARM, 0x05, 1)
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARM.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,16 @@
+// ARMThumb.cpp
+
+#include &quot;StdAfx.h&quot;
+#include &quot;ARMThumb.h&quot;
+
+#include &quot;BranchARMThumb.c&quot;
+
+UInt32 CBC_ARMThumb_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::ARMThumb_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_ARMThumb_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::ARMThumb_Convert(data, size, _bufferPos, 0);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// ARMThumb.h
+
+#ifndef __ARMTHUMB_H
+#define __ARMTHUMB_H
+
+#include &quot;BranchCoder.h&quot;
+
+MyClassA(BC_ARMThumb, 0x07, 1)
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/ARMThumb.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,26 @@
+/* BranchARM.c */
+
+#include &quot;BranchARM.h&quot;
+
+UInt32 ARM_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 4 &lt;= size; i += 4)
+  {
+    if (data[i + 3] == 0xEB)
+    {
+      UInt32 src = (data[i + 2] &lt;&lt; 16) | (data[i + 1] &lt;&lt; 8) | (data[i + 0]);
+      src &lt;&lt;= 2;
+      UInt32 dest;
+      if (encoding)
+        dest = nowPos + i + 8 + src;
+      else
+        dest = src - (nowPos + i + 8);
+      dest &gt;&gt;= 2;
+      data[i + 2] = (dest &gt;&gt; 16);
+      data[i + 1] = (dest &gt;&gt; 8);
+      data[i + 0] = dest;
+    }
+  }
+  return i;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// BranchARM.h
+
+#ifndef __BRANCH_ARM_H
+#define __BRANCH_ARM_H
+
+#include &quot;BranchTypes.h&quot;
+
+UInt32 ARM_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARM.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,35 @@
+/* BranchARMThumb.c */
+
+#include &quot;BranchARMThumb.h&quot;
+
+UInt32 ARMThumb_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 4 &lt;= size; i += 2)
+  {
+    if ((data[i + 1] &amp; 0xF8) == 0xF0 &amp;&amp; 
+        (data[i + 3] &amp; 0xF8) == 0xF8)
+    {
+      UInt32 src = 
+        ((data[i + 1] &amp; 0x7) &lt;&lt; 19) |
+        (data[i + 0] &lt;&lt; 11) |
+        ((data[i + 3] &amp; 0x7) &lt;&lt; 8) |
+        (data[i + 2]);
+      
+      src &lt;&lt;= 1;
+      UInt32 dest;
+      if (encoding)
+        dest = nowPos + i + 4 + src;
+      else
+        dest = src - (nowPos + i + 4);
+      dest &gt;&gt;= 1;
+      
+      data[i + 1] = 0xF0 | ((dest &gt;&gt; 19) &amp; 0x7);
+      data[i + 0] = (dest &gt;&gt; 11);
+      data[i + 3] = 0xF8 | ((dest &gt;&gt; 8) &amp; 0x7);
+      data[i + 2] = (dest);
+      i += 2;
+    }
+  }
+  return i;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// BranchARMThumb.h
+
+#ifndef __BRANCH_ARM_THUMB_H
+#define __BRANCH_ARM_THUMB_H
+
+#include &quot;BranchTypes.h&quot;
+
+UInt32 ARMThumb_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchARMThumb.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,18 @@
+// BranchCoder.cpp
+
+#include &quot;StdAfx.h&quot;
+#include &quot;BranchCoder.h&quot;
+
+STDMETHODIMP CBranchConverter::Init()
+{
+  _bufferPos = 0;
+  SubInit();
+  return S_OK;
+}
+
+STDMETHODIMP_(UInt32) CBranchConverter::Filter(Byte *data, UInt32 size)
+{
+  UInt32 processedSize = SubFilter(data, size);
+  _bufferPos += processedSize;
+  return processedSize;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,54 @@
+// BranchCoder.h
+
+#ifndef __BRANCH_CODER_H
+#define __BRANCH_CODER_H
+
+#include &quot;Common/MyCom.h&quot;
+#include &quot;Common/Types.h&quot;
+#include &quot;Common/Alloc.h&quot;
+
+#include &quot;../../ICoder.h&quot;
+
+class CBranchConverter:
+  public ICompressFilter,
+  public CMyUnknownImp
+{
+protected:
+  UInt32 _bufferPos;
+  virtual void SubInit() {}
+  virtual UInt32 SubFilter(Byte *data, UInt32 size) = 0;
+public:
+  MY_UNKNOWN_IMP;
+  STDMETHOD(Init)();
+  STDMETHOD_(UInt32, Filter)(Byte *data, UInt32 size);
+};
+
+#define MyClassEncoderA(Name) class C ## Name: public CBranchConverter \
+  { public: UInt32 SubFilter(Byte *data, UInt32 size); }; 
+
+#define MyClassDecoderA(Name) class C ## Name: public CBranchConverter \
+  { public: UInt32 SubFilter(Byte *data, UInt32 size); }; 
+
+#define MyClassEncoderB(Name, ADD_ITEMS, ADD_INIT) class C ## Name: public CBranchConverter, public ADD_ITEMS \
+  { public: UInt32 SubFilter(Byte *data, UInt32 size); ADD_INIT}; 
+
+#define MyClassDecoderB(Name, ADD_ITEMS, ADD_INIT) class C ## Name: public CBranchConverter, public ADD_ITEMS \
+  { public: UInt32 SubFilter(Byte *data, UInt32 size); ADD_INIT}; 
+
+#define MyClass2b(Name, id, subId, encodingId)  \
+DEFINE_GUID(CLSID_CCompressConvert ## Name,  \
+0x23170F69, 0x40C1, 0x278B, 0x03, 0x03, id, subId, 0x00, 0x00, encodingId, 0x00); 
+
+#define MyClassA(Name, id, subId)  \
+MyClass2b(Name ## _Encoder, id, subId, 0x01) \
+MyClassEncoderA(Name ## _Encoder) \
+MyClass2b(Name ## _Decoder, id, subId, 0x00) \
+MyClassDecoderA(Name ## _Decoder)
+
+#define MyClassB(Name, id, subId, ADD_ITEMS, ADD_INIT)  \
+MyClass2b(Name ## _Encoder, id, subId, 0x01) \
+MyClassEncoderB(Name ## _Encoder, ADD_ITEMS, ADD_INIT) \
+MyClass2b(Name ## _Decoder, id, subId, 0x00) \
+MyClassDecoderB(Name ## _Decoder, ADD_ITEMS, ADD_INIT)
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchCoder.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,63 @@
+/* BranchIA64.c */
+
+#include &quot;BranchIA64.h&quot;
+
+const Byte kBranchTable[32] = 
+{ 
+  0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,
+  4, 4, 6, 6, 0, 0, 7, 7,
+  4, 4, 0, 0, 4, 4, 0, 0 
+};
+
+UInt32 IA64_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 16 &lt;= size; i += 16)
+  {
+    UInt32 instrTemplate = data[i] &amp; 0x1F;
+    UInt32 mask = kBranchTable[instrTemplate];
+    UInt32 bitPos = 5;
+    for (int slot = 0; slot &lt; 3; slot++, bitPos += 41)
+    {
+      if (((mask &gt;&gt; slot) &amp; 1) == 0)
+        continue;
+      UInt32 bytePos = (bitPos &gt;&gt; 3);
+      UInt32 bitRes = bitPos &amp; 0x7;
+      UInt64 instruction = 0;
+      int j;
+      for (j = 0; j &lt; 6; j++)
+        instruction += (UInt64)(data[i + j + bytePos]) &lt;&lt; (8 * j);
+
+      UInt64 instNorm = instruction &gt;&gt; bitRes;
+      if (((instNorm &gt;&gt; 37) &amp; 0xF) == 0x5 
+        &amp;&amp;  ((instNorm &gt;&gt; 9) &amp; 0x7) == 0 
+        /* &amp;&amp;  (instNorm &amp; 0x3F)== 0 */
+        )
+      {
+        UInt32 src = UInt32((instNorm &gt;&gt; 13) &amp; 0xFFFFF);
+        src |= ((instNorm &gt;&gt; 36) &amp; 1) &lt;&lt; 20;
+        
+        src &lt;&lt;= 4;
+        
+        UInt32 dest;
+        if (encoding)
+          dest = nowPos + i + src;
+        else
+          dest = src - (nowPos + i);
+        
+        dest &gt;&gt;= 4;
+        
+        instNorm &amp;= ~(UInt64(0x8FFFFF) &lt;&lt; 13);
+        instNorm |= (UInt64(dest &amp; 0xFFFFF) &lt;&lt; 13);
+        instNorm |= (UInt64(dest &amp; 0x100000) &lt;&lt; (36 - 20));
+        
+        instruction &amp;= (1 &lt;&lt; bitRes) - 1;
+        instruction |= (instNorm &lt;&lt; bitRes);
+        for (j = 0; j &lt; 6; j++)
+          data[i + j + bytePos] = Byte(instruction &gt;&gt; (8 * j));
+      }
+    }
+  }
+  return i;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// BranchIA64.h
+
+#ifndef __BRANCH_IA64_H
+#define __BRANCH_IA64_H
+
+#include &quot;BranchTypes.h&quot;
+
+UInt32 IA64_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchIA64.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,36 @@
+/* BranchPPC.c */
+
+#include &quot;BranchPPC.h&quot;
+
+UInt32 PPC_B_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 4 &lt;= size; i += 4)
+  {
+    /* PowerPC branch 6(48) 24(Offset) 1(Abs) 1(Link) */
+    if ((data[i] &gt;&gt; 2) == 0x12 &amp;&amp; 
+    (
+      (data[i + 3] &amp; 3) == 1 
+      /* || (data[i+3] &amp; 3) == 3 */
+      )
+    )
+    {
+      UInt32 src = ((data[i + 0] &amp; 3) &lt;&lt; 24) |
+        (data[i + 1] &lt;&lt; 16) |
+        (data[i + 2] &lt;&lt; 8) |
+        (data[i + 3] &amp; (~3));
+      
+      UInt32 dest;
+      if (encoding)
+        dest = nowPos + i + src;
+      else
+        dest = src - (nowPos + i);
+      data[i + 0] = 0x48 | ((dest &gt;&gt; 24) &amp;  0x3);
+      data[i + 1] = (dest &gt;&gt; 16);
+      data[i + 2] = (dest &gt;&gt; 8);
+      data[i + 3] &amp;= 0x3;
+      data[i + 3] |= dest;
+    }
+  }
+  return i;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// BranchPPC.h
+
+#ifndef __BRANCH_PPC_H
+#define __BRANCH_PPC_H
+
+#include &quot;BranchTypes.h&quot;
+
+UInt32 PPC_B_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchPPC.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,36 @@
+/* BranchSPARC.c */
+
+#include &quot;BranchSPARC.h&quot;
+
+UInt32 SPARC_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 4 &lt;= size; i += 4)
+  {
+    if (data[i] == 0x40 &amp;&amp; (data[i + 1] &amp; 0xC0) == 0x00 || 
+        data[i] == 0x7F &amp;&amp; (data[i + 1] &amp; 0xC0) == 0xC0)
+    {
+      UInt32 src = 
+        ((UInt32)data[i + 0] &lt;&lt; 24) |
+        ((UInt32)data[i + 1] &lt;&lt; 16) |
+        ((UInt32)data[i + 2] &lt;&lt; 8) |
+        ((UInt32)data[i + 3]);
+      
+      src &lt;&lt;= 2;
+      UInt32 dest;
+      if (encoding)
+        dest = nowPos + i + src;
+      else
+        dest = src - (nowPos + i);
+      dest &gt;&gt;= 2;
+      
+      dest = (((0 - ((dest &gt;&gt; 22) &amp; 1)) &lt;&lt; 22) &amp; 0x3FFFFFFF) | (dest &amp; 0x3FFFFF) | 0x40000000;
+
+      data[i + 0] = (Byte)(dest &gt;&gt; 24);
+      data[i + 1] = (Byte)(dest &gt;&gt; 16);
+      data[i + 2] = (Byte)(dest &gt;&gt; 8);
+      data[i + 3] = (Byte)dest;
+    }
+  }
+  return i;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// BranchSPARC.h
+
+#ifndef __BRANCH_SPARC_H
+#define __BRANCH_SPARC_H
+
+#include &quot;BranchTypes.h&quot;
+
+UInt32 SPARC_B_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchSPARC.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchTypes.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchTypes.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchTypes.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,25 @@
+/* BranchTypes.h */
+
+#ifndef __BRANCHTYPES_H
+#define __BRANCHTYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchTypes.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,101 @@
+/* BranchX86.c */
+
+#include &quot;BranchX86.h&quot;
+
+/*
+static int inline Test86MSByte(Byte b)
+{
+  return (b == 0 || b == 0xFF);
+}
+*/
+#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
+
+const int kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
+const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
+
+/*
+void x86_Convert_Init(UInt32 *prevMask, UInt32 *prevPos)
+{
+  *prevMask = 0;
+  *prevPos = (UInt32)(-5);
+}
+*/
+
+UInt32 x86_Convert(Byte *buffer, UInt32 endPos, UInt32 nowPos, 
+    UInt32 *prevMask, UInt32 *prevPos, int encoding)
+{
+  UInt32 bufferPos = 0;
+  UInt32 limit;
+
+  if (endPos &lt; 5)
+    return 0;
+  
+  if (nowPos - *prevPos &gt; 5)
+    *prevPos = nowPos - 5;
+  
+  limit = endPos - 5;
+  while(bufferPos &lt;= limit)
+  {
+    Byte b = buffer[bufferPos];
+    UInt32 offset;
+    if (b != 0xE8 &amp;&amp; b != 0xE9)
+    {
+      bufferPos++;
+      continue;
+    }
+    offset = (nowPos + bufferPos - *prevPos);
+    *prevPos = (nowPos + bufferPos);
+    if (offset &gt; 5)
+      *prevMask = 0;
+    else
+    {
+      UInt32 i;
+      for (i = 0; i &lt; offset; i++)
+      {
+        *prevMask &amp;= 0x77;
+        *prevMask &lt;&lt;= 1;
+      }
+    }
+    b = buffer[bufferPos + 4];
+    if (Test86MSByte(b) &amp;&amp; kMaskToAllowedStatus[(*prevMask &gt;&gt; 1) &amp; 0x7] &amp;&amp; 
+      (*prevMask &gt;&gt; 1) &lt; 0x10)
+    {
+      UInt32 src = 
+        ((UInt32)(b) &lt;&lt; 24) |
+        ((UInt32)(buffer[bufferPos + 3]) &lt;&lt; 16) |
+        ((UInt32)(buffer[bufferPos + 2]) &lt;&lt; 8) |
+        (buffer[bufferPos + 1]);
+      
+      UInt32 dest;
+      while(1)
+      {
+        UInt32 index;
+        if (encoding)
+          dest = (nowPos + bufferPos + 5) + src;
+        else
+          dest = src - (nowPos + bufferPos + 5);
+        if (*prevMask == 0)
+          break;
+        index = kMaskToBitNumber[*prevMask &gt;&gt; 1];
+        b = (Byte)(dest &gt;&gt; (24 - index * 8));
+        if (!Test86MSByte(b))
+          break;
+        src = dest ^ ((1 &lt;&lt; (32 - index * 8)) - 1);
+      }
+      buffer[bufferPos + 4] = (Byte)(~(((dest &gt;&gt; 24) &amp; 1) - 1));
+      buffer[bufferPos + 3] = (Byte)(dest &gt;&gt; 16);
+      buffer[bufferPos + 2] = (Byte)(dest &gt;&gt; 8);
+      buffer[bufferPos + 1] = (Byte)dest;
+      bufferPos += 5;
+      *prevMask = 0;
+    }
+    else
+    {
+      bufferPos++;
+      *prevMask |= 1;
+      if (Test86MSByte(b))
+        *prevMask |= 0x10;
+    }
+  }
+  return bufferPos;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,13 @@
+/* BranchX86.h */
+
+#ifndef __BRANCHX86_H
+#define __BRANCHX86_H
+
+#include &quot;BranchTypes.h&quot;
+
+#define x86_Convert_Init(prevMask, prevPos) { prevMask = 0; prevPos = (UInt32)(-5); }
+
+UInt32 x86_Convert(Byte *buffer, UInt32 endPos, UInt32 nowPos, 
+    UInt32 *prevMask, UInt32 *prevPos, int encoding);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/BranchX86.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,16 @@
+// IA64.cpp
+
+#include &quot;StdAfx.h&quot;
+#include &quot;IA64.h&quot;
+
+#include &quot;BranchIA64.c&quot;
+
+UInt32 CBC_IA64_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::IA64_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_IA64_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::IA64_Convert(data, size, _bufferPos, 0);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// IA64.h
+
+#ifndef __IA64_H
+#define __IA64_H
+
+#include &quot;BranchCoder.h&quot;
+
+MyClassA(BC_IA64, 0x04, 1)
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/IA64.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,17 @@
+// PPC.cpp
+
+#include &quot;StdAfx.h&quot;
+#include &quot;PPC.h&quot;
+
+#include &quot;Windows/Defs.h&quot;
+#include &quot;BranchPPC.c&quot;
+
+UInt32 CBC_PPC_B_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::PPC_B_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_PPC_B_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::PPC_B_Convert(data, size, _bufferPos, 0);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// PPC.h
+
+#ifndef __PPC_H
+#define __PPC_H
+
+#include &quot;BranchCoder.h&quot;
+
+MyClassA(BC_PPC_B, 0x02, 5)
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/PPC.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,17 @@
+// SPARC.cpp
+
+#include &quot;StdAfx.h&quot;
+#include &quot;SPARC.h&quot;
+
+#include &quot;Windows/Defs.h&quot;
+#include &quot;BranchSPARC.c&quot;
+
+UInt32 CBC_SPARC_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::SPARC_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_SPARC_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::SPARC_Convert(data, size, _bufferPos, 0);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,10 @@
+// SPARC.h
+
+#ifndef __SPARC_H
+#define __SPARC_H
+
+#include &quot;BranchCoder.h&quot;
+
+MyClassA(BC_SPARC, 0x08, 5)
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/SPARC.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/StdAfx.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/StdAfx.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/StdAfx.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,8 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include &quot;../../../Common/MyWindows.h&quot;
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/StdAfx.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,18 @@
+// x86.cpp
+
+#include &quot;StdAfx.h&quot;
+#include &quot;x86.h&quot;
+
+#include &quot;Windows/Defs.h&quot;
+
+#include &quot;BranchX86.c&quot;
+
+UInt32 CBCJ_x86_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::x86_Convert(data, size, _bufferPos, &amp;_prevMask, &amp;_prevPos, 1);
+}
+
+UInt32 CBCJ_x86_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::x86_Convert(data, size, _bufferPos, &amp;_prevMask, &amp;_prevPos, 0);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,19 @@
+// x86.h
+
+#ifndef __X86_H
+#define __X86_H
+
+#include &quot;BranchCoder.h&quot;
+#include &quot;BranchX86.h&quot;
+
+struct CBranch86
+{
+  UInt32 _prevMask;
+  UInt32 _prevPos;
+  void x86Init() { x86_Convert_Init(_prevMask, _prevPos); }
+};
+
+MyClassB(BCJ_x86, 0x01, 3, CBranch86 , 
+    virtual void SubInit() { x86Init(); })
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,412 @@
+// x86_2.cpp
+
+#include &quot;StdAfx.h&quot;
+#include &quot;x86_2.h&quot;
+
+#include &quot;../../../Common/Alloc.h&quot;
+
+static const int kBufferSize = 1 &lt;&lt; 17;
+
+inline bool IsJcc(Byte b0, Byte b1)
+{
+  return (b0 == 0x0F &amp;&amp; (b1 &amp; 0xF0) == 0x80);
+}
+
+#ifndef EXTRACT_ONLY
+
+static bool inline Test86MSByte(Byte b)
+{
+  return (b == 0 || b == 0xFF);
+}
+
+bool CBCJ2_x86_Encoder::Create()
+{
+  if (!_mainStream.Create(1 &lt;&lt; 16))
+    return false;
+  if (!_callStream.Create(1 &lt;&lt; 20))
+    return false;
+  if (!_jumpStream.Create(1 &lt;&lt; 20))
+    return false;
+  if (!_rangeEncoder.Create(1 &lt;&lt; 20))
+    return false;
+  if (_buffer == 0)
+  {
+    _buffer = (Byte *)MidAlloc(kBufferSize);
+    if (_buffer == 0)
+      return false;
+  }
+  return true;
+}
+
+CBCJ2_x86_Encoder::~CBCJ2_x86_Encoder()
+{
+  ::MidFree(_buffer);
+}
+
+HRESULT CBCJ2_x86_Encoder::Flush()
+{
+  RINOK(_mainStream.Flush());
+  RINOK(_callStream.Flush());
+  RINOK(_jumpStream.Flush());
+  _rangeEncoder.FlushData();
+  return _rangeEncoder.FlushStream();
+}
+
+const UInt32 kDefaultLimit = (1 &lt;&lt; 24);
+
+HRESULT CBCJ2_x86_Encoder::CodeReal(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress)
+{
+  if (numInStreams != 1 || numOutStreams != 4)
+    return E_INVALIDARG;
+
+  if (!Create())
+    return E_OUTOFMEMORY;
+
+  bool sizeIsDefined = false;
+  UInt64 inSize;
+  if (inSizes != NULL)
+    if (inSizes[0] != NULL)
+    {
+      inSize = *inSizes[0];
+      if (inSize &lt;= kDefaultLimit)
+        sizeIsDefined = true;
+    }
+
+  ISequentialInStream *inStream = inStreams[0];
+
+  _mainStream.SetStream(outStreams[0]);
+  _mainStream.Init();
+  _callStream.SetStream(outStreams[1]);
+  _callStream.Init();
+  _jumpStream.SetStream(outStreams[2]);
+  _jumpStream.Init();
+  _rangeEncoder.SetStream(outStreams[3]);
+  _rangeEncoder.Init();
+  for (int i = 0; i &lt; 256; i++)
+    _statusE8Encoder[i].Init();
+  _statusE9Encoder.Init();
+  _statusJccEncoder.Init();
+  CCoderReleaser releaser(this);
+
+  CMyComPtr&lt;ICompressGetSubStreamSize&gt; getSubStreamSize;
+  {
+    inStream-&gt;QueryInterface(IID_ICompressGetSubStreamSize, (void **)&amp;getSubStreamSize);
+  }
+
+  UInt32 nowPos = 0;
+  UInt64 nowPos64 = 0;
+  UInt32 bufferPos = 0;
+
+  Byte prevByte = 0;
+
+  UInt64 subStreamIndex = 0;
+  UInt64 subStreamStartPos  = 0;
+  UInt64 subStreamEndPos = 0;
+
+  while(true)
+  {
+    UInt32 processedSize = 0;
+    while(true)
+    {
+      UInt32 size = kBufferSize - (bufferPos + processedSize);
+      UInt32 processedSizeLoc;
+      if (size == 0)
+        break;
+      RINOK(inStream-&gt;Read(_buffer + bufferPos + processedSize, size, &amp;processedSizeLoc));
+      if (processedSizeLoc == 0)
+        break;
+      processedSize += processedSizeLoc;
+    }
+    UInt32 endPos = bufferPos + processedSize;
+    
+    if (endPos &lt; 5)
+    {
+      // change it 
+      for (bufferPos = 0; bufferPos &lt; endPos; bufferPos++)
+      {
+        Byte b = _buffer[bufferPos];
+        _mainStream.WriteByte(b);
+        if (b == 0xE8)
+          _statusE8Encoder[prevByte].Encode(&amp;_rangeEncoder, 0);
+        else if (b == 0xE9)
+          _statusE9Encoder.Encode(&amp;_rangeEncoder, 0);
+        else if (IsJcc(prevByte, b))
+          _statusJccEncoder.Encode(&amp;_rangeEncoder, 0);
+        prevByte = b;
+      }
+      return Flush();
+    }
+
+    bufferPos = 0;
+
+    UInt32 limit = endPos - 5;
+    while(bufferPos &lt;= limit)
+    {
+      Byte b = _buffer[bufferPos];
+      _mainStream.WriteByte(b);
+      if (b != 0xE8 &amp;&amp; b != 0xE9 &amp;&amp; !IsJcc(prevByte, b))
+      {
+        bufferPos++;
+        prevByte = b;
+        continue;
+      }
+      Byte nextByte = _buffer[bufferPos + 4];
+      UInt32 src = 
+        (UInt32(nextByte) &lt;&lt; 24) |
+        (UInt32(_buffer[bufferPos + 3]) &lt;&lt; 16) |
+        (UInt32(_buffer[bufferPos + 2]) &lt;&lt; 8) |
+        (_buffer[bufferPos + 1]);
+      UInt32 dest = (nowPos + bufferPos + 5) + src;
+      // if (Test86MSByte(nextByte))
+      bool convert;
+      if (getSubStreamSize != NULL)
+      {
+        UInt64 currentPos = (nowPos64 + bufferPos);
+        while (subStreamEndPos &lt; currentPos)
+        {
+          UInt64 subStreamSize;
+          HRESULT result = getSubStreamSize-&gt;GetSubStreamSize(subStreamIndex, &amp;subStreamSize);
+          if (result == S_OK)
+          {
+            subStreamStartPos = subStreamEndPos;
+            subStreamEndPos += subStreamSize;          
+            subStreamIndex++;
+          }
+          else if (result == S_FALSE || result == E_NOTIMPL)
+          {
+            getSubStreamSize.Release();
+            subStreamStartPos = 0;
+            subStreamEndPos = subStreamStartPos - 1;          
+          }
+          else
+            return result;
+        }
+        if (getSubStreamSize == NULL)
+        {
+          if (sizeIsDefined)
+            convert = (dest &lt; inSize);
+          else
+            convert = Test86MSByte(nextByte);
+        }
+        else if (subStreamEndPos - subStreamStartPos &gt; kDefaultLimit)
+          convert = Test86MSByte(nextByte);
+        else
+        {
+          UInt64 dest64 = (currentPos + 5) + Int64(Int32(src));
+          convert = (dest64 &gt;= subStreamStartPos &amp;&amp; dest64 &lt; subStreamEndPos);
+        }
+      }
+      else if (sizeIsDefined)
+        convert = (dest &lt; inSize);
+      else
+        convert = Test86MSByte(nextByte);
+      if (convert)
+      {
+        if (b == 0xE8)
+          _statusE8Encoder[prevByte].Encode(&amp;_rangeEncoder, 1);
+        else if (b == 0xE9)
+          _statusE9Encoder.Encode(&amp;_rangeEncoder, 1);
+        else 
+          _statusJccEncoder.Encode(&amp;_rangeEncoder, 1);
+
+        bufferPos += 5;
+        if (b == 0xE8)
+        {
+          _callStream.WriteByte((Byte)(dest &gt;&gt; 24));
+          _callStream.WriteByte((Byte)(dest &gt;&gt; 16));
+          _callStream.WriteByte((Byte)(dest &gt;&gt; 8));
+          _callStream.WriteByte((Byte)(dest));
+        }
+        else 
+        {
+          _jumpStream.WriteByte((Byte)(dest &gt;&gt; 24));
+          _jumpStream.WriteByte((Byte)(dest &gt;&gt; 16));
+          _jumpStream.WriteByte((Byte)(dest &gt;&gt; 8));
+          _jumpStream.WriteByte((Byte)(dest));
+        }
+        prevByte = nextByte;
+      }
+      else
+      {
+        if (b == 0xE8)
+          _statusE8Encoder[prevByte].Encode(&amp;_rangeEncoder, 0);
+        else if (b == 0xE9)
+          _statusE9Encoder.Encode(&amp;_rangeEncoder, 0);
+        else
+          _statusJccEncoder.Encode(&amp;_rangeEncoder, 0);
+        bufferPos++;
+        prevByte = b;
+      }
+    }
+    nowPos += bufferPos;
+    nowPos64 += bufferPos;
+
+    if (progress != NULL)
+    {
+      RINOK(progress-&gt;SetRatioInfo(&amp;nowPos64, NULL));
+    }
+ 
+    UInt32 i = 0;
+    while(bufferPos &lt; endPos)
+      _buffer[i++] = _buffer[bufferPos++];
+    bufferPos = i;
+  }
+}
+
+STDMETHODIMP CBCJ2_x86_Encoder::Code(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress)
+{
+  try
+  {
+    return CodeReal(inStreams, inSizes, numInStreams,
+      outStreams, outSizes,numOutStreams, progress);
+  }
+  catch(const COutBufferException &amp;e) { return e.ErrorCode; }
+  catch(...) { return S_FALSE; }
+}
+
+#endif
+
+HRESULT CBCJ2_x86_Decoder::CodeReal(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress)
+{
+  if (numInStreams != 4 || numOutStreams != 1)
+    return E_INVALIDARG;
+
+  if (!_mainInStream.Create(1 &lt;&lt; 16))
+    return E_OUTOFMEMORY;
+  if (!_callStream.Create(1 &lt;&lt; 20))
+    return E_OUTOFMEMORY;
+  if (!_jumpStream.Create(1 &lt;&lt; 16))
+    return E_OUTOFMEMORY;
+  if (!_rangeDecoder.Create(1 &lt;&lt; 20))
+    return E_OUTOFMEMORY;
+  if (!_outStream.Create(1 &lt;&lt; 16))
+    return E_OUTOFMEMORY;
+
+  _mainInStream.SetStream(inStreams[0]);
+  _callStream.SetStream(inStreams[1]);
+  _jumpStream.SetStream(inStreams[2]);
+  _rangeDecoder.SetStream(inStreams[3]);
+  _outStream.SetStream(outStreams[0]);
+
+  _mainInStream.Init();
+  _callStream.Init();
+  _jumpStream.Init();
+  _rangeDecoder.Init();
+  _outStream.Init();
+
+  for (int i = 0; i &lt; 256; i++)
+    _statusE8Decoder[i].Init();
+  _statusE9Decoder.Init();
+  _statusJccDecoder.Init();
+
+  CCoderReleaser releaser(this);
+
+  Byte prevByte = 0;
+  UInt32 processedBytes = 0;
+  while(true)
+  {
+    if (processedBytes &gt; (1 &lt;&lt; 20) &amp;&amp; progress != NULL)
+    {
+      UInt64 nowPos64 = _outStream.GetProcessedSize();
+      RINOK(progress-&gt;SetRatioInfo(NULL, &amp;nowPos64));
+      processedBytes = 0;
+    }
+    processedBytes++;
+    Byte b;
+    if (!_mainInStream.ReadByte(b))
+      return Flush();
+    _outStream.WriteByte(b);
+    if (b != 0xE8 &amp;&amp; b != 0xE9 &amp;&amp; !IsJcc(prevByte, b))
+    {
+      prevByte = b;
+      continue;
+    }
+    bool status;
+    if (b == 0xE8)
+      status = (_statusE8Decoder[prevByte].Decode(&amp;_rangeDecoder) == 1);
+    else if (b == 0xE9)
+      status = (_statusE9Decoder.Decode(&amp;_rangeDecoder) == 1);
+    else
+      status = (_statusJccDecoder.Decode(&amp;_rangeDecoder) == 1);
+    if (status)
+    {
+      UInt32 src;
+      if (b == 0xE8)
+      {
+        Byte b0;
+        if(!_callStream.ReadByte(b0))
+          return S_FALSE;
+        src = ((UInt32)b0) &lt;&lt; 24;
+        if(!_callStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0) &lt;&lt; 16;
+        if(!_callStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0) &lt;&lt; 8;
+        if(!_callStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0);
+      }
+      else
+      {
+        Byte b0;
+        if(!_jumpStream.ReadByte(b0))
+          return S_FALSE;
+        src = ((UInt32)b0) &lt;&lt; 24;
+        if(!_jumpStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0) &lt;&lt; 16;
+        if(!_jumpStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0) &lt;&lt; 8;
+        if(!_jumpStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0);
+      }
+      UInt32 dest = src - (UInt32(_outStream.GetProcessedSize()) + 4) ;
+      _outStream.WriteByte((Byte)(dest));
+      _outStream.WriteByte((Byte)(dest &gt;&gt; 8));
+      _outStream.WriteByte((Byte)(dest &gt;&gt; 16));
+      _outStream.WriteByte((Byte)(dest &gt;&gt; 24));
+      prevByte = (dest &gt;&gt; 24);
+      processedBytes += 4;
+    }
+    else
+      prevByte = b;
+  }
+}
+
+STDMETHODIMP CBCJ2_x86_Decoder::Code(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress)
+{
+  try
+  {
+    return CodeReal(inStreams, inSizes, numInStreams,
+        outStreams, outSizes,numOutStreams, progress);
+  }
+  catch(const COutBufferException &amp;e) { return e.ErrorCode; }
+  catch(...) { return S_FALSE; }
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,133 @@
+// x86_2.h
+
+#ifndef __BRANCH_X86_2_H
+#define __BRANCH_X86_2_H
+
+#include &quot;../../../Common/MyCom.h&quot;
+#include &quot;../RangeCoder/RangeCoderBit.h&quot;
+#include &quot;../../ICoder.h&quot;
+
+// {23170F69-40C1-278B-0303-010100000100}
+#define MyClass2_a(Name, id, subId, encodingId)  \
+DEFINE_GUID(CLSID_CCompressConvert ## Name,  \
+0x23170F69, 0x40C1, 0x278B, 0x03, 0x03, id, subId, 0x00, 0x00, encodingId, 0x00);
+
+#define MyClass_a(Name, id, subId)  \
+MyClass2_a(Name ## _Encoder, id, subId, 0x01) \
+MyClass2_a(Name ## _Decoder, id, subId, 0x00) 
+
+MyClass_a(BCJ2_x86, 0x01, 0x1B)
+
+const int kNumMoveBits = 5;
+
+#ifndef EXTRACT_ONLY
+
+class CBCJ2_x86_Encoder:
+  public ICompressCoder2,
+  public CMyUnknownImp
+{
+  Byte *_buffer;
+public:
+  CBCJ2_x86_Encoder(): _buffer(0) {};
+  ~CBCJ2_x86_Encoder();
+  bool Create();
+
+  COutBuffer _mainStream;
+  COutBuffer _callStream;
+  COutBuffer _jumpStream;
+  NCompress::NRangeCoder::CEncoder _rangeEncoder;
+  NCompress::NRangeCoder::CBitEncoder&lt;kNumMoveBits&gt; _statusE8Encoder[256];
+  NCompress::NRangeCoder::CBitEncoder&lt;kNumMoveBits&gt; _statusE9Encoder;
+  NCompress::NRangeCoder::CBitEncoder&lt;kNumMoveBits&gt; _statusJccEncoder;
+
+  HRESULT Flush();
+  void ReleaseStreams()
+  {
+    _mainStream.ReleaseStream();
+    _callStream.ReleaseStream();
+    _jumpStream.ReleaseStream();
+    _rangeEncoder.ReleaseStream();
+  }
+
+  class CCoderReleaser
+  {
+    CBCJ2_x86_Encoder *_coder;
+  public:
+    CCoderReleaser(CBCJ2_x86_Encoder *coder): _coder(coder) {}
+    ~CCoderReleaser() {  _coder-&gt;ReleaseStreams(); }
+  };
+
+public: 
+
+  MY_UNKNOWN_IMP
+
+  HRESULT CodeReal(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress);
+  STDMETHOD(Code)(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress);
+}; 
+
+#endif
+
+class CBCJ2_x86_Decoder:
+  public ICompressCoder2,
+  public CMyUnknownImp
+{ 
+public:
+  CInBuffer _mainInStream;
+  CInBuffer _callStream;
+  CInBuffer _jumpStream;
+  NCompress::NRangeCoder::CDecoder _rangeDecoder;
+  NCompress::NRangeCoder::CBitDecoder&lt;kNumMoveBits&gt; _statusE8Decoder[256];
+  NCompress::NRangeCoder::CBitDecoder&lt;kNumMoveBits&gt; _statusE9Decoder;
+  NCompress::NRangeCoder::CBitDecoder&lt;kNumMoveBits&gt; _statusJccDecoder;
+
+  COutBuffer _outStream;
+
+  void ReleaseStreams()
+  {
+    _mainInStream.ReleaseStream();
+    _callStream.ReleaseStream();
+    _jumpStream.ReleaseStream();
+    _rangeDecoder.ReleaseStream();
+    _outStream.ReleaseStream();
+  }
+
+  HRESULT Flush() { return _outStream.Flush(); }
+  class CCoderReleaser
+  {
+    CBCJ2_x86_Decoder *_coder;
+  public:
+    CCoderReleaser(CBCJ2_x86_Decoder *coder): _coder(coder) {}
+    ~CCoderReleaser()  { _coder-&gt;ReleaseStreams(); }
+  };
+
+public: 
+  MY_UNKNOWN_IMP
+  HRESULT CodeReal(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress);
+  STDMETHOD(Code)(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress);
+}; 
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/Branch/x86_2.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,54 @@
+// BinTree.h
+
+#include &quot;../LZInWindow.h&quot;
+#include &quot;../IMatchFinder.h&quot;
+ 
+namespace BT_NAMESPACE {
+
+typedef UInt32 CIndex;
+const UInt32 kMaxValForNormalize = (UInt32(1) &lt;&lt; 31) - 1;
+
+class CMatchFinder: 
+  public IMatchFinder,
+  public CLZInWindow,
+  public CMyUnknownImp,
+  public IMatchFinderSetNumPasses
+{
+  UInt32 _cyclicBufferPos;
+  UInt32 _cyclicBufferSize; // it must be historySize + 1
+  UInt32 _matchMaxLen;
+  CIndex *_hash;
+  CIndex *_son;
+  UInt32 _hashMask;
+  UInt32 _cutValue;
+  UInt32 _hashSizeSum;
+
+  void Normalize();
+  void FreeThisClassMemory();
+  void FreeMemory();
+
+  MY_UNKNOWN_IMP
+
+  STDMETHOD(SetStream)(ISequentialInStream *inStream);
+  STDMETHOD_(void, ReleaseStream)();
+  STDMETHOD(Init)();
+  HRESULT MovePos();
+  STDMETHOD_(Byte, GetIndexByte)(Int32 index);
+  STDMETHOD_(UInt32, GetMatchLen)(Int32 index, UInt32 back, UInt32 limit);
+  STDMETHOD_(UInt32, GetNumAvailableBytes)();
+  STDMETHOD_(const Byte *, GetPointerToCurrentPos)();
+  STDMETHOD_(Int32, NeedChangeBufferPos)(UInt32 numCheckBytes);
+  STDMETHOD_(void, ChangeBufferPos)();
+
+  STDMETHOD(Create)(UInt32 historySize, UInt32 keepAddBufferBefore, 
+      UInt32 matchMaxLen, UInt32 keepAddBufferAfter);
+  STDMETHOD(GetMatches)(UInt32 *distances);
+  STDMETHOD(Skip)(UInt32 num);
+
+public:
+  CMatchFinder();
+  virtual ~CMatchFinder();
+  virtual void SetNumPasses(UInt32 numPasses) { _cutValue = numPasses; }
+};
+
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree2.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree2.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree2.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,12 @@
+// BinTree2.h
+
+#ifndef __BINTREE2_H
+#define __BINTREE2_H
+
+#define BT_NAMESPACE NBT2
+
+#include &quot;BinTreeMain.h&quot;
+
+#undef BT_NAMESPACE
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree2.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,16 @@
+// BinTree3.h
+
+#ifndef __BINTREE3_H
+#define __BINTREE3_H
+
+#define BT_NAMESPACE NBT3
+
+#define HASH_ARRAY_2
+
+#include &quot;BinTreeMain.h&quot;
+
+#undef HASH_ARRAY_2
+
+#undef BT_NAMESPACE
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3Z.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3Z.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3Z.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,16 @@
+// BinTree3Z.h
+
+#ifndef __BINTREE3Z_H
+#define __BINTREE3Z_H
+
+#define BT_NAMESPACE NBT3Z
+
+#define HASH_ZIP
+
+#include &quot;BinTreeMain.h&quot;
+
+#undef HASH_ZIP
+
+#undef BT_NAMESPACE
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree3Z.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree4.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree4.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree4.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,18 @@
+// BinTree4.h
+
+#ifndef __BINTREE4_H
+#define __BINTREE4_H
+
+#define BT_NAMESPACE NBT4
+
+#define HASH_ARRAY_2
+#define HASH_ARRAY_3
+
+#include &quot;BinTreeMain.h&quot;
+
+#undef HASH_ARRAY_2
+#undef HASH_ARRAY_3
+
+#undef BT_NAMESPACE
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTree4.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTreeMain.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTreeMain.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTreeMain.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,531 @@
+// BinTreeMain.h
+
+#include &quot;../../../../Common/Defs.h&quot;
+#include &quot;../../../../Common/CRC.h&quot;
+#include &quot;../../../../Common/Alloc.h&quot;
+
+#include &quot;BinTree.h&quot;
+
+// #include &lt;xmmintrin.h&gt;
+// It's for prefetch
+// But prefetch doesn't give big gain in K8.
+
+namespace BT_NAMESPACE {
+
+#ifdef HASH_ARRAY_2
+  static const UInt32 kHash2Size = 1 &lt;&lt; 10;
+  #define kNumHashDirectBytes 0
+  #ifdef HASH_ARRAY_3
+    static const UInt32 kNumHashBytes = 4;
+    static const UInt32 kHash3Size = 1 &lt;&lt; 16;
+  #else
+    static const UInt32 kNumHashBytes = 3;
+  #endif
+  static const UInt32 kHashSize = 0;
+  static const UInt32 kMinMatchCheck = kNumHashBytes;
+  static const UInt32 kStartMaxLen = 1;
+#else
+  #ifdef HASH_ZIP 
+    #define kNumHashDirectBytes 0
+    static const UInt32 kNumHashBytes = 3;
+    static const UInt32 kHashSize = 1 &lt;&lt; 16;
+    static const UInt32 kMinMatchCheck = kNumHashBytes;
+    static const UInt32 kStartMaxLen = 1;
+  #else
+    #define kNumHashDirectBytes 2
+    static const UInt32 kNumHashBytes = 2;
+    static const UInt32 kHashSize = 1 &lt;&lt; (8 * kNumHashBytes);
+    static const UInt32 kMinMatchCheck = kNumHashBytes + 1;
+    static const UInt32 kStartMaxLen = 1;
+  #endif
+#endif
+
+#ifdef HASH_ARRAY_2
+#ifdef HASH_ARRAY_3
+static const UInt32 kHash3Offset = kHash2Size;
+#endif
+#endif
+
+static const UInt32 kFixHashSize = 0
+    #ifdef HASH_ARRAY_2
+    + kHash2Size
+    #ifdef HASH_ARRAY_3
+    + kHash3Size
+    #endif
+    #endif
+    ;
+
+CMatchFinder::CMatchFinder():
+  _hash(0)
+{
+}
+
+void CMatchFinder::FreeThisClassMemory()
+{
+  BigFree(_hash);
+  _hash = 0;
+}
+
+void CMatchFinder::FreeMemory()
+{
+  FreeThisClassMemory();
+  CLZInWindow::Free();
+}
+
+CMatchFinder::~CMatchFinder()
+{ 
+  FreeMemory();
+}
+
+STDMETHODIMP CMatchFinder::Create(UInt32 historySize, UInt32 keepAddBufferBefore, 
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter)
+{
+  if (historySize &gt; kMaxValForNormalize - 256)
+  {
+    FreeMemory();
+    return E_INVALIDARG;
+  }
+  _cutValue = 
+  #ifdef _HASH_CHAIN
+    8 + (matchMaxLen &gt;&gt; 2);
+  #else
+    16 + (matchMaxLen &gt;&gt; 1);
+  #endif
+  UInt32 sizeReserv = (historySize + keepAddBufferBefore + 
+      matchMaxLen + keepAddBufferAfter) / 2 + 256;
+  if (CLZInWindow::Create(historySize + keepAddBufferBefore, 
+      matchMaxLen + keepAddBufferAfter, sizeReserv))
+  {
+    _matchMaxLen = matchMaxLen;
+    UInt32 newCyclicBufferSize = historySize + 1;
+    if (_hash != 0 &amp;&amp; newCyclicBufferSize == _cyclicBufferSize)
+      return S_OK;
+    FreeThisClassMemory();
+    _cyclicBufferSize = newCyclicBufferSize; // don't change it
+
+    UInt32 hs = kHashSize;
+
+    #ifdef HASH_ARRAY_2
+    hs = historySize - 1;
+    hs |= (hs &gt;&gt; 1);
+    hs |= (hs &gt;&gt; 2);
+    hs |= (hs &gt;&gt; 4);
+    hs |= (hs &gt;&gt; 8);
+    hs &gt;&gt;= 1;
+    hs |= 0xFFFF;
+    if (hs &gt; (1 &lt;&lt; 24))
+    {
+      #ifdef HASH_ARRAY_3
+      hs &gt;&gt;= 1;
+      #else
+      hs = (1 &lt;&lt; 24) - 1;
+      #endif
+    }
+    _hashMask = hs;
+    hs++;
+    #endif
+    _hashSizeSum = hs + kFixHashSize;
+    UInt32 numItems = _hashSizeSum + _cyclicBufferSize
+    #ifndef _HASH_CHAIN
+     * 2
+    #endif
+    ;
+    size_t sizeInBytes = (size_t)numItems * sizeof(CIndex);
+    if (sizeInBytes / sizeof(CIndex) != numItems)
+      return E_OUTOFMEMORY;
+    _hash = (CIndex *)BigAlloc(sizeInBytes);
+    _son = _hash + _hashSizeSum;
+    if (_hash != 0)
+      return S_OK;
+  }
+  FreeMemory();
+  return E_OUTOFMEMORY;
+}
+
+static const UInt32 kEmptyHashValue = 0;
+
+STDMETHODIMP CMatchFinder::SetStream(ISequentialInStream *stream)
+{
+  CLZInWindow::SetStream(stream);
+  return S_OK;
+}
+
+STDMETHODIMP CMatchFinder::Init()
+{
+  RINOK(CLZInWindow::Init());
+  for(UInt32 i = 0; i &lt; _hashSizeSum; i++)
+    _hash[i] = kEmptyHashValue;
+  _cyclicBufferPos = 0;
+  ReduceOffsets(-1);
+  return S_OK;
+}
+
+STDMETHODIMP_(void) CMatchFinder::ReleaseStream()
+{ 
+  // ReleaseStream(); 
+}
+
+#ifdef HASH_ARRAY_2
+#ifdef HASH_ARRAY_3
+
+#define HASH_CALC { \
+  UInt32 temp = CCRC::Table[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hash3Value = (temp ^ (UInt32(cur[2]) &lt;&lt; 8)) &amp; (kHash3Size - 1); \
+  hashValue = (temp ^ (UInt32(cur[2]) &lt;&lt; 8) ^ (CCRC::Table[cur[3]] &lt;&lt; 5)) &amp; _hashMask; }
+  
+#else // no HASH_ARRAY_3
+#define HASH_CALC { \
+  UInt32 temp = CCRC::Table[cur[0]] ^ cur[1]; \
+  hash2Value = temp &amp; (kHash2Size - 1); \
+  hashValue = (temp ^ (UInt32(cur[2]) &lt;&lt; 8)) &amp; _hashMask; }
+#endif // HASH_ARRAY_3
+#else // no HASH_ARRAY_2
+#ifdef HASH_ZIP 
+inline UInt32 Hash(const Byte *pointer)
+{
+  return ((UInt32(pointer[0]) &lt;&lt; 8) ^ CCRC::Table[pointer[1]] ^ pointer[2]) &amp; (kHashSize - 1);
+}
+#else // no HASH_ZIP 
+inline UInt32 Hash(const Byte *pointer)
+{
+  return pointer[0] ^ (UInt32(pointer[1]) &lt;&lt; 8);
+}
+#endif // HASH_ZIP
+#endif // HASH_ARRAY_2
+
+STDMETHODIMP CMatchFinder::GetMatches(UInt32 *distances)
+{
+  UInt32 lenLimit;
+  if (_pos + _matchMaxLen &lt;= _streamPos)
+    lenLimit = _matchMaxLen;
+  else
+  {
+    lenLimit = _streamPos - _pos;
+    if(lenLimit &lt; kMinMatchCheck)
+    {
+      distances[0] = 0;
+      return MovePos(); 
+    }
+  }
+
+  int offset = 1;
+
+  UInt32 matchMinPos = (_pos &gt; _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
+  const Byte *cur = _buffer + _pos;
+
+  UInt32 maxLen = kStartMaxLen; // to avoid items for len &lt; hashSize;
+
+  #ifdef HASH_ARRAY_2
+  UInt32 hash2Value;
+  #ifdef HASH_ARRAY_3
+  UInt32 hash3Value;
+  #endif
+  UInt32 hashValue;
+  HASH_CALC;
+  #else
+  UInt32 hashValue = Hash(cur);
+  #endif
+
+  UInt32 curMatch = _hash[kFixHashSize + hashValue];
+  #ifdef HASH_ARRAY_2
+  UInt32 curMatch2 = _hash[hash2Value];
+  #ifdef HASH_ARRAY_3
+  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];
+  #endif
+  _hash[hash2Value] = _pos;
+  if(curMatch2 &gt; matchMinPos)
+    if (_buffer[curMatch2] == cur[0])
+    {
+      distances[offset++] = maxLen = 2;
+      distances[offset++] = _pos - curMatch2 - 1;
+    }
+
+  #ifdef HASH_ARRAY_3
+  _hash[kHash3Offset + hash3Value] = _pos;
+  if(curMatch3 &gt; matchMinPos)
+    if (_buffer[curMatch3] == cur[0])
+    {
+      if (curMatch3 == curMatch2)
+        offset -= 2;
+      distances[offset++] = maxLen = 3;
+      distances[offset++] = _pos - curMatch3 - 1;
+      curMatch2 = curMatch3;
+    }
+  #endif
+  if (offset != 1 &amp;&amp; curMatch2 == curMatch)
+  {
+    offset -= 2;
+    maxLen = kStartMaxLen;
+  }
+  #endif
+
+  _hash[kFixHashSize + hashValue] = _pos;
+
+  CIndex *son = _son;
+
+  #ifdef _HASH_CHAIN
+  son[_cyclicBufferPos] = curMatch;
+  #else
+  CIndex *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
+  CIndex *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
+
+  UInt32 len0, len1;
+  len0 = len1 = kNumHashDirectBytes;
+  #endif
+
+  #if kNumHashDirectBytes != 0
+  if(curMatch &gt; matchMinPos)
+  {
+    if (_buffer[curMatch + kNumHashDirectBytes] != cur[kNumHashDirectBytes])
+    {
+      distances[offset++] = maxLen = kNumHashDirectBytes;
+      distances[offset++] = _pos - curMatch - 1;
+    }
+  }
+  #endif
+  UInt32 count = _cutValue;
+  while(true)
+  {
+    if(curMatch &lt;= matchMinPos || count-- == 0)
+    {
+      #ifndef _HASH_CHAIN
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      #endif
+      break;
+    }
+    UInt32 delta = _pos - curMatch;
+    UInt32 cyclicPos = (delta &lt;= _cyclicBufferPos) ?
+        (_cyclicBufferPos - delta):
+        (_cyclicBufferPos - delta + _cyclicBufferSize);
+    CIndex *pair = son + 
+    #ifdef _HASH_CHAIN
+      cyclicPos;
+    #else
+      (cyclicPos &lt;&lt; 1);
+    #endif
+    
+    // _mm_prefetch((const char *)pair, _MM_HINT_T0);
+    
+    const Byte *pb = _buffer + curMatch;
+    UInt32 len = 
+    #ifdef _HASH_CHAIN
+    kNumHashDirectBytes;
+    if (pb[maxLen] == cur[maxLen])
+    #else
+    MyMin(len0, len1);
+    #endif
+    if (pb[len] == cur[len])
+    {
+      while(++len != lenLimit)
+        if (pb[len] != cur[len])
+          break;
+      if (maxLen &lt; len)
+      {
+        distances[offset++] = maxLen = len;
+        distances[offset++] = delta - 1;
+        if (len == lenLimit)
+        {
+          #ifndef _HASH_CHAIN
+          *ptr1 = pair[0];
+          *ptr0 = pair[1];
+          #endif
+          break;
+        }
+      }
+    }
+    #ifdef _HASH_CHAIN
+    curMatch = *pair;
+    #else
+    if (pb[len] &lt; cur[len])
+    {
+      *ptr1 = curMatch;
+      ptr1 = pair + 1;
+      curMatch = *ptr1;
+      len1 = len;
+    }
+    else
+    {
+      *ptr0 = curMatch;
+      ptr0 = pair;
+      curMatch = *ptr0;
+      len0 = len;
+    }
+    #endif
+  }
+  distances[0] = offset - 1;
+  if (++_cyclicBufferPos == _cyclicBufferSize)
+    _cyclicBufferPos = 0;
+  RINOK(CLZInWindow::MovePos());
+  if (_pos == kMaxValForNormalize)
+    Normalize();
+  return S_OK;
+}
+
+STDMETHODIMP CMatchFinder::Skip(UInt32 num)
+{
+  do
+  {
+  #ifdef _HASH_CHAIN
+  if (_streamPos - _pos &lt; kNumHashBytes)
+  {
+    RINOK(MovePos()); 
+    continue;
+  }
+  #else
+  UInt32 lenLimit;
+  if (_pos + _matchMaxLen &lt;= _streamPos)
+    lenLimit = _matchMaxLen;
+  else
+  {
+    lenLimit = _streamPos - _pos;
+    if(lenLimit &lt; kMinMatchCheck)
+    {
+      RINOK(MovePos());
+      continue;
+    }
+  }
+  UInt32 matchMinPos = (_pos &gt; _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
+  #endif
+  const Byte *cur = _buffer + _pos;
+
+  #ifdef HASH_ARRAY_2
+  UInt32 hash2Value;
+  #ifdef HASH_ARRAY_3
+  UInt32 hash3Value;
+  UInt32 hashValue;
+  HASH_CALC;
+  _hash[kHash3Offset + hash3Value] = _pos;
+  #else
+  UInt32 hashValue;
+  HASH_CALC;
+  #endif
+  _hash[hash2Value] = _pos;
+  #else
+  UInt32 hashValue = Hash(cur);
+  #endif
+
+  UInt32 curMatch = _hash[kFixHashSize + hashValue];
+  _hash[kFixHashSize + hashValue] = _pos;
+
+  #ifdef _HASH_CHAIN
+  _son[_cyclicBufferPos] = curMatch;
+  #else
+  CIndex *son = _son;
+  CIndex *ptr0 = son + (_cyclicBufferPos &lt;&lt; 1) + 1;
+  CIndex *ptr1 = son + (_cyclicBufferPos &lt;&lt; 1);
+
+  UInt32 len0, len1;
+  len0 = len1 = kNumHashDirectBytes;
+  UInt32 count = _cutValue;
+  while(true)
+  {
+    if(curMatch &lt;= matchMinPos || count-- == 0)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      break;
+    }
+    
+    UInt32 delta = _pos - curMatch;
+    UInt32 cyclicPos = (delta &lt;= _cyclicBufferPos) ?
+      (_cyclicBufferPos - delta):
+      (_cyclicBufferPos - delta + _cyclicBufferSize);
+    CIndex *pair = son + (cyclicPos &lt;&lt; 1);
+    
+    // _mm_prefetch((const char *)pair, _MM_HINT_T0);
+    
+    const Byte *pb = _buffer + curMatch;
+    UInt32 len = MyMin(len0, len1);
+    
+    if (pb[len] == cur[len])
+    {
+      while(++len != lenLimit)
+        if (pb[len] != cur[len])
+          break;
+      if (len == lenLimit)
+      {
+        *ptr1 = pair[0];
+        *ptr0 = pair[1];
+        break;
+      }
+    }
+    if (pb[len] &lt; cur[len])
+    {
+      *ptr1 = curMatch;
+      ptr1 = pair + 1;
+      curMatch = *ptr1;
+      len1 = len;
+    }
+    else
+    {
+      *ptr0 = curMatch;
+      ptr0 = pair;
+      curMatch = *ptr0;
+      len0 = len;
+    }
+  }
+  #endif
+  if (++_cyclicBufferPos == _cyclicBufferSize)
+    _cyclicBufferPos = 0;
+  RINOK(CLZInWindow::MovePos());
+  if (_pos == kMaxValForNormalize)
+    Normalize();
+  }
+  while(--num != 0);
+  return S_OK;
+}
+
+void CMatchFinder::Normalize()
+{
+  UInt32 subValue = _pos - _cyclicBufferSize;
+  CIndex *items = _hash;
+  UInt32 numItems = (_hashSizeSum + _cyclicBufferSize 
+    #ifndef _HASH_CHAIN
+     * 2
+    #endif
+    );
+  for (UInt32 i = 0; i &lt; numItems; i++)
+  {
+    UInt32 value = items[i];
+    if (value &lt;= subValue)
+      value = kEmptyHashValue;
+    else
+      value -= subValue;
+    items[i] = value;
+  }
+  ReduceOffsets(subValue);
+}
+
+HRESULT CMatchFinder::MovePos()
+{
+  if (++_cyclicBufferPos == _cyclicBufferSize)
+    _cyclicBufferPos = 0;
+  RINOK(CLZInWindow::MovePos());
+  if (_pos == kMaxValForNormalize)
+    Normalize();
+  return S_OK;
+}
+
+STDMETHODIMP_(Byte) CMatchFinder::GetIndexByte(Int32 index)
+  { return CLZInWindow::GetIndexByte(index); }
+
+STDMETHODIMP_(UInt32) CMatchFinder::GetMatchLen(Int32 index, 
+    UInt32 back, UInt32 limit)
+  { return CLZInWindow::GetMatchLen(index, back, limit); }
+
+STDMETHODIMP_(UInt32) CMatchFinder::GetNumAvailableBytes()
+  { return CLZInWindow::GetNumAvailableBytes(); }
+
+STDMETHODIMP_(const Byte *) CMatchFinder::GetPointerToCurrentPos()
+  { return CLZInWindow::GetPointerToCurrentPos(); }
+
+STDMETHODIMP_(Int32) CMatchFinder::NeedChangeBufferPos(UInt32 numCheckBytes)
+  { return CLZInWindow::NeedMove(numCheckBytes) ? 1: 0; }
+
+STDMETHODIMP_(void) CMatchFinder::ChangeBufferPos()
+  { CLZInWindow::MoveBlock();}
+
+#undef HASH_CALC
+#undef kNumHashDirectBytes
+ 
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/BinTree/BinTreeMain.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC2.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC2.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC2.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,13 @@
+// HC2.h
+
+#ifndef __HC2_H
+#define __HC2_H
+
+#define BT_NAMESPACE NHC2
+
+#include &quot;HCMain.h&quot;
+
+#undef BT_NAMESPACE
+
+#endif
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC2.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC3.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC3.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC3.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,16 @@
+// HC3.h
+
+#ifndef __HC3_H
+#define __HC3_H
+
+#define BT_NAMESPACE NHC3
+
+#define HASH_ARRAY_2
+
+#include &quot;HCMain.h&quot;
+
+#undef HASH_ARRAY_2
+#undef BT_NAMESPACE
+
+#endif
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC3.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC4.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC4.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC4.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,19 @@
+// HC4.h
+
+#ifndef __HC4_H
+#define __HC4_H
+
+#define BT_NAMESPACE NHC4
+
+#define HASH_ARRAY_2
+#define HASH_ARRAY_3
+
+#include &quot;HCMain.h&quot;
+
+#undef HASH_ARRAY_2
+#undef HASH_ARRAY_3
+
+#undef BT_NAMESPACE
+
+#endif
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HC4.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HCMain.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HCMain.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HCMain.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,6 @@
+// HCMain.h
+
+#define _HASH_CHAIN
+#include &quot;../BinTree/BinTreeMain.h&quot;
+#undef _HASH_CHAIN
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/HashChain/HCMain.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/IMatchFinder.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/IMatchFinder.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/IMatchFinder.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,32 @@
+// MatchFinders/IMatchFinder.h
+
+#ifndef __IMATCHFINDER_H
+#define __IMATCHFINDER_H
+
+struct IInWindowStream: public IUnknown
+{
+  STDMETHOD(SetStream)(ISequentialInStream *inStream) PURE;
+  STDMETHOD_(void, ReleaseStream)() PURE;
+  STDMETHOD(Init)() PURE;
+  STDMETHOD_(Byte, GetIndexByte)(Int32 index) PURE;
+  STDMETHOD_(UInt32, GetMatchLen)(Int32 index, UInt32 distance, UInt32 limit) PURE;
+  STDMETHOD_(UInt32, GetNumAvailableBytes)() PURE;
+  STDMETHOD_(const Byte *, GetPointerToCurrentPos)() PURE;
+  STDMETHOD_(Int32, NeedChangeBufferPos)(UInt32 numCheckBytes) PURE;
+  STDMETHOD_(void, ChangeBufferPos)() PURE;
+};
+ 
+struct IMatchFinder: public IInWindowStream
+{
+  STDMETHOD(Create)(UInt32 historySize, UInt32 keepAddBufferBefore, 
+      UInt32 matchMaxLen, UInt32 keepAddBufferAfter) PURE;
+  STDMETHOD(GetMatches)(UInt32 *distances) PURE;
+  STDMETHOD(Skip)(UInt32 num) PURE;
+};
+
+struct IMatchFinderSetNumPasses
+{
+  virtual void SetNumPasses(UInt32 numPasses) PURE;
+};
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/IMatchFinder.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,105 @@
+// LZInWindow.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;LZInWindow.h&quot;
+#include &quot;../../../Common/MyCom.h&quot;
+#include &quot;../../../Common/Alloc.h&quot;
+
+void CLZInWindow::Free()
+{
+  ::BigFree(_bufferBase);
+  _bufferBase = 0;
+}
+
+bool CLZInWindow::Create(UInt32 keepSizeBefore, UInt32 keepSizeAfter, UInt32 keepSizeReserv)
+{
+  _keepSizeBefore = keepSizeBefore;
+  _keepSizeAfter = keepSizeAfter;
+  UInt32 blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
+  if (_bufferBase == 0 || _blockSize != blockSize)
+  {
+    Free();
+    _blockSize = blockSize;
+    if (_blockSize != 0)
+      _bufferBase = (Byte *)::BigAlloc(_blockSize);
+  }
+  _pointerToLastSafePosition = _bufferBase + _blockSize - keepSizeAfter;
+  if (_blockSize == 0)
+    return true;
+  return (_bufferBase != 0);
+}
+
+void CLZInWindow::SetStream(ISequentialInStream *stream)
+{
+  _stream = stream;
+}
+
+HRESULT CLZInWindow::Init()
+{
+  _buffer = _bufferBase;
+  _pos = 0;
+  _streamPos = 0;
+  _streamEndWasReached = false;
+  return ReadBlock();
+}
+
+/*
+void CLZInWindow::ReleaseStream()
+{
+  _stream.Release();
+}
+*/
+
+///////////////////////////////////////////
+// ReadBlock
+
+// In State:
+//   (_buffer + _streamPos) &lt;= (_bufferBase + _blockSize)
+// Out State:
+//   _posLimit &lt;= _blockSize - _keepSizeAfter;
+//   if(_streamEndWasReached == false):
+//     _streamPos &gt;= _pos + _keepSizeAfter
+//     _posLimit = _streamPos - _keepSizeAfter;
+//   else
+//          
+  
+HRESULT CLZInWindow::ReadBlock()
+{
+  if(_streamEndWasReached)
+    return S_OK;
+  while(true)
+  {
+    UInt32 size = (UInt32)(_bufferBase - _buffer) + _blockSize - _streamPos;
+    if(size == 0)
+      return S_OK;
+    UInt32 numReadBytes;
+    RINOK(_stream-&gt;Read(_buffer + _streamPos, size, &amp;numReadBytes));
+    if(numReadBytes == 0)
+    {
+      _posLimit = _streamPos;
+      const Byte *pointerToPostion = _buffer + _posLimit;
+      if(pointerToPostion &gt; _pointerToLastSafePosition)
+        _posLimit = (UInt32)(_pointerToLastSafePosition - _buffer);
+      _streamEndWasReached = true;
+      return S_OK;
+    }
+    _streamPos += numReadBytes;
+    if(_streamPos &gt;= _pos + _keepSizeAfter)
+    {
+      _posLimit = _streamPos - _keepSizeAfter;
+      return S_OK;
+    }
+  }
+}
+
+void CLZInWindow::MoveBlock()
+{
+  UInt32 offset = (UInt32)(_buffer - _bufferBase) + _pos - _keepSizeBefore;
+  // we need one additional byte, since MovePos moves on 1 byte.
+  if (offset &gt; 0)
+    offset--; 
+  UInt32 numBytes = (UInt32)(_buffer - _bufferBase) + _streamPos -  offset;
+  memmove(_bufferBase, _bufferBase + offset, numBytes);
+  _buffer -= offset;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,87 @@
+// LZInWindow.h
+
+#ifndef __LZ_IN_WINDOW_H
+#define __LZ_IN_WINDOW_H
+
+#include &quot;../../IStream.h&quot;
+
+class CLZInWindow
+{
+  Byte *_bufferBase; // pointer to buffer with data
+  ISequentialInStream *_stream;
+  UInt32 _posLimit;  // offset (from _buffer) when new block reading must be done
+  bool _streamEndWasReached; // if (true) then _streamPos shows real end of stream
+  const Byte *_pointerToLastSafePosition;
+protected:
+  Byte  *_buffer;   // Pointer to virtual Buffer begin
+  UInt32 _blockSize;  // Size of Allocated memory block
+  UInt32 _pos;             // offset (from _buffer) of curent byte
+  UInt32 _keepSizeBefore;  // how many BYTEs must be kept in buffer before _pos
+  UInt32 _keepSizeAfter;   // how many BYTEs must be kept buffer after _pos
+  UInt32 _streamPos;   // offset (from _buffer) of first not read byte from Stream
+
+  void MoveBlock();
+  HRESULT ReadBlock();
+  void Free();
+public:
+  CLZInWindow(): _bufferBase(0) {}
+  virtual ~CLZInWindow() { Free(); }
+
+  // keepSizeBefore + keepSizeAfter + keepSizeReserv &lt; 4G)
+  bool Create(UInt32 keepSizeBefore, UInt32 keepSizeAfter, UInt32 keepSizeReserv = (1&lt;&lt;17));
+
+  void SetStream(ISequentialInStream *stream);
+  HRESULT Init();
+  // void ReleaseStream();
+
+  Byte *GetBuffer() const { return _buffer; }
+
+  const Byte *GetPointerToCurrentPos() const { return _buffer + _pos; }
+
+  HRESULT MovePos()
+  {
+    _pos++;
+    if (_pos &gt; _posLimit)
+    {
+      const Byte *pointerToPostion = _buffer + _pos;
+      if(pointerToPostion &gt; _pointerToLastSafePosition)
+        MoveBlock();
+      return ReadBlock();
+    }
+    else
+      return S_OK;
+  }
+  Byte GetIndexByte(Int32 index) const  {  return _buffer[(size_t)_pos + index]; }
+
+  // index + limit have not to exceed _keepSizeAfter;
+  // -2G &lt;= index &lt; 2G
+  UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit) const
+  {  
+    if(_streamEndWasReached)
+      if ((_pos + index) + limit &gt; _streamPos)
+        limit = _streamPos - (_pos + index);
+    distance++;
+    const Byte *pby = _buffer + (size_t)_pos + index;
+    UInt32 i;
+    for(i = 0; i &lt; limit &amp;&amp; pby[i] == pby[(size_t)i - distance]; i++);
+    return i;
+  }
+
+  UInt32 GetNumAvailableBytes() const { return _streamPos - _pos; }
+
+  void ReduceOffsets(Int32 subValue)
+  {
+    _buffer += subValue;
+    _posLimit -= subValue;
+    _pos -= subValue;
+    _streamPos -= subValue;
+  }
+
+  bool NeedMove(UInt32 numCheckBytes)
+  {
+    UInt32 reserv = _pointerToLastSafePosition - (_buffer + _pos);
+    return (reserv &lt;= numCheckBytes);
+  }
+};
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZInWindow.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,17 @@
+// LZOutWindow.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;../../../Common/Alloc.h&quot;
+#include &quot;LZOutWindow.h&quot;
+
+void CLZOutWindow::Init(bool solid)
+{
+  if(!solid)
+    COutBuffer::Init();
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = S_OK;
+  #endif
+}
+
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,56 @@
+// LZOutWindow.h
+
+#ifndef __LZ_OUT_WINDOW_H
+#define __LZ_OUT_WINDOW_H
+
+#include &quot;../../IStream.h&quot;
+#include &quot;../../Common/OutBuffer.h&quot;
+
+#ifndef _NO_EXCEPTIONS
+typedef COutBufferException CLZOutWindowException;
+#endif
+
+class CLZOutWindow: public COutBuffer
+{
+public:
+  void Init(bool solid = false);
+  
+  // distance &gt;= 0, len &gt; 0, 
+  bool CopyBlock(UInt32 distance, UInt32 len)
+  {
+    UInt32 pos = _pos - distance - 1;
+    if (distance &gt;= _pos)
+    {
+      if (!_overDict || distance &gt;= _bufferSize)
+        return false;
+      pos += _bufferSize;
+    }
+    do
+    {
+      if (pos == _bufferSize)
+        pos = 0;
+      _buffer[_pos++] = _buffer[pos++];
+      if (_pos == _limitPos)
+        FlushWithCheck();  
+    }
+    while(--len != 0);
+    return true;
+  }
+  
+  void PutByte(Byte b)
+  {
+    _buffer[_pos++] = b;
+    if (_pos == _limitPos)
+      FlushWithCheck();  
+  }
+  
+  Byte GetByte(UInt32 distance) const
+  {
+    UInt32 pos = _pos - distance - 1;
+    if (pos &gt;= _bufferSize)
+      pos += _bufferSize;
+    return _buffer[pos]; 
+  }
+};
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/LZOutWindow.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/StdAfx.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/StdAfx.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/StdAfx.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,6 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#endif 


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZ/StdAfx.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMA.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMA.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMA.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,82 @@
+// LZMA.h
+
+#ifndef __LZMA_H
+#define __LZMA_H
+
+namespace NCompress {
+namespace NLZMA {
+
+const UInt32 kNumRepDistances = 4;
+
+const int kNumStates = 12;
+
+const Byte kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
+const Byte kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
+const Byte kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
+const Byte kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
+
+class CState
+{
+public:
+  Byte Index;
+  void Init() { Index = 0; }
+  void UpdateChar() { Index = kLiteralNextStates[Index]; }
+  void UpdateMatch() { Index = kMatchNextStates[Index]; }
+  void UpdateRep() { Index = kRepNextStates[Index]; }
+  void UpdateShortRep() { Index = kShortRepNextStates[Index]; }
+  bool IsCharState() const { return Index &lt; 7; }
+};
+
+const int kNumPosSlotBits = 6; 
+const int kDicLogSizeMin = 0; 
+const int kDicLogSizeMax = 32; 
+const int kDistTableSizeMax = kDicLogSizeMax * 2; 
+
+const UInt32 kNumLenToPosStates = 4;
+
+inline UInt32 GetLenToPosState(UInt32 len)
+{
+  len -= 2;
+  if (len &lt; kNumLenToPosStates)
+    return len;
+  return kNumLenToPosStates - 1;
+}
+
+namespace NLength {
+
+const int kNumPosStatesBitsMax = 4;
+const UInt32 kNumPosStatesMax = (1 &lt;&lt; kNumPosStatesBitsMax);
+
+const int kNumPosStatesBitsEncodingMax = 4;
+const UInt32 kNumPosStatesEncodingMax = (1 &lt;&lt; kNumPosStatesBitsEncodingMax);
+
+const int kNumLowBits = 3;
+const int kNumMidBits = 3;
+const int kNumHighBits = 8;
+const UInt32 kNumLowSymbols = 1 &lt;&lt; kNumLowBits;
+const UInt32 kNumMidSymbols = 1 &lt;&lt; kNumMidBits;
+const UInt32 kNumSymbolsTotal = kNumLowSymbols + kNumMidSymbols + (1 &lt;&lt; kNumHighBits);
+
+}
+
+const UInt32 kMatchMinLen = 2;
+const UInt32 kMatchMaxLen = kMatchMinLen + NLength::kNumSymbolsTotal - 1;
+
+const int kNumAlignBits = 4;
+const UInt32 kAlignTableSize = 1 &lt;&lt; kNumAlignBits;
+const UInt32 kAlignMask = (kAlignTableSize - 1);
+
+const UInt32 kStartPosModelIndex = 4;
+const UInt32 kEndPosModelIndex = 14;
+const UInt32 kNumPosModels = kEndPosModelIndex - kStartPosModelIndex;
+
+const UInt32 kNumFullDistances = 1 &lt;&lt; (kEndPosModelIndex / 2);
+
+const int kNumLitPosStatesBitsEncodingMax = 4;
+const int kNumLitContextBitsMax = 8;
+
+const int kNumMoveBits = 5;
+
+}}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMA.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,337 @@
+// LZMADecoder.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;LZMADecoder.h&quot;
+#include &quot;../../../Common/Defs.h&quot;
+
+namespace NCompress {
+namespace NLZMA {
+
+const int kLenIdFinished = -1;
+const int kLenIdNeedInit = -2;
+
+void CDecoder::Init()
+{
+  { 
+    for(int i = 0; i &lt; kNumStates; i++)
+    {
+      for (UInt32 j = 0; j &lt;= _posStateMask; j++)
+      {
+        _isMatch[i][j].Init();
+        _isRep0Long[i][j].Init();
+      }
+      _isRep[i].Init();
+      _isRepG0[i].Init();
+      _isRepG1[i].Init();
+      _isRepG2[i].Init();
+    }
+  }
+  { 
+    for (UInt32 i = 0; i &lt; kNumLenToPosStates; i++)
+    _posSlotDecoder[i].Init();
+  }
+  { 
+    for(UInt32 i = 0; i &lt; kNumFullDistances - kEndPosModelIndex; i++)
+      _posDecoders[i].Init();
+  }
+  _posAlignDecoder.Init();
+  _lenDecoder.Init(_posStateMask + 1);
+  _repMatchLenDecoder.Init(_posStateMask + 1);
+  _literalDecoder.Init();
+
+  _state.Init();
+  _reps[0] = _reps[1] = _reps[2] = _reps[3] = 0;
+}
+
+HRESULT CDecoder::CodeSpec(UInt32 curSize)
+{
+  if (_outSizeDefined)
+  {
+    const UInt64 rem = _outSize - _outWindowStream.GetProcessedSize();
+    if (curSize &gt; rem)
+      curSize = (UInt32)rem;
+  }
+
+  if (_remainLen == kLenIdFinished)
+    return S_OK;
+  if (_remainLen == kLenIdNeedInit)
+  {
+    _rangeDecoder.Init();
+    Init();
+    _remainLen = 0;
+  }
+  if (curSize == 0)
+    return S_OK;
+
+  UInt32 rep0 = _reps[0];
+  UInt32 rep1 = _reps[1];
+  UInt32 rep2 = _reps[2];
+  UInt32 rep3 = _reps[3];
+  CState state = _state;
+  Byte previousByte;
+
+  while(_remainLen &gt; 0 &amp;&amp; curSize &gt; 0)
+  {
+    previousByte = _outWindowStream.GetByte(rep0);
+    _outWindowStream.PutByte(previousByte);
+    _remainLen--;
+    curSize--;
+  }
+  UInt64 nowPos64 = _outWindowStream.GetProcessedSize();
+  if (nowPos64 == 0)
+    previousByte = 0;
+  else
+    previousByte = _outWindowStream.GetByte(0);
+
+  while(curSize &gt; 0)
+  {
+    {
+      #ifdef _NO_EXCEPTIONS
+      if (_rangeDecoder.Stream.ErrorCode != S_OK)
+        return _rangeDecoder.Stream.ErrorCode;
+      #endif
+      if (_rangeDecoder.Stream.WasFinished())
+        return S_FALSE;
+      UInt32 posState = UInt32(nowPos64) &amp; _posStateMask;
+      if (_isMatch[state.Index][posState].Decode(&amp;_rangeDecoder) == 0)
+      {
+        if(!state.IsCharState())
+          previousByte = _literalDecoder.DecodeWithMatchByte(&amp;_rangeDecoder, 
+              (UInt32)nowPos64, previousByte, _outWindowStream.GetByte(rep0));
+        else
+          previousByte = _literalDecoder.DecodeNormal(&amp;_rangeDecoder, 
+              (UInt32)nowPos64, previousByte);
+        _outWindowStream.PutByte(previousByte);
+        state.UpdateChar();
+        curSize--;
+        nowPos64++;
+      }
+      else             
+      {
+        UInt32 len;
+        if(_isRep[state.Index].Decode(&amp;_rangeDecoder) == 1)
+        {
+          len = 0;
+          if(_isRepG0[state.Index].Decode(&amp;_rangeDecoder) == 0)
+          {
+            if(_isRep0Long[state.Index][posState].Decode(&amp;_rangeDecoder) == 0)
+            {
+              state.UpdateShortRep();
+              len = 1;
+            }
+          }
+          else
+          {
+            UInt32 distance;
+            if(_isRepG1[state.Index].Decode(&amp;_rangeDecoder) == 0)
+              distance = rep1;
+            else 
+            {
+              if (_isRepG2[state.Index].Decode(&amp;_rangeDecoder) == 0)
+                distance = rep2;
+              else
+              {
+                distance = rep3;
+                rep3 = rep2;
+              }
+              rep2 = rep1;
+            }
+            rep1 = rep0;
+            rep0 = distance;
+          }
+          if (len == 0)
+          {
+            len = _repMatchLenDecoder.Decode(&amp;_rangeDecoder, posState) + kMatchMinLen;
+            state.UpdateRep();
+          }
+        }
+        else
+        {
+          rep3 = rep2;
+          rep2 = rep1;
+          rep1 = rep0;
+          len = kMatchMinLen + _lenDecoder.Decode(&amp;_rangeDecoder, posState);
+          state.UpdateMatch();
+          UInt32 posSlot = _posSlotDecoder[GetLenToPosState(len)].Decode(&amp;_rangeDecoder);
+          if (posSlot &gt;= kStartPosModelIndex)
+          {
+            UInt32 numDirectBits = (posSlot &gt;&gt; 1) - 1;
+            rep0 = ((2 | (posSlot &amp; 1)) &lt;&lt; numDirectBits);
+
+            if (posSlot &lt; kEndPosModelIndex)
+              rep0 += NRangeCoder::ReverseBitTreeDecode(_posDecoders + 
+                  rep0 - posSlot - 1, &amp;_rangeDecoder, numDirectBits);
+            else
+            {
+              rep0 += (_rangeDecoder.DecodeDirectBits(
+                  numDirectBits - kNumAlignBits) &lt;&lt; kNumAlignBits);
+              rep0 += _posAlignDecoder.ReverseDecode(&amp;_rangeDecoder);
+              if (rep0 == 0xFFFFFFFF)
+              {
+                _remainLen = kLenIdFinished;
+                return S_OK;
+              }
+            }
+          }
+          else
+            rep0 = posSlot;
+        }
+        UInt32 locLen = len;
+        if (len &gt; curSize)
+          locLen = (UInt32)curSize;
+        if (!_outWindowStream.CopyBlock(rep0, locLen))
+          return S_FALSE;
+        previousByte = _outWindowStream.GetByte(0);
+        curSize -= locLen;
+        nowPos64 += locLen;
+        len -= locLen;
+        if (len != 0)
+        {
+          _remainLen = (Int32)len;
+          break;
+        }
+
+        #ifdef _NO_EXCEPTIONS
+        if (_outWindowStream.ErrorCode != S_OK)
+          return _outWindowStream.ErrorCode;
+        #endif
+      }
+    }
+  }
+  if (_rangeDecoder.Stream.WasFinished())
+    return S_FALSE;
+  _reps[0] = rep0;
+  _reps[1] = rep1;
+  _reps[2] = rep2;
+  _reps[3] = rep3;
+  _state = state;
+
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::CodeReal(ISequentialInStream *inStream,
+    ISequentialOutStream *outStream, 
+    const UInt64 *, const UInt64 *outSize,
+    ICompressProgressInfo *progress)
+{
+  SetInStream(inStream);
+  _outWindowStream.SetStream(outStream);
+  SetOutStreamSize(outSize);
+  CDecoderFlusher flusher(this);
+
+  while (true)
+  {
+    UInt32 curSize = 1 &lt;&lt; 18;
+    RINOK(CodeSpec(curSize));
+    if (_remainLen == kLenIdFinished)
+      break;
+    if (progress != NULL)
+    {
+      UInt64 inSize = _rangeDecoder.GetProcessedSize();
+      UInt64 nowPos64 = _outWindowStream.GetProcessedSize();
+      RINOK(progress-&gt;SetRatioInfo(&amp;inSize, &amp;nowPos64));
+    }
+    if (_outSizeDefined)
+      if (_outWindowStream.GetProcessedSize() &gt;= _outSize)
+        break;
+  } 
+  flusher.NeedFlush = false;
+  return Flush();
+}
+
+
+#ifdef _NO_EXCEPTIONS
+
+#define LZMA_TRY_BEGIN
+#define LZMA_TRY_END
+
+#else
+
+#define LZMA_TRY_BEGIN try { 
+#define LZMA_TRY_END } \
+  catch(const CInBufferException &amp;e)  { return e.ErrorCode; } \
+  catch(const CLZOutWindowException &amp;e)  { return e.ErrorCode; } \
+  catch(...) { return S_FALSE; }
+
+#endif
+
+
+STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress)
+{
+  LZMA_TRY_BEGIN
+  return CodeReal(inStream, outStream, inSize, outSize, progress); 
+  LZMA_TRY_END
+}
+
+STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *properties, UInt32 size)
+{
+  if (size &lt; 5)
+    return E_INVALIDARG;
+  int lc = properties[0] % 9;
+  Byte remainder = (Byte)(properties[0] / 9);
+  int lp = remainder % 5;
+  int pb = remainder / 5;
+  if (pb &gt; NLength::kNumPosStatesBitsMax)
+    return E_INVALIDARG;
+  _posStateMask = (1 &lt;&lt; pb) - 1;
+  UInt32 dictionarySize = 0;
+  for (int i = 0; i &lt; 4; i++)
+    dictionarySize += ((UInt32)(properties[1 + i])) &lt;&lt; (i * 8);
+  if (!_outWindowStream.Create(dictionarySize))
+    return E_OUTOFMEMORY;
+  if (!_literalDecoder.Create(lp, lc))
+    return E_OUTOFMEMORY;
+  if (!_rangeDecoder.Create(1 &lt;&lt; 20))
+    return E_OUTOFMEMORY;
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::GetInStreamProcessedSize(UInt64 *value)
+{
+  *value = _rangeDecoder.GetProcessedSize();
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::SetInStream(ISequentialInStream *inStream)
+{
+  _rangeDecoder.SetStream(inStream);
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::ReleaseInStream()
+{
+  _rangeDecoder.ReleaseStream();
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::SetOutStreamSize(const UInt64 *outSize)
+{
+  if (_outSizeDefined = (outSize != NULL))
+    _outSize = *outSize;
+  _remainLen = kLenIdNeedInit;
+  _outWindowStream.Init();
+  return S_OK;
+}
+
+#ifdef _ST_MODE
+
+STDMETHODIMP CDecoder::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  LZMA_TRY_BEGIN
+  if (processedSize)
+    *processedSize = 0;
+  const UInt64 startPos = _outWindowStream.GetProcessedSize();
+  _outWindowStream.SetMemStream((Byte *)data);
+  RINOK(CodeSpec(size));
+  if (processedSize)
+    *processedSize = (UInt32)(_outWindowStream.GetProcessedSize() - startPos);
+  return Flush();
+  LZMA_TRY_END
+}
+
+#endif
+
+}}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,251 @@
+// LZMA/Decoder.h
+
+#ifndef __LZMA_DECODER_H
+#define __LZMA_DECODER_H
+
+#include &quot;../../../Common/MyCom.h&quot;
+#include &quot;../../../Common/Alloc.h&quot;
+#include &quot;../../ICoder.h&quot;
+#include &quot;../LZ/LZOutWindow.h&quot;
+#include &quot;../RangeCoder/RangeCoderBitTree.h&quot;
+
+#include &quot;LZMA.h&quot;
+
+namespace NCompress {
+namespace NLZMA {
+
+typedef NRangeCoder::CBitDecoder&lt;kNumMoveBits&gt; CMyBitDecoder;
+
+class CLiteralDecoder2
+{
+  CMyBitDecoder _decoders[0x300];
+public:
+  void Init()
+  {
+    for (int i = 0; i &lt; 0x300; i++)
+      _decoders[i].Init();
+  }
+  Byte DecodeNormal(NRangeCoder::CDecoder *rangeDecoder)
+  {
+    UInt32 symbol = 1;
+    RC_INIT_VAR
+    do
+    {
+      // symbol = (symbol &lt;&lt; 1) | _decoders[0][symbol].Decode(rangeDecoder);
+      RC_GETBIT(kNumMoveBits, _decoders[symbol].Prob, symbol)
+    }
+    while (symbol &lt; 0x100);
+    RC_FLUSH_VAR
+    return (Byte)symbol;
+  }
+  Byte DecodeWithMatchByte(NRangeCoder::CDecoder *rangeDecoder, Byte matchByte)
+  {
+    UInt32 symbol = 1;
+    RC_INIT_VAR
+    do
+    {
+      UInt32 matchBit = (matchByte &gt;&gt; 7) &amp; 1;
+      matchByte &lt;&lt;= 1;
+      // UInt32 bit = _decoders[1 + matchBit][symbol].Decode(rangeDecoder);
+      // symbol = (symbol &lt;&lt; 1) | bit;
+      UInt32 bit;
+      RC_GETBIT2(kNumMoveBits, _decoders[0x100 + (matchBit &lt;&lt; 8) + symbol].Prob, symbol, 
+          bit = 0, bit = 1)
+      if (matchBit != bit)
+      {
+        while (symbol &lt; 0x100)
+        {
+          // symbol = (symbol &lt;&lt; 1) | _decoders[0][symbol].Decode(rangeDecoder);
+          RC_GETBIT(kNumMoveBits, _decoders[symbol].Prob, symbol)
+        }
+        break;
+      }
+    }
+    while (symbol &lt; 0x100);
+    RC_FLUSH_VAR
+    return (Byte)symbol;
+  }
+};
+
+class CLiteralDecoder
+{
+  CLiteralDecoder2 *_coders;
+  int _numPrevBits;
+  int _numPosBits;
+  UInt32 _posMask;
+public:
+  CLiteralDecoder(): _coders(0) {}
+  ~CLiteralDecoder()  { Free(); }
+  void Free()
+  { 
+    MyFree(_coders);
+    _coders = 0;
+  }
+  bool Create(int numPosBits, int numPrevBits)
+  {
+    if (_coders == 0 || (numPosBits + numPrevBits) != 
+        (_numPrevBits + _numPosBits) )
+    {
+      Free();
+      UInt32 numStates = 1 &lt;&lt; (numPosBits + numPrevBits);
+      _coders = (CLiteralDecoder2 *)MyAlloc(numStates * sizeof(CLiteralDecoder2));
+    }
+    _numPosBits = numPosBits;
+    _posMask = (1 &lt;&lt; numPosBits) - 1;
+    _numPrevBits = numPrevBits;
+    return (_coders != 0);
+  }
+  void Init()
+  {
+    UInt32 numStates = 1 &lt;&lt; (_numPrevBits + _numPosBits);
+    for (UInt32 i = 0; i &lt; numStates; i++)
+      _coders[i].Init();
+  }
+  UInt32 GetState(UInt32 pos, Byte prevByte) const
+    { return ((pos &amp; _posMask) &lt;&lt; _numPrevBits) + (prevByte &gt;&gt; (8 - _numPrevBits)); }
+  Byte DecodeNormal(NRangeCoder::CDecoder *rangeDecoder, UInt32 pos, Byte prevByte)
+    { return _coders[GetState(pos, prevByte)].DecodeNormal(rangeDecoder); }
+  Byte DecodeWithMatchByte(NRangeCoder::CDecoder *rangeDecoder, UInt32 pos, Byte prevByte, Byte matchByte)
+    { return _coders[GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte); }
+};
+
+namespace NLength {
+
+class CDecoder
+{
+  CMyBitDecoder _choice;
+  CMyBitDecoder _choice2;
+  NRangeCoder::CBitTreeDecoder&lt;kNumMoveBits, kNumLowBits&gt;  _lowCoder[kNumPosStatesMax];
+  NRangeCoder::CBitTreeDecoder&lt;kNumMoveBits, kNumMidBits&gt;  _midCoder[kNumPosStatesMax];
+  NRangeCoder::CBitTreeDecoder&lt;kNumMoveBits, kNumHighBits&gt; _highCoder; 
+public:
+  void Init(UInt32 numPosStates)
+  {
+    _choice.Init();
+    _choice2.Init();
+    for (UInt32 posState = 0; posState &lt; numPosStates; posState++)
+    {
+      _lowCoder[posState].Init();
+      _midCoder[posState].Init();
+    }
+    _highCoder.Init();
+  }
+  UInt32 Decode(NRangeCoder::CDecoder *rangeDecoder, UInt32 posState)
+  {
+    if(_choice.Decode(rangeDecoder) == 0)
+      return _lowCoder[posState].Decode(rangeDecoder);
+    if(_choice2.Decode(rangeDecoder) == 0)
+      return kNumLowSymbols + _midCoder[posState].Decode(rangeDecoder);
+    return kNumLowSymbols + kNumMidSymbols + _highCoder.Decode(rangeDecoder);
+  }
+};
+
+}
+
+class CDecoder: 
+  public ICompressCoder,
+  public ICompressSetDecoderProperties2,
+  public ICompressGetInStreamProcessedSize,
+  #ifdef _ST_MODE
+  public ICompressSetInStream,
+  public ICompressSetOutStreamSize,
+  public ISequentialInStream,
+  #endif
+  public CMyUnknownImp
+{
+  CLZOutWindow _outWindowStream;
+  NRangeCoder::CDecoder _rangeDecoder;
+
+  CMyBitDecoder _isMatch[kNumStates][NLength::kNumPosStatesMax];
+  CMyBitDecoder _isRep[kNumStates];
+  CMyBitDecoder _isRepG0[kNumStates];
+  CMyBitDecoder _isRepG1[kNumStates];
+  CMyBitDecoder _isRepG2[kNumStates];
+  CMyBitDecoder _isRep0Long[kNumStates][NLength::kNumPosStatesMax];
+
+  NRangeCoder::CBitTreeDecoder&lt;kNumMoveBits, kNumPosSlotBits&gt; _posSlotDecoder[kNumLenToPosStates];
+
+  CMyBitDecoder _posDecoders[kNumFullDistances - kEndPosModelIndex];
+  NRangeCoder::CBitTreeDecoder&lt;kNumMoveBits, kNumAlignBits&gt; _posAlignDecoder;
+  
+  NLength::CDecoder _lenDecoder;
+  NLength::CDecoder _repMatchLenDecoder;
+
+  CLiteralDecoder _literalDecoder;
+
+  UInt32 _posStateMask;
+
+  ///////////////////
+  // State
+  UInt32 _reps[4];
+  CState _state;
+  Int32 _remainLen; // -1 means end of stream. // -2 means need Init
+  UInt64 _outSize;
+  bool _outSizeDefined;
+
+  void Init();
+  HRESULT CodeSpec(UInt32 size);
+public:
+
+  #ifdef _ST_MODE
+  MY_UNKNOWN_IMP5(
+      ICompressSetDecoderProperties2, 
+      ICompressGetInStreamProcessedSize,
+      ICompressSetInStream, 
+      ICompressSetOutStreamSize, 
+      ISequentialInStream)
+  #else
+  MY_UNKNOWN_IMP2(
+      ICompressSetDecoderProperties2,
+      ICompressGetInStreamProcessedSize)
+  #endif
+
+  void ReleaseStreams()
+  {
+    _outWindowStream.ReleaseStream();
+    ReleaseInStream();
+  }
+
+  class CDecoderFlusher
+  {
+    CDecoder *_decoder;
+  public:
+    bool NeedFlush;
+    CDecoderFlusher(CDecoder *decoder): _decoder(decoder), NeedFlush(true) {}
+    ~CDecoderFlusher() 
+    { 
+      if (NeedFlush)
+        _decoder-&gt;Flush();
+      _decoder-&gt;ReleaseStreams(); 
+    }
+  };
+
+  HRESULT Flush() {  return _outWindowStream.Flush(); }  
+
+  STDMETHOD(CodeReal)(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress);
+  
+  STDMETHOD(Code)(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress);
+
+  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);
+
+  STDMETHOD(GetInStreamProcessedSize)(UInt64 *value);
+
+  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
+  STDMETHOD(ReleaseInStream)();
+  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);
+
+  #ifdef _ST_MODE
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+  #endif
+
+  CDecoder(): _outSizeDefined(false) {}
+  virtual ~CDecoder() {}
+};
+
+}}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMADecoder.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,1564 @@
+// LZMA/Encoder.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;../../../Common/Defs.h&quot;
+#include &quot;../../Common/StreamUtils.h&quot;
+
+#include &quot;LZMAEncoder.h&quot;
+
+// for minimal compressing code size define these:
+// #define COMPRESS_MF_BT
+// #define COMPRESS_MF_BT4
+
+#if !defined(COMPRESS_MF_BT) &amp;&amp; !defined(COMPRESS_MF_HC)
+#define COMPRESS_MF_BT
+#define COMPRESS_MF_HC
+#endif
+
+#ifdef COMPRESS_MF_BT
+#if !defined(COMPRESS_MF_BT2) &amp;&amp; !defined(COMPRESS_MF_BT3) &amp;&amp; !defined(COMPRESS_MF_BT4)
+#define COMPRESS_MF_BT2
+#define COMPRESS_MF_BT3
+#define COMPRESS_MF_BT4
+#endif
+#ifdef COMPRESS_MF_BT2
+#include &quot;../LZ/BinTree/BinTree2.h&quot;
+#endif
+#ifdef COMPRESS_MF_BT3
+#include &quot;../LZ/BinTree/BinTree3.h&quot;
+#endif
+#ifdef COMPRESS_MF_BT4
+#include &quot;../LZ/BinTree/BinTree4.h&quot;
+#endif
+#endif
+
+#ifdef COMPRESS_MF_HC
+#include &quot;../LZ/HashChain/HC4.h&quot;
+#endif
+
+#ifdef COMPRESS_MF_MT
+#include &quot;../LZ/MT/MT.h&quot;
+#endif
+
+namespace NCompress {
+namespace NLZMA {
+
+const int kDefaultDictionaryLogSize = 22;
+const UInt32 kNumFastBytesDefault = 0x20;
+
+enum 
+{
+  kBT2,
+  kBT3,
+  kBT4,
+  kHC4
+};
+
+static const wchar_t *kMatchFinderIDs[] = 
+{
+  L&quot;BT2&quot;,
+  L&quot;BT3&quot;,
+  L&quot;BT4&quot;,
+  L&quot;HC4&quot;
+};
+
+Byte g_FastPos[1 &lt;&lt; 11];
+
+class CFastPosInit
+{
+public:
+  CFastPosInit() { Init(); }
+  void Init()
+  {
+    const Byte kFastSlots = 22;
+    int c = 2;
+    g_FastPos[0] = 0;
+    g_FastPos[1] = 1;
+
+    for (Byte slotFast = 2; slotFast &lt; kFastSlots; slotFast++)
+    {
+      UInt32 k = (1 &lt;&lt; ((slotFast &gt;&gt; 1) - 1));
+      for (UInt32 j = 0; j &lt; k; j++, c++)
+        g_FastPos[c] = slotFast;
+    }
+  }
+} g_FastPosInit;
+
+
+void CLiteralEncoder2::Encode(NRangeCoder::CEncoder *rangeEncoder, Byte symbol)
+{
+  UInt32 context = 1;
+  int i = 8;
+  do 
+  {
+    i--;
+    UInt32 bit = (symbol &gt;&gt; i) &amp; 1;
+    _encoders[context].Encode(rangeEncoder, bit);
+    context = (context &lt;&lt; 1) | bit;
+  }
+  while(i != 0);
+}
+
+void CLiteralEncoder2::EncodeMatched(NRangeCoder::CEncoder *rangeEncoder, 
+    Byte matchByte, Byte symbol)
+{
+  UInt32 context = 1;
+  int i = 8;
+  do 
+  {
+    i--;
+    UInt32 bit = (symbol &gt;&gt; i) &amp; 1;
+    UInt32 matchBit = (matchByte &gt;&gt; i) &amp; 1;
+    _encoders[0x100 + (matchBit &lt;&lt; 8) + context].Encode(rangeEncoder, bit);
+    context = (context &lt;&lt; 1) | bit;
+    if (matchBit != bit)
+    {
+      while(i != 0)
+      {
+        i--;
+        UInt32 bit = (symbol &gt;&gt; i) &amp; 1;
+        _encoders[context].Encode(rangeEncoder, bit);
+        context = (context &lt;&lt; 1) | bit;
+      }
+      break;
+    }
+  }
+  while(i != 0);
+}
+
+UInt32 CLiteralEncoder2::GetPrice(bool matchMode, Byte matchByte, Byte symbol) const
+{
+  UInt32 price = 0;
+  UInt32 context = 1;
+  int i = 8;
+  if (matchMode)
+  {
+    do 
+    {
+      i--;
+      UInt32 matchBit = (matchByte &gt;&gt; i) &amp; 1;
+      UInt32 bit = (symbol &gt;&gt; i) &amp; 1;
+      price += _encoders[0x100 + (matchBit &lt;&lt; 8) + context].GetPrice(bit);
+      context = (context &lt;&lt; 1) | bit;
+      if (matchBit != bit)
+        break;
+    }
+    while (i != 0);
+  }
+  while(i != 0)
+  {
+    i--;
+    UInt32 bit = (symbol &gt;&gt; i) &amp; 1;
+    price += _encoders[context].GetPrice(bit);
+    context = (context &lt;&lt; 1) | bit;
+  }
+  return price;
+};
+
+
+namespace NLength {
+
+void CEncoder::Init(UInt32 numPosStates)
+{
+  _choice.Init();
+  _choice2.Init();
+  for (UInt32 posState = 0; posState &lt; numPosStates; posState++)
+  {
+    _lowCoder[posState].Init();
+    _midCoder[posState].Init();
+  }
+  _highCoder.Init();
+}
+
+void CEncoder::Encode(NRangeCoder::CEncoder *rangeEncoder, UInt32 symbol, UInt32 posState)
+{
+  if(symbol &lt; kNumLowSymbols)
+  {
+    _choice.Encode(rangeEncoder, 0);
+    _lowCoder[posState].Encode(rangeEncoder, symbol);
+  }
+  else
+  {
+    _choice.Encode(rangeEncoder, 1);
+    if(symbol &lt; kNumLowSymbols + kNumMidSymbols)
+    {
+      _choice2.Encode(rangeEncoder, 0);
+      _midCoder[posState].Encode(rangeEncoder, symbol - kNumLowSymbols);
+    }
+    else
+    {
+      _choice2.Encode(rangeEncoder, 1);
+      _highCoder.Encode(rangeEncoder, symbol - kNumLowSymbols - kNumMidSymbols);
+    }
+  }
+}
+
+void CEncoder::SetPrices(UInt32 posState, UInt32 numSymbols, UInt32 *prices) const
+{
+  UInt32 a0 = _choice.GetPrice0();
+  UInt32 a1 = _choice.GetPrice1();
+  UInt32 b0 = a1 + _choice2.GetPrice0();
+  UInt32 b1 = a1 + _choice2.GetPrice1();
+  UInt32 i = 0;
+  for (i = 0; i &lt; kNumLowSymbols; i++)
+  {
+    if (i &gt;= numSymbols)
+      return;
+    prices[i] = a0 + _lowCoder[posState].GetPrice(i);
+  }
+  for (; i &lt; kNumLowSymbols + kNumMidSymbols; i++)
+  {
+    if (i &gt;= numSymbols)
+      return;
+    prices[i] = b0 + _midCoder[posState].GetPrice(i - kNumLowSymbols);
+  }
+  for (; i &lt; numSymbols; i++)
+    prices[i] = b1 + _highCoder.GetPrice(i - kNumLowSymbols - kNumMidSymbols);
+}
+
+}
+CEncoder::CEncoder():
+  _numFastBytes(kNumFastBytesDefault),
+  _distTableSize(kDefaultDictionaryLogSize * 2),
+  _posStateBits(2),
+  _posStateMask(4 - 1),
+  _numLiteralPosStateBits(0),
+  _numLiteralContextBits(3),
+  _dictionarySize(1 &lt;&lt; kDefaultDictionaryLogSize),
+  _dictionarySizePrev(UInt32(-1)),
+  _numFastBytesPrev(UInt32(-1)),
+  _matchFinderCycles(0),
+  _matchFinderIndex(kBT4),
+   #ifdef COMPRESS_MF_MT
+  _multiThread(false),
+   #endif
+  _writeEndMark(false),
+  setMfPasses(0)
+{
+  // _maxMode = false;
+  _fastMode = false;
+}
+
+HRESULT CEncoder::Create()
+{
+  if (!_rangeEncoder.Create(1 &lt;&lt; 20))
+    return E_OUTOFMEMORY;
+  if (!_matchFinder)
+  {
+    switch(_matchFinderIndex)
+    {
+      #ifdef COMPRESS_MF_BT
+      #ifdef COMPRESS_MF_BT2
+      case kBT2:
+      {
+        NBT2::CMatchFinder *mfSpec = new NBT2::CMatchFinder;
+        setMfPasses = mfSpec;
+        _matchFinder = mfSpec;
+        break;
+      }
+      #endif
+      #ifdef COMPRESS_MF_BT3
+      case kBT3:
+      {
+        NBT3::CMatchFinder *mfSpec = new NBT3::CMatchFinder;
+        setMfPasses = mfSpec;
+        _matchFinder = mfSpec;
+        break;
+      }
+      #endif
+      #ifdef COMPRESS_MF_BT4
+      case kBT4:
+      {
+        NBT4::CMatchFinder *mfSpec = new NBT4::CMatchFinder;
+        setMfPasses = mfSpec;
+        _matchFinder = mfSpec;
+        break;
+      }
+      #endif
+      #endif
+      
+      #ifdef COMPRESS_MF_HC
+      case kHC4:
+      {
+        NHC4::CMatchFinder *mfSpec = new NHC4::CMatchFinder;
+        setMfPasses = mfSpec;
+        _matchFinder = mfSpec;
+        break;
+      }
+      #endif
+    }
+    if (_matchFinder == 0)
+      return E_OUTOFMEMORY;
+
+    #ifdef COMPRESS_MF_MT
+    if (_multiThread &amp;&amp; !(_fastMode &amp;&amp; (_matchFinderIndex == kHC4)))
+    {
+      CMatchFinderMT *mfSpec = new CMatchFinderMT;
+      if (mfSpec == 0)
+        return E_OUTOFMEMORY;
+      CMyComPtr&lt;IMatchFinder&gt; mf = mfSpec;
+      RINOK(mfSpec-&gt;SetMatchFinder(_matchFinder));
+      _matchFinder.Release();
+      _matchFinder = mf;
+    }
+    #endif
+  }
+  
+  if (!_literalEncoder.Create(_numLiteralPosStateBits, _numLiteralContextBits))
+    return E_OUTOFMEMORY;
+
+  if (_dictionarySize == _dictionarySizePrev &amp;&amp; _numFastBytesPrev == _numFastBytes)
+    return S_OK;
+  RINOK(_matchFinder-&gt;Create(_dictionarySize, kNumOpts, _numFastBytes, kMatchMaxLen + 1)); // actually it's + _numFastBytes - _numFastBytes
+  if (_matchFinderCycles != 0 &amp;&amp; setMfPasses != 0)
+    setMfPasses-&gt;SetNumPasses(_matchFinderCycles);
+  _dictionarySizePrev = _dictionarySize;
+  _numFastBytesPrev = _numFastBytes;
+  return S_OK;
+}
+
+static bool AreStringsEqual(const wchar_t *base, const wchar_t *testString)
+{
+  while (true)
+  {
+    wchar_t c = *testString;
+    if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
+      c -= 0x20;
+    if (*base != c)
+      return false;
+    if (c == 0)
+      return true;
+    base++;
+    testString++;
+  }
+}
+
+static int FindMatchFinder(const wchar_t *s)
+{
+  for (int m = 0; m &lt; (int)(sizeof(kMatchFinderIDs) / sizeof(kMatchFinderIDs[0])); m++)
+    if (AreStringsEqual(kMatchFinderIDs[m], s))
+      return m;
+  return -1;
+}
+
+STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs, 
+    const PROPVARIANT *properties, UInt32 numProperties)
+{
+  for (UInt32 i = 0; i &lt; numProperties; i++)
+  {
+    const PROPVARIANT &amp;prop = properties[i];
+    switch(propIDs[i])
+    {
+      case NCoderPropID::kNumFastBytes:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 numFastBytes = prop.ulVal;
+        if(numFastBytes &lt; 5 || numFastBytes &gt; kMatchMaxLen)
+          return E_INVALIDARG;
+        _numFastBytes = numFastBytes;
+        break;
+      }
+      case NCoderPropID::kMatchFinderCycles:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        _matchFinderCycles = prop.ulVal;
+        break;
+      }
+      case NCoderPropID::kAlgorithm:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 maximize = prop.ulVal;
+        _fastMode = (maximize == 0); 
+        // _maxMode = (maximize &gt;= 2);
+        break;
+      }
+      case NCoderPropID::kMatchFinder:
+      {
+        if (prop.vt != VT_BSTR)
+          return E_INVALIDARG;
+        int matchFinderIndexPrev = _matchFinderIndex;
+        int m = FindMatchFinder(prop.bstrVal);
+        if (m &lt; 0)
+          return E_INVALIDARG;
+        _matchFinderIndex = m;
+        if (_matchFinder &amp;&amp; matchFinderIndexPrev != _matchFinderIndex)
+        {
+          _dictionarySizePrev = (UInt32)-1;
+          ReleaseMatchFinder();
+        }
+        break;
+      }
+      #ifdef COMPRESS_MF_MT
+      case NCoderPropID::kMultiThread:
+      {
+        if (prop.vt != VT_BOOL)
+          return E_INVALIDARG;
+        bool newMultiThread = (prop.boolVal == VARIANT_TRUE);
+        if (newMultiThread != _multiThread)
+        {
+          _dictionarySizePrev = (UInt32)-1;
+          ReleaseMatchFinder();
+          _multiThread = newMultiThread;
+        }
+        break;
+      }
+      case NCoderPropID::kNumThreads:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        bool newMultiThread = (prop.ulVal &gt; 1);
+        if (newMultiThread != _multiThread)
+        {
+          _dictionarySizePrev = (UInt32)-1;
+          ReleaseMatchFinder();
+          _multiThread = newMultiThread;
+        }
+        break;
+      }
+      #endif
+      case NCoderPropID::kDictionarySize:
+      {
+        const int kDicLogSizeMaxCompress = 30;
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 dictionarySize = prop.ulVal;
+        if (dictionarySize &lt; UInt32(1 &lt;&lt; kDicLogSizeMin) ||
+            dictionarySize &gt; UInt32(1 &lt;&lt; kDicLogSizeMaxCompress))
+          return E_INVALIDARG;
+        _dictionarySize = dictionarySize;
+        UInt32 dicLogSize;
+        for(dicLogSize = 0; dicLogSize &lt; (UInt32)kDicLogSizeMaxCompress; dicLogSize++)
+          if (dictionarySize &lt;= (UInt32(1) &lt;&lt; dicLogSize))
+            break;
+        _distTableSize = dicLogSize * 2;
+        break;
+      }
+      case NCoderPropID::kPosStateBits:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 value = prop.ulVal;
+        if (value &gt; (UInt32)NLength::kNumPosStatesBitsEncodingMax)
+          return E_INVALIDARG;
+        _posStateBits = value;
+        _posStateMask = (1 &lt;&lt; _posStateBits) - 1;
+        break;
+      }
+      case NCoderPropID::kLitPosBits:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 value = prop.ulVal;
+        if (value &gt; (UInt32)kNumLitPosStatesBitsEncodingMax)
+          return E_INVALIDARG;
+        _numLiteralPosStateBits = value;
+        break;
+      }
+      case NCoderPropID::kLitContextBits:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 value = prop.ulVal;
+        if (value &gt; (UInt32)kNumLitContextBitsMax)
+          return E_INVALIDARG;
+        _numLiteralContextBits = value;
+        break;
+      }
+      case NCoderPropID::kEndMarker:
+      {
+        if (prop.vt != VT_BOOL)
+          return E_INVALIDARG;
+        SetWriteEndMarkerMode(prop.boolVal == VARIANT_TRUE);
+        break;
+      }
+      default:
+        return E_INVALIDARG;
+    }
+  }
+  return S_OK;
+}
+
+STDMETHODIMP CEncoder::WriteCoderProperties(ISequentialOutStream *outStream)
+{ 
+  const UInt32 kPropSize = 5;
+  Byte properties[kPropSize];
+  properties[0] = (_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits;
+  for (int i = 0; i &lt; 4; i++)
+    properties[1 + i] = Byte(_dictionarySize &gt;&gt; (8 * i));
+  return WriteStream(outStream, properties, kPropSize, NULL);
+}
+
+STDMETHODIMP CEncoder::SetOutStream(ISequentialOutStream *outStream)
+{
+  _rangeEncoder.SetStream(outStream);
+  return S_OK;
+}
+
+STDMETHODIMP CEncoder::ReleaseOutStream()
+{
+  _rangeEncoder.ReleaseStream();
+  return S_OK;
+}
+
+HRESULT CEncoder::Init()
+{
+  CBaseState::Init();
+
+  // RINOK(_matchFinder-&gt;Init(inStream));
+  _rangeEncoder.Init();
+
+  for(int i = 0; i &lt; kNumStates; i++)
+  {
+    for (UInt32 j = 0; j &lt;= _posStateMask; j++)
+    {
+      _isMatch[i][j].Init();
+      _isRep0Long[i][j].Init();
+    }
+    _isRep[i].Init();
+    _isRepG0[i].Init();
+    _isRepG1[i].Init();
+    _isRepG2[i].Init();
+  }
+
+  _literalEncoder.Init();
+
+  {
+    for(UInt32 i = 0; i &lt; kNumLenToPosStates; i++)
+      _posSlotEncoder[i].Init();
+  }
+  {
+    for(UInt32 i = 0; i &lt; kNumFullDistances - kEndPosModelIndex; i++)
+      _posEncoders[i].Init();
+  }
+
+  _lenEncoder.Init(1 &lt;&lt; _posStateBits);
+  _repMatchLenEncoder.Init(1 &lt;&lt; _posStateBits);
+
+  _posAlignEncoder.Init();
+
+  _longestMatchWasFound = false;
+  _optimumEndIndex = 0;
+  _optimumCurrentIndex = 0;
+  _additionalOffset = 0;
+
+  return S_OK;
+}
+
+HRESULT CEncoder::MovePos(UInt32 num)
+{
+  if (num == 0)
+    return S_OK;
+  _additionalOffset += num;
+  return _matchFinder-&gt;Skip(num);
+}
+
+UInt32 CEncoder::Backward(UInt32 &amp;backRes, UInt32 cur)
+{
+  _optimumEndIndex = cur;
+  UInt32 posMem = _optimum[cur].PosPrev;
+  UInt32 backMem = _optimum[cur].BackPrev;
+  do
+  {
+    if (_optimum[cur].Prev1IsChar)
+    {
+      _optimum[posMem].MakeAsChar();
+      _optimum[posMem].PosPrev = posMem - 1;
+      if (_optimum[cur].Prev2)
+      {
+        _optimum[posMem - 1].Prev1IsChar = false;
+        _optimum[posMem - 1].PosPrev = _optimum[cur].PosPrev2;
+        _optimum[posMem - 1].BackPrev = _optimum[cur].BackPrev2;
+      }
+    }
+    UInt32 posPrev = posMem;
+    UInt32 backCur = backMem;
+
+    backMem = _optimum[posPrev].BackPrev;
+    posMem = _optimum[posPrev].PosPrev;
+
+    _optimum[posPrev].BackPrev = backCur;
+    _optimum[posPrev].PosPrev = cur;
+    cur = posPrev;
+  }
+  while(cur != 0);
+  backRes = _optimum[0].BackPrev;
+  _optimumCurrentIndex  = _optimum[0].PosPrev;
+  return _optimumCurrentIndex; 
+}
+
+/*
+Out:
+  (lenRes == 1) &amp;&amp; (backRes == 0xFFFFFFFF) means Literal
+*/
+
+HRESULT CEncoder::GetOptimum(UInt32 position, UInt32 &amp;backRes, UInt32 &amp;lenRes)
+{
+  if(_optimumEndIndex != _optimumCurrentIndex)
+  {
+    const COptimal &amp;optimum = _optimum[_optimumCurrentIndex];
+    lenRes = optimum.PosPrev - _optimumCurrentIndex;
+    backRes = optimum.BackPrev;
+    _optimumCurrentIndex = optimum.PosPrev;
+    return S_OK;
+  }
+  _optimumCurrentIndex = _optimumEndIndex = 0;
+  
+  UInt32 lenMain, numDistancePairs;
+  if (!_longestMatchWasFound)
+  {
+    RINOK(ReadMatchDistances(lenMain, numDistancePairs));
+  }
+  else
+  {
+    lenMain = _longestMatchLength;
+    numDistancePairs = _numDistancePairs;
+    _longestMatchWasFound = false;
+  }
+
+  const Byte *data = _matchFinder-&gt;GetPointerToCurrentPos() - 1;
+  UInt32 numAvailableBytes = _matchFinder-&gt;GetNumAvailableBytes() + 1;
+  if (numAvailableBytes &lt; 2)
+  {
+    backRes = (UInt32)(-1);
+    lenRes = 1;
+    return S_OK;
+  }
+  if (numAvailableBytes &gt; kMatchMaxLen)
+    numAvailableBytes = kMatchMaxLen;
+
+  UInt32 reps[kNumRepDistances];
+  UInt32 repLens[kNumRepDistances];
+  UInt32 repMaxIndex = 0;
+  UInt32 i;
+  for(i = 0; i &lt; kNumRepDistances; i++)
+  {
+    reps[i] = _repDistances[i];
+    UInt32 backOffset = reps[i] + 1;
+    if (data[0] != data[(size_t)0 - backOffset] || data[1] != data[(size_t)1 - backOffset])
+    {
+      repLens[i] = 0;
+      continue;
+    }
+    UInt32 lenTest;
+    for (lenTest = 2; lenTest &lt; numAvailableBytes &amp;&amp; 
+        data[lenTest] == data[(size_t)lenTest - backOffset]; lenTest++);
+    repLens[i] = lenTest;
+    if (lenTest &gt; repLens[repMaxIndex])
+      repMaxIndex = i;
+  }
+  if(repLens[repMaxIndex] &gt;= _numFastBytes)
+  {
+    backRes = repMaxIndex;
+    lenRes = repLens[repMaxIndex];
+    return MovePos(lenRes - 1);
+  }
+
+  UInt32 *matchDistances = _matchDistances + 1;
+  if(lenMain &gt;= _numFastBytes)
+  {
+    backRes = matchDistances[numDistancePairs - 1] + kNumRepDistances; 
+    lenRes = lenMain;
+    return MovePos(lenMain - 1);
+  }
+  Byte currentByte = *data;
+  Byte matchByte = data[(size_t)0 - reps[0] - 1];
+
+  if(lenMain &lt; 2 &amp;&amp; currentByte != matchByte &amp;&amp; repLens[repMaxIndex] &lt; 2)
+  {
+    backRes = (UInt32)-1;
+    lenRes = 1;
+    return S_OK;
+  }
+
+  _optimum[0].State = _state;
+
+  UInt32 posState = (position &amp; _posStateMask);
+
+  _optimum[1].Price = _isMatch[_state.Index][posState].GetPrice0() + 
+      _literalEncoder.GetSubCoder(position, _previousByte)-&gt;GetPrice(!_state.IsCharState(), matchByte, currentByte);
+  _optimum[1].MakeAsChar();
+
+  UInt32 matchPrice = _isMatch[_state.Index][posState].GetPrice1();
+  UInt32 repMatchPrice = matchPrice + _isRep[_state.Index].GetPrice1();
+
+  if(matchByte == currentByte)
+  {
+    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(_state, posState);
+    if(shortRepPrice &lt; _optimum[1].Price)
+    {
+      _optimum[1].Price = shortRepPrice;
+      _optimum[1].MakeAsShortRep();
+    }
+  }
+  UInt32 lenEnd = ((lenMain &gt;= repLens[repMaxIndex]) ? lenMain : repLens[repMaxIndex]);
+
+  if(lenEnd &lt; 2)
+  {
+    backRes = _optimum[1].BackPrev;
+    lenRes = 1;
+    return S_OK;
+  }
+
+  _optimum[1].PosPrev = 0;
+  for (i = 0; i &lt; kNumRepDistances; i++)
+    _optimum[0].Backs[i] = reps[i];
+
+  UInt32 len = lenEnd;
+  do
+    _optimum[len--].Price = kIfinityPrice;
+  while (len &gt;= 2);
+
+  for(i = 0; i &lt; kNumRepDistances; i++)
+  {
+    UInt32 repLen = repLens[i];
+    if (repLen &lt; 2)
+      continue;
+    UInt32 price = repMatchPrice + GetPureRepPrice(i, _state, posState);
+    do
+    {
+      UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2, posState);
+      COptimal &amp;optimum = _optimum[repLen];
+      if (curAndLenPrice &lt; optimum.Price) 
+      {
+        optimum.Price = curAndLenPrice;
+        optimum.PosPrev = 0;
+        optimum.BackPrev = i;
+        optimum.Prev1IsChar = false;
+      }
+    }
+    while(--repLen &gt;= 2);
+  }
+
+  UInt32 normalMatchPrice = matchPrice + _isRep[_state.Index].GetPrice0();
+
+  len = ((repLens[0] &gt;= 2) ? repLens[0] + 1 : 2);
+  if (len &lt;= lenMain)
+  {
+    UInt32 offs = 0;
+    while (len &gt; matchDistances[offs])
+      offs += 2;
+    for(; ; len++)
+    {
+      UInt32 distance = matchDistances[offs + 1];
+      UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance, len, posState);
+      COptimal &amp;optimum = _optimum[len];
+      if (curAndLenPrice &lt; optimum.Price) 
+      {
+        optimum.Price = curAndLenPrice;
+        optimum.PosPrev = 0;
+        optimum.BackPrev = distance + kNumRepDistances;
+        optimum.Prev1IsChar = false;
+      }
+      if (len == matchDistances[offs])
+      {
+        offs += 2;
+        if (offs == numDistancePairs)
+          break;
+      }
+    }
+  }
+
+  UInt32 cur = 0;
+
+  while(true)
+  {
+    cur++;
+    if(cur == lenEnd)
+    {
+      lenRes = Backward(backRes, cur);
+      return S_OK;
+    }
+    UInt32 newLen, numDistancePairs;
+    RINOK(ReadMatchDistances(newLen, numDistancePairs));
+    if(newLen &gt;= _numFastBytes)
+    {
+      _numDistancePairs = numDistancePairs;
+      _longestMatchLength = newLen;
+      _longestMatchWasFound = true;
+      lenRes = Backward(backRes, cur);
+      return S_OK;
+    }
+    position++;
+    COptimal &amp;curOptimum = _optimum[cur];
+    UInt32 posPrev = curOptimum.PosPrev;
+    CState state;
+    if (curOptimum.Prev1IsChar)
+    {
+      posPrev--;
+      if (curOptimum.Prev2)
+      {
+        state = _optimum[curOptimum.PosPrev2].State;
+        if (curOptimum.BackPrev2 &lt; kNumRepDistances)
+          state.UpdateRep();
+        else
+          state.UpdateMatch();
+      }
+      else
+        state = _optimum[posPrev].State;
+      state.UpdateChar();
+    }
+    else
+      state = _optimum[posPrev].State;
+    if (posPrev == cur - 1)
+    {
+      if (curOptimum.IsShortRep())
+        state.UpdateShortRep();
+      else
+        state.UpdateChar();
+    }
+    else
+    {
+      UInt32 pos;
+      if (curOptimum.Prev1IsChar &amp;&amp; curOptimum.Prev2)
+      {
+        posPrev = curOptimum.PosPrev2;
+        pos = curOptimum.BackPrev2;
+        state.UpdateRep();
+      }
+      else
+      {
+        pos = curOptimum.BackPrev;
+        if (pos &lt; kNumRepDistances)
+          state.UpdateRep();
+        else
+          state.UpdateMatch();
+      }
+      const COptimal &amp;prevOptimum = _optimum[posPrev];
+      if (pos &lt; kNumRepDistances)
+      {
+        reps[0] = prevOptimum.Backs[pos];
+    		UInt32 i;
+        for(i = 1; i &lt;= pos; i++)
+          reps[i] = prevOptimum.Backs[i - 1];
+        for(; i &lt; kNumRepDistances; i++)
+          reps[i] = prevOptimum.Backs[i];
+      }
+      else
+      {
+        reps[0] = (pos - kNumRepDistances);
+        for(UInt32 i = 1; i &lt; kNumRepDistances; i++)
+          reps[i] = prevOptimum.Backs[i - 1];
+      }
+    }
+    curOptimum.State = state;
+    for(UInt32 i = 0; i &lt; kNumRepDistances; i++)
+      curOptimum.Backs[i] = reps[i];
+    UInt32 curPrice = curOptimum.Price; 
+    const Byte *data = _matchFinder-&gt;GetPointerToCurrentPos() - 1;
+    const Byte currentByte = *data;
+    const Byte matchByte = data[(size_t)0 - reps[0] - 1];
+
+    UInt32 posState = (position &amp; _posStateMask);
+
+    UInt32 curAnd1Price = curPrice +
+        _isMatch[state.Index][posState].GetPrice0() +
+        _literalEncoder.GetSubCoder(position, data[(size_t)0 - 1])-&gt;GetPrice(!state.IsCharState(), matchByte, currentByte);
+
+    COptimal &amp;nextOptimum = _optimum[cur + 1];
+
+    bool nextIsChar = false;
+    if (curAnd1Price &lt; nextOptimum.Price) 
+    {
+      nextOptimum.Price = curAnd1Price;
+      nextOptimum.PosPrev = cur;
+      nextOptimum.MakeAsChar();
+      nextIsChar = true;
+    }
+
+    UInt32 matchPrice = curPrice + _isMatch[state.Index][posState].GetPrice1();
+    UInt32 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();
+    
+    if(matchByte == currentByte &amp;&amp;
+        !(nextOptimum.PosPrev &lt; cur &amp;&amp; nextOptimum.BackPrev == 0))
+    {
+      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);
+      if(shortRepPrice &lt;= nextOptimum.Price)
+      {
+        nextOptimum.Price = shortRepPrice;
+        nextOptimum.PosPrev = cur;
+        nextOptimum.MakeAsShortRep();
+        nextIsChar = true;
+      }
+    }
+    /*
+    if(newLen == 2 &amp;&amp; matchDistances[2] &gt;= kDistLimit2) // test it maybe set 2000 ?
+      continue;
+    */
+
+    UInt32 numAvailableBytesFull = _matchFinder-&gt;GetNumAvailableBytes() + 1;
+    numAvailableBytesFull = MyMin(kNumOpts - 1 - cur, numAvailableBytesFull);
+    UInt32 numAvailableBytes = numAvailableBytesFull;
+
+    if (numAvailableBytes &lt; 2)
+      continue;
+    if (numAvailableBytes &gt; _numFastBytes)
+      numAvailableBytes = _numFastBytes;
+    if (!nextIsChar &amp;&amp; matchByte != currentByte) // speed optimization
+    {
+      // try Literal + rep0
+      UInt32 backOffset = reps[0] + 1;
+      UInt32 limit = MyMin(numAvailableBytesFull, _numFastBytes + 1);
+      UInt32 temp;
+      for (temp = 1; temp &lt; limit &amp;&amp; 
+          data[temp] == data[(size_t)temp - backOffset]; temp++);
+      UInt32 lenTest2 = temp - 1;
+      if (lenTest2 &gt;= 2)
+      {
+        CState state2 = state;
+        state2.UpdateChar();
+        UInt32 posStateNext = (position + 1) &amp; _posStateMask;
+        UInt32 nextRepMatchPrice = curAnd1Price + 
+            _isMatch[state2.Index][posStateNext].GetPrice1() +
+            _isRep[state2.Index].GetPrice1();
+        // for (; lenTest2 &gt;= 2; lenTest2--)
+        {
+          UInt32 offset = cur + 1 + lenTest2;
+          while(lenEnd &lt; offset)
+            _optimum[++lenEnd].Price = kIfinityPrice;
+          UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(
+              0, lenTest2, state2, posStateNext);
+          COptimal &amp;optimum = _optimum[offset];
+          if (curAndLenPrice &lt; optimum.Price) 
+          {
+            optimum.Price = curAndLenPrice;
+            optimum.PosPrev = cur + 1;
+            optimum.BackPrev = 0;
+            optimum.Prev1IsChar = true;
+            optimum.Prev2 = false;
+          }
+        }
+      }
+    }
+    
+    UInt32 startLen = 2; // speed optimization 
+    for(UInt32 repIndex = 0; repIndex &lt; kNumRepDistances; repIndex++)
+    {
+      // UInt32 repLen = _matchFinder-&gt;GetMatchLen(0 - 1, reps[repIndex], newLen); // test it;
+      UInt32 backOffset = reps[repIndex] + 1;
+      if (data[0] != data[(size_t)0 - backOffset] ||
+          data[1] != data[(size_t)1 - backOffset])
+        continue;
+      UInt32 lenTest;
+      for (lenTest = 2; lenTest &lt; numAvailableBytes &amp;&amp; 
+          data[lenTest] == data[(size_t)lenTest - backOffset]; lenTest++);
+      while(lenEnd &lt; cur + lenTest)
+        _optimum[++lenEnd].Price = kIfinityPrice;
+      UInt32 lenTestTemp = lenTest;
+      UInt32 price = repMatchPrice + GetPureRepPrice(repIndex, state, posState);
+      do
+      {
+        UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(lenTest - 2, posState);
+        COptimal &amp;optimum = _optimum[cur + lenTest];
+        if (curAndLenPrice &lt; optimum.Price) 
+        {
+          optimum.Price = curAndLenPrice;
+          optimum.PosPrev = cur;
+          optimum.BackPrev = repIndex;
+          optimum.Prev1IsChar = false;
+        }
+      }
+      while(--lenTest &gt;= 2);
+      lenTest = lenTestTemp;
+      
+      if (repIndex == 0)
+        startLen = lenTest + 1;
+        
+      // if (_maxMode)
+        {
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = MyMin(numAvailableBytesFull, lenTest2 + _numFastBytes);
+          for (; lenTest2 &lt; limit &amp;&amp; 
+              data[lenTest2] == data[(size_t)lenTest2 - backOffset]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 &gt;= 2)
+          {
+            CState state2 = state;
+            state2.UpdateRep();
+            UInt32 posStateNext = (position + lenTest) &amp; _posStateMask;
+            UInt32 curAndLenCharPrice = 
+                price + _repMatchLenEncoder.GetPrice(lenTest - 2, posState) + 
+                _isMatch[state2.Index][posStateNext].GetPrice0() +
+                _literalEncoder.GetSubCoder(position + lenTest, data[(size_t)lenTest - 1])-&gt;GetPrice(
+                true, data[(size_t)lenTest - backOffset], data[lenTest]);
+            state2.UpdateChar();
+            posStateNext = (position + lenTest + 1) &amp; _posStateMask;
+            UInt32 nextRepMatchPrice = curAndLenCharPrice + 
+                _isMatch[state2.Index][posStateNext].GetPrice1() +
+                _isRep[state2.Index].GetPrice1();
+            
+            // for(; lenTest2 &gt;= 2; lenTest2--)
+            {
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              while(lenEnd &lt; offset)
+                _optimum[++lenEnd].Price = kIfinityPrice;
+              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(
+                  0, lenTest2, state2, posStateNext);
+              COptimal &amp;optimum = _optimum[offset];
+              if (curAndLenPrice &lt; optimum.Price) 
+              {
+                optimum.Price = curAndLenPrice;
+                optimum.PosPrev = cur + lenTest + 1;
+                optimum.BackPrev = 0;
+                optimum.Prev1IsChar = true;
+                optimum.Prev2 = true;
+                optimum.PosPrev2 = cur;
+                optimum.BackPrev2 = repIndex;
+              }
+            }
+          }
+        }
+      }
+    
+    //    for(UInt32 lenTest = 2; lenTest &lt;= newLen; lenTest++)
+    if (newLen &gt; numAvailableBytes)
+    {
+      newLen = numAvailableBytes;
+      for (numDistancePairs = 0; newLen &gt; matchDistances[numDistancePairs]; numDistancePairs += 2);
+      matchDistances[numDistancePairs] = newLen;
+      numDistancePairs += 2;
+    }
+    if (newLen &gt;= startLen)
+    {
+      UInt32 normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();
+      while(lenEnd &lt; cur + newLen)
+        _optimum[++lenEnd].Price = kIfinityPrice;
+
+      UInt32 offs = 0;
+      while(startLen &gt; matchDistances[offs])
+        offs += 2;
+      UInt32 curBack = matchDistances[offs + 1];
+      UInt32 posSlot = GetPosSlot2(curBack);
+      for(UInt32 lenTest = /*2*/ startLen; ; lenTest++)
+      {
+        UInt32 curAndLenPrice = normalMatchPrice;
+        UInt32 lenToPosState = GetLenToPosState(lenTest);
+        if (curBack &lt; kNumFullDistances)
+          curAndLenPrice += _distancesPrices[lenToPosState][curBack];
+        else
+          curAndLenPrice += _posSlotPrices[lenToPosState][posSlot] + _alignPrices[curBack &amp; kAlignMask];
+  
+        curAndLenPrice += _lenEncoder.GetPrice(lenTest - kMatchMinLen, posState);
+        
+        COptimal &amp;optimum = _optimum[cur + lenTest];
+        if (curAndLenPrice &lt; optimum.Price) 
+        {
+          optimum.Price = curAndLenPrice;
+          optimum.PosPrev = cur;
+          optimum.BackPrev = curBack + kNumRepDistances;
+          optimum.Prev1IsChar = false;
+        }
+
+        if (/*_maxMode &amp;&amp; */lenTest == matchDistances[offs])
+        {
+          // Try Match + Literal + Rep0
+          UInt32 backOffset = curBack + 1;
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = MyMin(numAvailableBytesFull, lenTest2 + _numFastBytes);
+          for (; lenTest2 &lt; limit &amp;&amp; 
+              data[lenTest2] == data[(size_t)lenTest2 - backOffset]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 &gt;= 2)
+          {
+            CState state2 = state;
+            state2.UpdateMatch();
+            UInt32 posStateNext = (position + lenTest) &amp; _posStateMask;
+            UInt32 curAndLenCharPrice = curAndLenPrice + 
+                _isMatch[state2.Index][posStateNext].GetPrice0() +
+                _literalEncoder.GetSubCoder(position + lenTest, data[(size_t)lenTest - 1])-&gt;GetPrice( 
+                true, data[(size_t)lenTest - backOffset], data[lenTest]);
+            state2.UpdateChar();
+            posStateNext = (posStateNext + 1) &amp; _posStateMask;
+            UInt32 nextRepMatchPrice = curAndLenCharPrice + 
+                _isMatch[state2.Index][posStateNext].GetPrice1() +
+                _isRep[state2.Index].GetPrice1();
+            
+            // for(; lenTest2 &gt;= 2; lenTest2--)
+            {
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              while(lenEnd &lt; offset)
+                _optimum[++lenEnd].Price = kIfinityPrice;
+              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
+              COptimal &amp;optimum = _optimum[offset];
+              if (curAndLenPrice &lt; optimum.Price) 
+              {
+                optimum.Price = curAndLenPrice;
+                optimum.PosPrev = cur + lenTest + 1;
+                optimum.BackPrev = 0;
+                optimum.Prev1IsChar = true;
+                optimum.Prev2 = true;
+                optimum.PosPrev2 = cur;
+                optimum.BackPrev2 = curBack + kNumRepDistances;
+              }
+            }
+          }
+          offs += 2;
+          if (offs == numDistancePairs)
+            break;
+          curBack = matchDistances[offs + 1];
+          if (curBack &gt;= kNumFullDistances)
+            posSlot = GetPosSlot2(curBack);
+        }
+      }
+    }
+  }
+}
+
+static inline bool ChangePair(UInt32 smallDist, UInt32 bigDist)
+{
+  return ((bigDist &gt;&gt; 7) &gt; smallDist);
+}
+
+
+HRESULT CEncoder::ReadMatchDistances(UInt32 &amp;lenRes, UInt32 &amp;numDistancePairs)
+{
+  lenRes = 0;
+  RINOK(_matchFinder-&gt;GetMatches(_matchDistances));
+  numDistancePairs = _matchDistances[0];
+  if (numDistancePairs &gt; 0)
+  {
+    lenRes = _matchDistances[1 + numDistancePairs - 2];
+    if (lenRes == _numFastBytes)
+      lenRes += _matchFinder-&gt;GetMatchLen(lenRes - 1, _matchDistances[1 + numDistancePairs - 1], 
+          kMatchMaxLen - lenRes);
+  }
+  _additionalOffset++;
+  return S_OK;
+}
+
+HRESULT CEncoder::GetOptimumFast(UInt32 position, UInt32 &amp;backRes, UInt32 &amp;lenRes)
+{
+  UInt32 lenMain, numDistancePairs;
+  if (!_longestMatchWasFound)
+  {
+    RINOK(ReadMatchDistances(lenMain, numDistancePairs));
+  }
+  else
+  {
+    lenMain = _longestMatchLength;
+    numDistancePairs = _numDistancePairs;
+    _longestMatchWasFound = false;
+  }
+
+  const Byte *data = _matchFinder-&gt;GetPointerToCurrentPos() - 1;
+  UInt32 numAvailableBytes = _matchFinder-&gt;GetNumAvailableBytes() + 1;
+  if (numAvailableBytes &gt; kMatchMaxLen)
+    numAvailableBytes = kMatchMaxLen;
+  if (numAvailableBytes &lt; 2)
+  {
+    backRes = (UInt32)(-1);
+    lenRes = 1;
+    return S_OK;
+  }
+
+  UInt32 repLens[kNumRepDistances];
+  UInt32 repMaxIndex = 0;
+
+  for(UInt32 i = 0; i &lt; kNumRepDistances; i++)
+  {
+    UInt32 backOffset = _repDistances[i] + 1;
+    if (data[0] != data[(size_t)0 - backOffset] || data[1] != data[(size_t)1 - backOffset])
+    {
+      repLens[i] = 0;
+      continue;
+    }
+    UInt32 len;
+    for (len = 2; len &lt; numAvailableBytes &amp;&amp; data[len] == data[(size_t)len - backOffset]; len++);
+    if(len &gt;= _numFastBytes)
+    {
+      backRes = i;
+      lenRes = len;
+      return MovePos(lenRes - 1);
+    }
+    repLens[i] = len;
+    if (len &gt; repLens[repMaxIndex])
+      repMaxIndex = i;
+  }
+  UInt32 *matchDistances = _matchDistances + 1;
+  if(lenMain &gt;= _numFastBytes)
+  {
+    backRes = matchDistances[numDistancePairs - 1] + kNumRepDistances; 
+    lenRes = lenMain;
+    return MovePos(lenMain - 1);
+  }
+
+  UInt32 backMain = 0; // for GCC
+  if (lenMain &gt;= 2)
+  {
+    backMain = matchDistances[numDistancePairs - 1];
+    while (numDistancePairs &gt; 2 &amp;&amp; lenMain == matchDistances[numDistancePairs - 4] + 1)
+    {
+      if (!ChangePair(matchDistances[numDistancePairs - 3], backMain))
+        break;
+      numDistancePairs -= 2;
+      lenMain = matchDistances[numDistancePairs - 2];
+      backMain = matchDistances[numDistancePairs - 1];
+    }
+    if (lenMain == 2 &amp;&amp; backMain &gt;= 0x80)
+      lenMain = 1;
+  }
+
+  if (repLens[repMaxIndex] &gt;= 2)
+  {
+    if (repLens[repMaxIndex] + 1 &gt;= lenMain || 
+        repLens[repMaxIndex] + 2 &gt;= lenMain &amp;&amp; (backMain &gt; (1 &lt;&lt; 9)) ||
+        repLens[repMaxIndex] + 3 &gt;= lenMain &amp;&amp; (backMain &gt; (1 &lt;&lt; 15)))
+    {
+      backRes = repMaxIndex;
+      lenRes = repLens[repMaxIndex];
+      return MovePos(lenRes - 1);
+    }
+  }
+  
+  if (lenMain &gt;= 2 &amp;&amp; numAvailableBytes &gt; 2)
+  {
+    RINOK(ReadMatchDistances(_longestMatchLength, _numDistancePairs));
+    if (_longestMatchLength &gt;= 2)
+    {
+      UInt32 newDistance = matchDistances[_numDistancePairs - 1];
+      if (_longestMatchLength &gt;= lenMain &amp;&amp; newDistance &lt; backMain || 
+          _longestMatchLength == lenMain + 1 &amp;&amp; !ChangePair(backMain, newDistance) ||
+          _longestMatchLength &gt; lenMain + 1 ||
+          _longestMatchLength + 1 &gt;= lenMain &amp;&amp; lenMain &gt;= 3 &amp;&amp; ChangePair(newDistance, backMain))
+      {
+        _longestMatchWasFound = true;
+        backRes = UInt32(-1);
+        lenRes = 1;
+        return S_OK;
+      }
+    }
+    data++;
+    numAvailableBytes--;
+    for(UInt32 i = 0; i &lt; kNumRepDistances; i++)
+    {
+      UInt32 backOffset = _repDistances[i] + 1;
+      if (data[1] != data[(size_t)1 - backOffset] || data[2] != data[(size_t)2 - backOffset])
+      {
+        repLens[i] = 0;
+        continue;
+      }
+      UInt32 len;
+      for (len = 2; len &lt; numAvailableBytes &amp;&amp; data[len] == data[(size_t)len - backOffset]; len++);
+      if (len + 1 &gt;= lenMain)
+      {
+        _longestMatchWasFound = true;
+        backRes = UInt32(-1);
+        lenRes = 1;
+        return S_OK;
+      }
+    }
+    backRes = backMain + kNumRepDistances; 
+    lenRes = lenMain;
+    return MovePos(lenMain - 2);
+  }
+  backRes = UInt32(-1);
+  lenRes = 1;
+  return S_OK;
+}
+
+HRESULT CEncoder::Flush(UInt32 nowPos)
+{
+  ReleaseMFStream();
+  WriteEndMarker(nowPos &amp; _posStateMask);
+  _rangeEncoder.FlushData();
+  return _rangeEncoder.FlushStream();
+}
+
+void CEncoder::WriteEndMarker(UInt32 posState)
+{
+  // This function for writing End Mark for stream version of LZMA. 
+  // In current version this feature is not used.
+  if (!_writeEndMark)
+    return;
+
+  _isMatch[_state.Index][posState].Encode(&amp;_rangeEncoder, 1);
+  _isRep[_state.Index].Encode(&amp;_rangeEncoder, 0);
+  _state.UpdateMatch();
+  UInt32 len = kMatchMinLen; // kMatchMaxLen;
+  _lenEncoder.Encode(&amp;_rangeEncoder, len - kMatchMinLen, posState, !_fastMode);
+  UInt32 posSlot = (1 &lt;&lt; kNumPosSlotBits)  - 1;
+  UInt32 lenToPosState = GetLenToPosState(len);
+  _posSlotEncoder[lenToPosState].Encode(&amp;_rangeEncoder, posSlot);
+  UInt32 footerBits = 30;
+  UInt32 posReduced = (UInt32(1) &lt;&lt; footerBits) - 1;
+  _rangeEncoder.EncodeDirectBits(posReduced &gt;&gt; kNumAlignBits, footerBits - kNumAlignBits);
+  _posAlignEncoder.ReverseEncode(&amp;_rangeEncoder, posReduced &amp; kAlignMask);
+}
+
+HRESULT CEncoder::CodeReal(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress)
+{
+  _needReleaseMFStream = false;
+  CCoderReleaser coderReleaser(this);
+  RINOK(SetStreams(inStream, outStream, inSize, outSize));
+  while(true)
+  {
+    UInt64 processedInSize;
+    UInt64 processedOutSize;
+    Int32 finished;
+    RINOK(CodeOneBlock(&amp;processedInSize, &amp;processedOutSize, &amp;finished));
+    if (finished != 0)
+      return S_OK;
+    if (progress != 0)
+    {
+      RINOK(progress-&gt;SetRatioInfo(&amp;processedInSize, &amp;processedOutSize));
+    }
+  }
+}
+
+HRESULT CEncoder::SetStreams(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, const UInt64 *outSize)
+{
+  _inStream = inStream;
+  _finished = false;
+  RINOK(Create());
+  RINOK(SetOutStream(outStream));
+  RINOK(Init());
+  
+  // CCoderReleaser releaser(this);
+
+  /*
+  if (_matchFinder-&gt;GetNumAvailableBytes() == 0)
+    return Flush();
+  */
+
+  if (!_fastMode)
+  {
+    FillDistancesPrices();
+    FillAlignPrices();
+  }
+
+  _lenEncoder.SetTableSize(_numFastBytes + 1 - kMatchMinLen);
+  _lenEncoder.UpdateTables(1 &lt;&lt; _posStateBits);
+  _repMatchLenEncoder.SetTableSize(_numFastBytes + 1 - kMatchMinLen);
+  _repMatchLenEncoder.UpdateTables(1 &lt;&lt; _posStateBits);
+
+  nowPos64 = 0;
+  return S_OK;
+}
+
+HRESULT CEncoder::CodeOneBlock(UInt64 *inSize, UInt64 *outSize, Int32 *finished)
+{
+  if (_inStream != 0)
+  {
+    RINOK(_matchFinder-&gt;SetStream(_inStream));
+    RINOK(_matchFinder-&gt;Init());
+    _needReleaseMFStream = true;
+    _inStream = 0;
+  }
+
+
+  *finished = 1;
+  if (_finished)
+    return S_OK;
+  _finished = true;
+
+  if (nowPos64 == 0)
+  {
+    if (_matchFinder-&gt;GetNumAvailableBytes() == 0)
+      return Flush(UInt32(nowPos64));
+    UInt32 len, numDistancePairs;
+    RINOK(ReadMatchDistances(len, numDistancePairs));
+    UInt32 posState = UInt32(nowPos64) &amp; _posStateMask;
+    _isMatch[_state.Index][posState].Encode(&amp;_rangeEncoder, 0);
+    _state.UpdateChar();
+    Byte curByte = _matchFinder-&gt;GetIndexByte(0 - _additionalOffset);
+    _literalEncoder.GetSubCoder(UInt32(nowPos64), _previousByte)-&gt;Encode(&amp;_rangeEncoder, curByte);
+    _previousByte = curByte;
+    _additionalOffset--;
+    nowPos64++;
+  }
+
+  UInt32 nowPos32 = (UInt32)nowPos64;
+  UInt32 progressPosValuePrev = nowPos32;
+
+  if (_matchFinder-&gt;GetNumAvailableBytes() == 0)
+    return Flush(nowPos32);
+
+  while(true)
+  {
+    #ifdef _NO_EXCEPTIONS
+    if (_rangeEncoder.Stream.ErrorCode != S_OK)
+      return _rangeEncoder.Stream.ErrorCode;
+    #endif
+    UInt32 pos, len;
+    HRESULT result;
+    if (_fastMode)
+      result = GetOptimumFast(nowPos32, pos, len);
+    else
+      result = GetOptimum(nowPos32, pos, len);
+    RINOK(result);
+
+    UInt32 posState = nowPos32 &amp; _posStateMask;
+    if(len == 1 &amp;&amp; pos == 0xFFFFFFFF)
+    {
+      _isMatch[_state.Index][posState].Encode(&amp;_rangeEncoder, 0);
+      Byte curByte = _matchFinder-&gt;GetIndexByte(0 - _additionalOffset);
+      CLiteralEncoder2 *subCoder = _literalEncoder.GetSubCoder(nowPos32, _previousByte);
+      if(_state.IsCharState())
+        subCoder-&gt;Encode(&amp;_rangeEncoder, curByte);
+      else
+      {
+        Byte matchByte = _matchFinder-&gt;GetIndexByte(0 - _repDistances[0] - 1 - _additionalOffset);
+        subCoder-&gt;EncodeMatched(&amp;_rangeEncoder, matchByte, curByte);
+      }
+      _state.UpdateChar();
+      _previousByte = curByte;
+    }
+    else
+    {
+      _isMatch[_state.Index][posState].Encode(&amp;_rangeEncoder, 1);
+      if(pos &lt; kNumRepDistances)
+      {
+        _isRep[_state.Index].Encode(&amp;_rangeEncoder, 1);
+        if(pos == 0)
+        {
+          _isRepG0[_state.Index].Encode(&amp;_rangeEncoder, 0);
+          _isRep0Long[_state.Index][posState].Encode(&amp;_rangeEncoder, ((len == 1) ? 0 : 1));
+        }
+        else
+        {
+          UInt32 distance = _repDistances[pos];
+          _isRepG0[_state.Index].Encode(&amp;_rangeEncoder, 1);
+          if (pos == 1)
+            _isRepG1[_state.Index].Encode(&amp;_rangeEncoder, 0);
+          else
+          {
+            _isRepG1[_state.Index].Encode(&amp;_rangeEncoder, 1);
+            _isRepG2[_state.Index].Encode(&amp;_rangeEncoder, pos - 2);
+            if (pos == 3)
+              _repDistances[3] = _repDistances[2];
+            _repDistances[2] = _repDistances[1];
+          }
+          _repDistances[1] = _repDistances[0];
+          _repDistances[0] = distance;
+        }
+        if (len == 1)
+          _state.UpdateShortRep();
+        else
+        {
+          _repMatchLenEncoder.Encode(&amp;_rangeEncoder, len - kMatchMinLen, posState, !_fastMode);
+          _state.UpdateRep();
+        }
+      }
+      else
+      {
+        _isRep[_state.Index].Encode(&amp;_rangeEncoder, 0);
+        _state.UpdateMatch();
+        _lenEncoder.Encode(&amp;_rangeEncoder, len - kMatchMinLen, posState, !_fastMode);
+        pos -= kNumRepDistances;
+        UInt32 posSlot = GetPosSlot(pos);
+        _posSlotEncoder[GetLenToPosState(len)].Encode(&amp;_rangeEncoder, posSlot);
+        
+        if (posSlot &gt;= kStartPosModelIndex)
+        {
+          UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
+          UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+          UInt32 posReduced = pos - base;
+
+          if (posSlot &lt; kEndPosModelIndex)
+            NRangeCoder::ReverseBitTreeEncode(_posEncoders + base - posSlot - 1, 
+                &amp;_rangeEncoder, footerBits, posReduced);
+          else
+          {
+            _rangeEncoder.EncodeDirectBits(posReduced &gt;&gt; kNumAlignBits, footerBits - kNumAlignBits);
+            _posAlignEncoder.ReverseEncode(&amp;_rangeEncoder, posReduced &amp; kAlignMask);
+            _alignPriceCount++;
+          }
+        }
+        _repDistances[3] = _repDistances[2];
+        _repDistances[2] = _repDistances[1];
+        _repDistances[1] = _repDistances[0];
+        _repDistances[0] = pos;
+        _matchPriceCount++;
+      }
+      _previousByte = _matchFinder-&gt;GetIndexByte(len - 1 - _additionalOffset);
+    }
+    _additionalOffset -= len;
+    nowPos32 += len;
+    if (_additionalOffset == 0)
+    {
+      if (!_fastMode)
+      {
+        if (_matchPriceCount &gt;= (1 &lt;&lt; 7))
+          FillDistancesPrices();
+        if (_alignPriceCount &gt;= kAlignTableSize)
+          FillAlignPrices();
+      }
+      if (_matchFinder-&gt;GetNumAvailableBytes() == 0)
+        return Flush(nowPos32);
+      if (nowPos32 - progressPosValuePrev &gt;= (1 &lt;&lt; 14))
+      {
+        nowPos64 += nowPos32 - progressPosValuePrev;
+        *inSize = nowPos64;
+        *outSize = _rangeEncoder.GetProcessedSize();
+        _finished = false;
+        *finished = 0;
+        return S_OK;
+      }
+    }
+  }
+}
+
+STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream,
+    ISequentialOutStream *outStream, const UInt64 *inSize, const UInt64 *outSize,
+    ICompressProgressInfo *progress)
+{
+  #ifndef _NO_EXCEPTIONS
+  try 
+  { 
+  #endif
+    return CodeReal(inStream, outStream, inSize, outSize, progress); 
+  #ifndef _NO_EXCEPTIONS
+  }
+  catch(const COutBufferException &amp;e) { return e.ErrorCode; }
+  catch(...) { return E_FAIL; }
+  #endif
+}
+  
+void CEncoder::FillDistancesPrices()
+{
+  UInt32 tempPrices[kNumFullDistances];
+  for (UInt32 i = kStartPosModelIndex; i &lt; kNumFullDistances; i++)
+  { 
+    UInt32 posSlot = GetPosSlot(i);
+    UInt32 footerBits = ((posSlot &gt;&gt; 1) - 1);
+    UInt32 base = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+    tempPrices[i] = NRangeCoder::ReverseBitTreeGetPrice(_posEncoders + 
+      base - posSlot - 1, footerBits, i - base);
+  }
+
+  for (UInt32 lenToPosState = 0; lenToPosState &lt; kNumLenToPosStates; lenToPosState++)
+  {
+	  UInt32 posSlot;
+    NRangeCoder::CBitTreeEncoder&lt;kNumMoveBits, kNumPosSlotBits&gt; &amp;encoder = _posSlotEncoder[lenToPosState];
+    UInt32 *posSlotPrices = _posSlotPrices[lenToPosState];
+    for (posSlot = 0; posSlot &lt; _distTableSize; posSlot++)
+      posSlotPrices[posSlot] = encoder.GetPrice(posSlot);
+    for (posSlot = kEndPosModelIndex; posSlot &lt; _distTableSize; posSlot++)
+      posSlotPrices[posSlot] += ((((posSlot &gt;&gt; 1) - 1) - kNumAlignBits) &lt;&lt; NRangeCoder::kNumBitPriceShiftBits);
+
+    UInt32 *distancesPrices = _distancesPrices[lenToPosState];
+	  UInt32 i;
+    for (i = 0; i &lt; kStartPosModelIndex; i++)
+      distancesPrices[i] = posSlotPrices[i];
+    for (; i &lt; kNumFullDistances; i++)
+      distancesPrices[i] = posSlotPrices[GetPosSlot(i)] + tempPrices[i];
+  }
+  _matchPriceCount = 0;
+}
+
+void CEncoder::FillAlignPrices()
+{
+  for (UInt32 i = 0; i &lt; kAlignTableSize; i++)
+    _alignPrices[i] = _posAlignEncoder.ReverseGetPrice(i);
+  _alignPriceCount = 0;
+}
+
+}}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,411 @@
+// LZMA/Encoder.h
+
+#ifndef __LZMA_ENCODER_H
+#define __LZMA_ENCODER_H
+
+#include &quot;../../../Common/MyCom.h&quot;
+#include &quot;../../../Common/Alloc.h&quot;
+#include &quot;../../ICoder.h&quot;
+#include &quot;../LZ/IMatchFinder.h&quot;
+#include &quot;../RangeCoder/RangeCoderBitTree.h&quot;
+
+#include &quot;LZMA.h&quot;
+
+namespace NCompress {
+namespace NLZMA {
+
+typedef NRangeCoder::CBitEncoder&lt;kNumMoveBits&gt; CMyBitEncoder;
+
+class CBaseState
+{
+protected:
+  CState _state;
+  Byte _previousByte;
+  UInt32 _repDistances[kNumRepDistances];
+  void Init()
+  {
+    _state.Init();
+    _previousByte = 0;
+    for(UInt32 i = 0 ; i &lt; kNumRepDistances; i++)
+      _repDistances[i] = 0;
+  }
+};
+
+struct COptimal
+{
+  CState State;
+
+  bool Prev1IsChar;
+  bool Prev2;
+
+  UInt32 PosPrev2;
+  UInt32 BackPrev2;     
+
+  UInt32 Price;    
+  UInt32 PosPrev;         // posNext;
+  UInt32 BackPrev;     
+  UInt32 Backs[kNumRepDistances];
+  void MakeAsChar() { BackPrev = UInt32(-1); Prev1IsChar = false; }
+  void MakeAsShortRep() { BackPrev = 0; ; Prev1IsChar = false; }
+  bool IsShortRep() { return (BackPrev == 0); }
+};
+
+
+extern Byte g_FastPos[1 &lt;&lt; 11];
+inline UInt32 GetPosSlot(UInt32 pos)
+{
+  if (pos &lt; (1 &lt;&lt; 11))
+    return g_FastPos[pos];
+  if (pos &lt; (1 &lt;&lt; 21))
+    return g_FastPos[pos &gt;&gt; 10] + 20;
+  return g_FastPos[pos &gt;&gt; 20] + 40;
+}
+
+inline UInt32 GetPosSlot2(UInt32 pos)
+{
+  if (pos &lt; (1 &lt;&lt; 17))
+    return g_FastPos[pos &gt;&gt; 6] + 12;
+  if (pos &lt; (1 &lt;&lt; 27))
+    return g_FastPos[pos &gt;&gt; 16] + 32;
+  return g_FastPos[pos &gt;&gt; 26] + 52;
+}
+
+const UInt32 kIfinityPrice = 0xFFFFFFF;
+
+const UInt32 kNumOpts = 1 &lt;&lt; 12;
+
+
+class CLiteralEncoder2
+{
+  CMyBitEncoder _encoders[0x300];
+public:
+  void Init()
+  {
+    for (int i = 0; i &lt; 0x300; i++)
+      _encoders[i].Init();
+  }
+  void Encode(NRangeCoder::CEncoder *rangeEncoder, Byte symbol);
+  void EncodeMatched(NRangeCoder::CEncoder *rangeEncoder, Byte matchByte, Byte symbol);
+  UInt32 GetPrice(bool matchMode, Byte matchByte, Byte symbol) const;
+};
+
+class CLiteralEncoder
+{
+  CLiteralEncoder2 *_coders;
+  int _numPrevBits;
+  int _numPosBits;
+  UInt32 _posMask;
+public:
+  CLiteralEncoder(): _coders(0) {}
+  ~CLiteralEncoder()  { Free(); }
+  void Free()
+  { 
+    MyFree(_coders);
+    _coders = 0;
+  }
+  bool Create(int numPosBits, int numPrevBits)
+  {
+    if (_coders == 0 || (numPosBits + numPrevBits) != (_numPrevBits + _numPosBits))
+    {
+      Free();
+      UInt32 numStates = 1 &lt;&lt; (numPosBits + numPrevBits);
+      _coders = (CLiteralEncoder2 *)MyAlloc(numStates * sizeof(CLiteralEncoder2));
+    }
+    _numPosBits = numPosBits;
+    _posMask = (1 &lt;&lt; numPosBits) - 1;
+    _numPrevBits = numPrevBits;
+    return (_coders != 0);
+  }
+  void Init()
+  {
+    UInt32 numStates = 1 &lt;&lt; (_numPrevBits + _numPosBits);
+    for (UInt32 i = 0; i &lt; numStates; i++)
+      _coders[i].Init();
+  }
+  CLiteralEncoder2 *GetSubCoder(UInt32 pos, Byte prevByte)
+    { return &amp;_coders[((pos &amp; _posMask) &lt;&lt; _numPrevBits) + (prevByte &gt;&gt; (8 - _numPrevBits))]; }
+};
+
+namespace NLength {
+
+class CEncoder
+{
+  CMyBitEncoder _choice;
+  CMyBitEncoder _choice2;
+  NRangeCoder::CBitTreeEncoder&lt;kNumMoveBits, kNumLowBits&gt; _lowCoder[kNumPosStatesEncodingMax];
+  NRangeCoder::CBitTreeEncoder&lt;kNumMoveBits, kNumMidBits&gt; _midCoder[kNumPosStatesEncodingMax];
+  NRangeCoder::CBitTreeEncoder&lt;kNumMoveBits, kNumHighBits&gt; _highCoder;
+public:
+  void Init(UInt32 numPosStates);
+  void Encode(NRangeCoder::CEncoder *rangeEncoder, UInt32 symbol, UInt32 posState);
+  void SetPrices(UInt32 posState, UInt32 numSymbols, UInt32 *prices) const;
+};
+
+const UInt32 kNumSpecSymbols = kNumLowSymbols + kNumMidSymbols;
+
+class CPriceTableEncoder: public CEncoder
+{
+  UInt32 _prices[kNumPosStatesEncodingMax][kNumSymbolsTotal];
+  UInt32 _tableSize;
+  UInt32 _counters[kNumPosStatesEncodingMax];
+public:
+  void SetTableSize(UInt32 tableSize) { _tableSize = tableSize;  }
+  UInt32 GetPrice(UInt32 symbol, UInt32 posState) const { return _prices[posState][symbol]; }
+  void UpdateTable(UInt32 posState)
+  {
+    SetPrices(posState, _tableSize, _prices[posState]);
+    _counters[posState] = _tableSize;
+  }
+  void UpdateTables(UInt32 numPosStates)
+  {
+    for (UInt32 posState = 0; posState &lt; numPosStates; posState++)
+      UpdateTable(posState);
+  }
+  void Encode(NRangeCoder::CEncoder *rangeEncoder, UInt32 symbol, UInt32 posState, bool updatePrice)
+  {
+    CEncoder::Encode(rangeEncoder, symbol, posState);
+    if (updatePrice)
+      if (--_counters[posState] == 0)
+        UpdateTable(posState);
+  }
+};
+
+}
+
+class CEncoder : 
+  public ICompressCoder,
+  public ICompressSetOutStream,
+  public ICompressSetCoderProperties,
+  public ICompressWriteCoderProperties,
+  public CBaseState,
+  public CMyUnknownImp
+{
+  COptimal _optimum[kNumOpts];
+  CMyComPtr&lt;IMatchFinder&gt; _matchFinder; // test it
+  NRangeCoder::CEncoder _rangeEncoder;
+
+  CMyBitEncoder _isMatch[kNumStates][NLength::kNumPosStatesEncodingMax];
+  CMyBitEncoder _isRep[kNumStates];
+  CMyBitEncoder _isRepG0[kNumStates];
+  CMyBitEncoder _isRepG1[kNumStates];
+  CMyBitEncoder _isRepG2[kNumStates];
+  CMyBitEncoder _isRep0Long[kNumStates][NLength::kNumPosStatesEncodingMax];
+
+  NRangeCoder::CBitTreeEncoder&lt;kNumMoveBits, kNumPosSlotBits&gt; _posSlotEncoder[kNumLenToPosStates];
+
+  CMyBitEncoder _posEncoders[kNumFullDistances - kEndPosModelIndex];
+  NRangeCoder::CBitTreeEncoder&lt;kNumMoveBits, kNumAlignBits&gt; _posAlignEncoder;
+  
+  NLength::CPriceTableEncoder _lenEncoder;
+  NLength::CPriceTableEncoder _repMatchLenEncoder;
+
+  CLiteralEncoder _literalEncoder;
+
+  UInt32 _matchDistances[kMatchMaxLen * 2 + 2 + 1];
+
+  bool _fastMode;
+  // bool _maxMode;
+  UInt32 _numFastBytes;
+  UInt32 _longestMatchLength;    
+  UInt32 _numDistancePairs;
+
+  UInt32 _additionalOffset;
+
+  UInt32 _optimumEndIndex;
+  UInt32 _optimumCurrentIndex;
+
+  bool _longestMatchWasFound;
+
+  UInt32 _posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
+  
+  UInt32 _distancesPrices[kNumLenToPosStates][kNumFullDistances];
+
+  UInt32 _alignPrices[kAlignTableSize];
+  UInt32 _alignPriceCount;
+
+  UInt32 _distTableSize;
+
+  UInt32 _posStateBits;
+  UInt32 _posStateMask;
+  UInt32 _numLiteralPosStateBits;
+  UInt32 _numLiteralContextBits;
+
+  UInt32 _dictionarySize;
+
+  UInt32 _dictionarySizePrev;
+  UInt32 _numFastBytesPrev;
+
+  UInt32 _matchPriceCount;
+  UInt64 nowPos64;
+  bool _finished;
+  ISequentialInStream *_inStream;
+
+  UInt32 _matchFinderCycles;
+  int _matchFinderIndex;
+  #ifdef COMPRESS_MF_MT
+  bool _multiThread;
+  #endif
+
+  bool _writeEndMark;
+
+  bool _needReleaseMFStream;
+
+  IMatchFinderSetNumPasses *setMfPasses;
+
+  void ReleaseMatchFinder()
+  {
+    setMfPasses = 0;
+    _matchFinder.Release();
+  }
+  
+  HRESULT ReadMatchDistances(UInt32 &amp;len, UInt32 &amp;numDistancePairs);
+
+  HRESULT MovePos(UInt32 num);
+  UInt32 GetRepLen1Price(CState state, UInt32 posState) const
+  {
+    return _isRepG0[state.Index].GetPrice0() +
+        _isRep0Long[state.Index][posState].GetPrice0();
+  }
+  
+  UInt32 GetPureRepPrice(UInt32 repIndex, CState state, UInt32 posState) const
+  {
+    UInt32 price;
+    if(repIndex == 0)
+    {
+      price = _isRepG0[state.Index].GetPrice0();
+      price += _isRep0Long[state.Index][posState].GetPrice1();
+    }
+    else
+    {
+      price = _isRepG0[state.Index].GetPrice1();
+      if (repIndex == 1)
+        price += _isRepG1[state.Index].GetPrice0();
+      else
+      {
+        price += _isRepG1[state.Index].GetPrice1();
+        price += _isRepG2[state.Index].GetPrice(repIndex - 2);
+      }
+    }
+    return price;
+  }
+  UInt32 GetRepPrice(UInt32 repIndex, UInt32 len, CState state, UInt32 posState) const
+  {
+    return _repMatchLenEncoder.GetPrice(len - kMatchMinLen, posState) +
+        GetPureRepPrice(repIndex, state, posState);
+  }
+  /*
+  UInt32 GetPosLen2Price(UInt32 pos, UInt32 posState) const
+  {
+    if (pos &gt;= kNumFullDistances)
+      return kIfinityPrice;
+    return _distancesPrices[0][pos] + _lenEncoder.GetPrice(0, posState);
+  }
+  UInt32 GetPosLen3Price(UInt32 pos, UInt32 len, UInt32 posState) const
+  {
+    UInt32 price;
+    UInt32 lenToPosState = GetLenToPosState(len);
+    if (pos &lt; kNumFullDistances)
+      price = _distancesPrices[lenToPosState][pos];
+    else
+      price = _posSlotPrices[lenToPosState][GetPosSlot2(pos)] + 
+          _alignPrices[pos &amp; kAlignMask];
+    return price + _lenEncoder.GetPrice(len - kMatchMinLen, posState);
+  }
+  */
+  UInt32 GetPosLenPrice(UInt32 pos, UInt32 len, UInt32 posState) const
+  {
+    UInt32 price;
+    UInt32 lenToPosState = GetLenToPosState(len);
+    if (pos &lt; kNumFullDistances)
+      price = _distancesPrices[lenToPosState][pos];
+    else
+      price = _posSlotPrices[lenToPosState][GetPosSlot2(pos)] + 
+          _alignPrices[pos &amp; kAlignMask];
+    return price + _lenEncoder.GetPrice(len - kMatchMinLen, posState);
+  }
+
+  UInt32 Backward(UInt32 &amp;backRes, UInt32 cur);
+  HRESULT GetOptimum(UInt32 position, UInt32 &amp;backRes, UInt32 &amp;lenRes);
+  HRESULT GetOptimumFast(UInt32 position, UInt32 &amp;backRes, UInt32 &amp;lenRes);
+
+  void FillDistancesPrices();
+  void FillAlignPrices();
+    
+  void ReleaseMFStream()
+  {
+    if (_matchFinder &amp;&amp; _needReleaseMFStream)
+    {
+      _matchFinder-&gt;ReleaseStream();
+      _needReleaseMFStream = false;
+    }
+  }
+
+  void ReleaseStreams()
+  {
+    ReleaseMFStream();
+    ReleaseOutStream();
+  }
+
+  HRESULT Flush(UInt32 nowPos);
+  class CCoderReleaser
+  {
+    CEncoder *_coder;
+  public:
+    CCoderReleaser(CEncoder *coder): _coder(coder) {}
+    ~CCoderReleaser()
+    {
+      _coder-&gt;ReleaseStreams();
+    }
+  };
+  friend class CCoderReleaser;
+
+  void WriteEndMarker(UInt32 posState);
+
+public:
+  CEncoder();
+  void SetWriteEndMarkerMode(bool writeEndMarker)
+    { _writeEndMark= writeEndMarker; }
+
+  HRESULT Create();
+
+  MY_UNKNOWN_IMP3(
+      ICompressSetOutStream,
+      ICompressSetCoderProperties,
+      ICompressWriteCoderProperties
+      )
+    
+  HRESULT Init();
+  
+  // ICompressCoder interface
+  HRESULT SetStreams(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream,
+      const UInt64 *inSize, const UInt64 *outSize);
+  HRESULT CodeOneBlock(UInt64 *inSize, UInt64 *outSize, Int32 *finished);
+
+  HRESULT CodeReal(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress);
+
+  // ICompressCoder interface
+  STDMETHOD(Code)(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress);
+
+  // ICompressSetCoderProperties2
+  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, 
+      const PROPVARIANT *properties, UInt32 numProperties);
+  
+  // ICompressWriteCoderProperties
+  STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStream);
+
+  STDMETHOD(SetOutStream)(ISequentialOutStream *outStream);
+  STDMETHOD(ReleaseOutStream)();
+
+  virtual ~CEncoder() {}
+};
+
+}}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/LZMAEncoder.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/StdAfx.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/StdAfx.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/StdAfx.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,8 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include &quot;../../../Common/MyWindows.h&quot;
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA/StdAfx.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,475 @@
+# Microsoft Developer Studio Project File - Name=&quot;AloneLZMA&quot; - Package Owner=&lt;4&gt;
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE &quot;Win32 (x86) Console Application&quot; 0x0103
+
+CFG=AloneLZMA - Win32 DebugU
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;AloneLZMA.mak&quot;.
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;AloneLZMA.mak&quot; CFG=&quot;AloneLZMA - Win32 DebugU&quot;
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE &quot;AloneLZMA - Win32 Release&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE &quot;AloneLZMA - Win32 Debug&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE &quot;AloneLZMA - Win32 ReleaseU&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE &quot;AloneLZMA - Win32 DebugU&quot; (based on &quot;Win32 (x86) Console Application&quot;)
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName &quot;&quot;
+# PROP Scc_LocalPath &quot;&quot;
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  &quot;$(CFG)&quot; == &quot;AloneLZMA - Win32 Release&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;Release&quot;
+# PROP BASE Intermediate_Dir &quot;Release&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;Release&quot;
+# PROP Intermediate_Dir &quot;Release&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I &quot;..\..\..\\&quot; /D &quot;NDEBUG&quot; /D &quot;_MBCS&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /Yu&quot;StdAfx.h&quot; /FD /c
+# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;c:\UTIL\lzma.exe&quot; /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;AloneLZMA - Win32 Debug&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;Debug&quot;
+# PROP BASE Intermediate_Dir &quot;Debug&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;Debug&quot;
+# PROP Intermediate_Dir &quot;Debug&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_CONSOLE&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I &quot;..\..\..\\&quot; /D &quot;_DEBUG&quot; /D &quot;_MBCS&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /Yu&quot;StdAfx.h&quot; /FD /GZ /c
+# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;c:\UTIL\lzma.exe&quot; /pdbtype:sept
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;AloneLZMA - Win32 ReleaseU&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;ReleaseU&quot;
+# PROP BASE Intermediate_Dir &quot;ReleaseU&quot;
+# PROP BASE Ignore_Export_Lib 0
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;ReleaseU&quot;
+# PROP Intermediate_Dir &quot;ReleaseU&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /MD /W3 /GX /O2 /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;EXCLUDE_COM&quot; /D &quot;NO_REGISTRY&quot; /D &quot;FORMAT_7Z&quot; /D &quot;FORMAT_BZIP2&quot; /D &quot;FORMAT_ZIP&quot; /D &quot;FORMAT_TAR&quot; /D &quot;FORMAT_GZIP&quot; /D &quot;COMPRESS_LZMA&quot; /D &quot;COMPRESS_BCJ_X86&quot; /D &quot;COMPRESS_BCJ2&quot; /D &quot;COMPRESS_COPY&quot; /D &quot;COMPRESS_MF_PAT&quot; /D &quot;COMPRESS_MF_BT&quot; /D &quot;COMPRESS_PPMD&quot; /D &quot;COMPRESS_DEFLATE&quot; /D &quot;COMPRESS_IMPLODE&quot; /D &quot;COMPRESS_BZIP2&quot; /D &quot;CRYPTO_ZIP&quot; /Yu&quot;StdAfx.h&quot; /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I &quot;..\..\..\\&quot; /D &quot;NDEBUG&quot; /D &quot;UNICODE&quot; /D &quot;_UNICODE&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /Yu&quot;StdAfx.h&quot; /FD /c
+# ADD BASE RSC /l 0x419 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;c:\UTIL\7za2.exe&quot; /opt:NOWIN98
+# SUBTRACT BASE LINK32 /pdb:none
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:&quot;c:\UTIL\lzma.exe&quot; /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;AloneLZMA - Win32 DebugU&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;DebugU&quot;
+# PROP BASE Intermediate_Dir &quot;DebugU&quot;
+# PROP BASE Ignore_Export_Lib 0
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;DebugU&quot;
+# PROP Intermediate_Dir &quot;DebugU&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /D &quot;EXCLUDE_COM&quot; /D &quot;NO_REGISTRY&quot; /D &quot;FORMAT_7Z&quot; /D &quot;FORMAT_BZIP2&quot; /D &quot;FORMAT_ZIP&quot; /D &quot;FORMAT_TAR&quot; /D &quot;FORMAT_GZIP&quot; /D &quot;COMPRESS_LZMA&quot; /D &quot;COMPRESS_BCJ_X86&quot; /D &quot;COMPRESS_BCJ2&quot; /D &quot;COMPRESS_COPY&quot; /D &quot;COMPRESS_MF_PAT&quot; /D &quot;COMPRESS_MF_BT&quot; /D &quot;COMPRESS_PPMD&quot; /D &quot;COMPRESS_DEFLATE&quot; /D &quot;COMPRESS_IMPLODE&quot; /D &quot;COMPRESS_BZIP2&quot; /D &quot;CRYPTO_ZIP&quot; /D &quot;_MBCS&quot; /Yu&quot;StdAfx.h&quot; /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I &quot;..\..\..\\&quot; /D &quot;_DEBUG&quot; /D &quot;_UNICODE&quot; /D &quot;UNICODE&quot; /D &quot;WIN32&quot; /D &quot;_CONSOLE&quot; /Yu&quot;StdAfx.h&quot; /FD /GZ /c
+# ADD BASE RSC /l 0x419 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x419 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;c:\UTIL\7za2.exe&quot; /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:&quot;c:\UTIL\lzma.exe&quot; /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name &quot;AloneLZMA - Win32 Release&quot;
+# Name &quot;AloneLZMA - Win32 Debug&quot;
+# Name &quot;AloneLZMA - Win32 ReleaseU&quot;
+# Name &quot;AloneLZMA - Win32 DebugU&quot;
+# Begin Group &quot;Spec&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=.\StdAfx.cpp
+# ADD CPP /Yc&quot;StdAfx.h&quot;
+# End Source File
+# Begin Source File
+
+SOURCE=.\StdAfx.h
+# End Source File
+# End Group
+# Begin Group &quot;Compress&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Group &quot;LZMA&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\LZMA\LZMA.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA\LZMADecoder.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA\LZMADecoder.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA\LZMAEncoder.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA\LZMAEncoder.h
+# End Source File
+# End Group
+# Begin Group &quot;RangeCoder&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoder.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoderBit.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoderBit.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoderBitTree.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoderOpt.h
+# End Source File
+# End Group
+# Begin Group &quot;LZ&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Group &quot;BT&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree3.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree3Z.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree4.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTreeMain.h
+# End Source File
+# End Group
+# Begin Group &quot;HC&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\LZ\HashChain\HC4.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\HashChain\HCMain.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\LZ\IMatchFinder.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\LZInWindow.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\LZInWindow.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\LZOutWindow.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\LZOutWindow.h
+# End Source File
+# End Group
+# Begin Group &quot;Branch&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\Branch\BranchTypes.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\Branch\BranchX86.c
+# SUBTRACT CPP /YX /Yc /Yu
+# End Source File
+# Begin Source File
+
+SOURCE=..\Branch\BranchX86.h
+# End Source File
+# End Group
+# Begin Group &quot;LZMA_C&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\LZMA_C\LzmaDecode.c
+# SUBTRACT CPP /YX /Yc /Yu
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA_C\LzmaDecode.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA_C\LzmaTypes.h
+# End Source File
+# End Group
+# End Group
+# Begin Group &quot;Windows&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\..\..\Windows\FileIO.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Windows\FileIO.h
+# End Source File
+# End Group
+# Begin Group &quot;Common&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\..\..\Common\Alloc.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Alloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\CommandLineParser.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\CommandLineParser.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\CRC.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\CRC.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Defs.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Windows\Defs.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\MyCom.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\MyWindows.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\NewHandler.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\NewHandler.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\String.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\String.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\StringConvert.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\StringConvert.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\StringToInt.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\StringToInt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Types.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Vector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Vector.h
+# End Source File
+# End Group
+# Begin Group &quot;7zip Common&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=..\..\Common\FileStreams.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\FileStreams.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\InBuffer.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\InBuffer.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\OutBuffer.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\OutBuffer.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\StreamUtils.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\StreamUtils.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\..\ICoder.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaAlone.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaBench.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaBench.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaRam.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaRam.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaRamDecode.c
+# SUBTRACT CPP /YX /Yc /Yu
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaRamDecode.h
+# End Source File
+# End Target
+# End Project


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: &quot;AloneLZMA&quot;=.\AloneLZMA.dsp - Package Owner=&lt;4&gt;
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;4&gt;
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;3&gt;
+{{{
+}}}
+
+###############################################################################
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,524 @@
+// LzmaAlone.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;../../../Common/MyWindows.h&quot;
+#include &quot;../../../Common/MyInitGuid.h&quot;
+
+#include &lt;stdio.h&gt;
+
+#if defined(_WIN32) || defined(OS2) || defined(MSDOS)
+#include &lt;fcntl.h&gt;
+#include &lt;io.h&gt;
+#define MY_SET_BINARY_MODE(file) setmode(fileno(file),O_BINARY)
+#else
+#define MY_SET_BINARY_MODE(file)
+#endif
+
+#include &quot;../../../Common/CommandLineParser.h&quot;
+#include &quot;../../../Common/StringConvert.h&quot;
+#include &quot;../../../Common/StringToInt.h&quot;
+
+#include &quot;../../Common/FileStreams.h&quot;
+#include &quot;../../Common/StreamUtils.h&quot;
+
+#include &quot;../LZMA/LZMADecoder.h&quot;
+#include &quot;../LZMA/LZMAEncoder.h&quot;
+
+#include &quot;LzmaBench.h&quot;
+#include &quot;LzmaRam.h&quot;
+
+extern &quot;C&quot;
+{
+#include &quot;LzmaRamDecode.h&quot;
+}
+
+using namespace NCommandLineParser;
+
+#ifdef _WIN32
+bool g_IsNT = false;
+static inline bool IsItWindowsNT()
+{
+  OSVERSIONINFO versionInfo;
+  versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
+  if (!::GetVersionEx(&amp;versionInfo)) 
+    return false;
+  return (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
+}
+#endif
+
+static const char *kCantAllocate = &quot;Can not allocate memory&quot;;
+static const char *kReadError = &quot;Read error&quot;;
+static const char *kWriteError = &quot;Write error&quot;;
+
+namespace NKey {
+enum Enum
+{
+  kHelp1 = 0,
+  kHelp2,
+  kMode,
+  kDictionary,
+  kFastBytes,
+  kMatchFinderCycles,
+  kLitContext,
+  kLitPos,
+  kPosBits,
+  kMatchFinder,
+  kEOS,
+  kStdIn,
+  kStdOut,
+  kFilter86
+};
+}
+
+static const CSwitchForm kSwitchForms[] = 
+{
+  { L&quot;?&quot;,  NSwitchType::kSimple, false },
+  { L&quot;H&quot;,  NSwitchType::kSimple, false },
+  { L&quot;A&quot;, NSwitchType::kUnLimitedPostString, false, 1 },
+  { L&quot;D&quot;, NSwitchType::kUnLimitedPostString, false, 1 },
+  { L&quot;FB&quot;, NSwitchType::kUnLimitedPostString, false, 1 },
+  { L&quot;MC&quot;, NSwitchType::kUnLimitedPostString, false, 1 },
+  { L&quot;LC&quot;, NSwitchType::kUnLimitedPostString, false, 1 },
+  { L&quot;LP&quot;, NSwitchType::kUnLimitedPostString, false, 1 },
+  { L&quot;PB&quot;, NSwitchType::kUnLimitedPostString, false, 1 },
+  { L&quot;MF&quot;, NSwitchType::kUnLimitedPostString, false, 1 },
+  { L&quot;EOS&quot;, NSwitchType::kSimple, false },
+  { L&quot;SI&quot;,  NSwitchType::kSimple, false },
+  { L&quot;SO&quot;,  NSwitchType::kSimple, false },
+  { L&quot;F86&quot;,  NSwitchType::kSimple, false }
+};
+
+static const int kNumSwitches = sizeof(kSwitchForms) / sizeof(kSwitchForms[0]);
+
+static void PrintHelp()
+{
+  fprintf(stderr, &quot;\nUsage:  LZMA &lt;e|d&gt; inputFile outputFile [&lt;switches&gt;...]\n&quot;
+             &quot;  e: encode file\n&quot;
+             &quot;  d: decode file\n&quot;
+             &quot;  b: Benchmark\n&quot;
+    &quot;&lt;Switches&gt;\n&quot;
+    &quot;  -a{N}:  set compression mode - [0, 1], default: 1 (max)\n&quot;
+    &quot;  -d{N}:  set dictionary - [0,30], default: 23 (8MB)\n&quot;
+    &quot;  -fb{N}: set number of fast bytes - [5, 273], default: 128\n&quot;
+    &quot;  -mc{N}: set number of cycles for match finder\n&quot;
+    &quot;  -lc{N}: set number of literal context bits - [0, 8], default: 3\n&quot;
+    &quot;  -lp{N}: set number of literal pos bits - [0, 4], default: 0\n&quot;
+    &quot;  -pb{N}: set number of pos bits - [0, 4], default: 2\n&quot;
+    &quot;  -mf{MF_ID}: set Match Finder: [bt2, bt3, bt4, hc4], default: bt4\n&quot;
+    &quot;  -eos:   write End Of Stream marker\n&quot;
+    &quot;  -si:    read data from stdin\n&quot;
+    &quot;  -so:    write data to stdout\n&quot;
+    );
+}
+
+static void PrintHelpAndExit(const char *s)
+{
+  fprintf(stderr, &quot;\nError: %s\n\n&quot;, s);
+  PrintHelp();
+  throw -1;
+}
+
+static void IncorrectCommand()
+{
+  PrintHelpAndExit(&quot;Incorrect command&quot;);
+}
+
+static void WriteArgumentsToStringList(int numArguments, const char *arguments[], 
+    UStringVector &amp;strings)
+{
+  for(int i = 1; i &lt; numArguments; i++)
+    strings.Add(MultiByteToUnicodeString(arguments[i]));
+}
+
+static bool GetNumber(const wchar_t *s, UInt32 &amp;value)
+{
+  value = 0;
+  if (MyStringLen(s) == 0)
+    return false;
+  const wchar_t *end;
+  UInt64 res = ConvertStringToUInt64(s, &amp;end);
+  if (*end != L'\0')
+    return false;
+  if (res &gt; 0xFFFFFFFF)
+    return false;
+  value = UInt32(res);
+  return true;
+}
+
+int main2(int n, const char *args[])
+{
+  #ifdef _WIN32
+  g_IsNT = IsItWindowsNT();
+  #endif
+
+  fprintf(stderr, &quot;\nLZMA 4.43 Copyright (c) 1999-2006 Igor Pavlov  2006-06-04\n&quot;);
+
+  if (n == 1)
+  {
+    PrintHelp();
+    return 0;
+  }
+
+  if (sizeof(Byte) != 1 || sizeof(UInt32) &lt; 4 || sizeof(UInt64) &lt; 4)
+  {
+    fprintf(stderr, &quot;Unsupported base types. Edit Common/Types.h and recompile&quot;);
+    return 1;
+  }   
+
+  UStringVector commandStrings;
+  WriteArgumentsToStringList(n, args, commandStrings);
+  CParser parser(kNumSwitches);
+  try
+  {
+    parser.ParseStrings(kSwitchForms, commandStrings);
+  }
+  catch(...) 
+  {
+    IncorrectCommand();
+  }
+
+  if(parser[NKey::kHelp1].ThereIs || parser[NKey::kHelp2].ThereIs)
+  {
+    PrintHelp();
+    return 0;
+  }
+  const UStringVector &amp;nonSwitchStrings = parser.NonSwitchStrings;
+
+  int paramIndex = 0;
+  if (paramIndex &gt;= nonSwitchStrings.Size())
+    IncorrectCommand();
+  const UString &amp;command = nonSwitchStrings[paramIndex++]; 
+
+  bool dictionaryIsDefined = false;
+  UInt32 dictionary = 1 &lt;&lt; 21;
+  if(parser[NKey::kDictionary].ThereIs)
+  {
+    UInt32 dicLog;
+    if (!GetNumber(parser[NKey::kDictionary].PostStrings[0], dicLog))
+      IncorrectCommand();
+    dictionary = 1 &lt;&lt; dicLog;
+    dictionaryIsDefined = true;
+  }
+  UString mf = L&quot;BT4&quot;;
+  if (parser[NKey::kMatchFinder].ThereIs)
+    mf = parser[NKey::kMatchFinder].PostStrings[0];
+
+  if (command.CompareNoCase(L&quot;b&quot;) == 0)
+  {
+    const UInt32 kNumDefaultItereations = 10;
+    UInt32 numIterations = kNumDefaultItereations;
+    {
+      if (paramIndex &lt; nonSwitchStrings.Size())
+        if (!GetNumber(nonSwitchStrings[paramIndex++], numIterations))
+          numIterations = kNumDefaultItereations;
+    }
+    return LzmaBenchmark(stderr, numIterations, dictionary);
+  }
+
+  bool encodeMode = false;
+  if (command.CompareNoCase(L&quot;e&quot;) == 0)
+    encodeMode = true;
+  else if (command.CompareNoCase(L&quot;d&quot;) == 0)
+    encodeMode = false;
+  else
+    IncorrectCommand();
+
+  bool stdInMode = parser[NKey::kStdIn].ThereIs;
+  bool stdOutMode = parser[NKey::kStdOut].ThereIs;
+
+  CMyComPtr&lt;ISequentialInStream&gt; inStream;
+  CInFileStream *inStreamSpec = 0;
+  if (stdInMode)
+  {
+    inStream = new CStdInFileStream;
+    MY_SET_BINARY_MODE(stdin);
+  }
+  else
+  {
+    if (paramIndex &gt;= nonSwitchStrings.Size())
+      IncorrectCommand();
+    const UString &amp;inputName = nonSwitchStrings[paramIndex++]; 
+    inStreamSpec = new CInFileStream;
+    inStream = inStreamSpec;
+    if (!inStreamSpec-&gt;Open(GetSystemString(inputName)))
+    {
+      fprintf(stderr, &quot;\nError: can not open input file %s\n&quot;, 
+          (const char *)GetOemString(inputName));
+      return 1;
+    }
+  }
+
+  CMyComPtr&lt;ISequentialOutStream&gt; outStream;
+  if (stdOutMode)
+  {
+    outStream = new CStdOutFileStream;
+    MY_SET_BINARY_MODE(stdout);
+  }
+  else
+  {
+    if (paramIndex &gt;= nonSwitchStrings.Size())
+      IncorrectCommand();
+    const UString &amp;outputName = nonSwitchStrings[paramIndex++]; 
+    COutFileStream *outStreamSpec = new COutFileStream;
+    outStream = outStreamSpec;
+    if (!outStreamSpec-&gt;Create(GetSystemString(outputName), true))
+    {
+      fprintf(stderr, &quot;\nError: can not open output file %s\n&quot;, 
+        (const char *)GetOemString(outputName));
+      return 1;
+    }
+  }
+
+  if (parser[NKey::kFilter86].ThereIs)
+  {
+    // -f86 switch is for x86 filtered mode: BCJ + LZMA.
+    if (parser[NKey::kEOS].ThereIs || stdInMode)
+      throw &quot;Can not use stdin in this mode&quot;;
+    UInt64 fileSize;
+    inStreamSpec-&gt;File.GetLength(fileSize);
+    if (fileSize &gt; 0xF0000000)
+      throw &quot;File is too big&quot;;
+    UInt32 inSize = (UInt32)fileSize;
+    Byte *inBuffer = 0;
+    if (inSize != 0)
+    {
+      inBuffer = (Byte *)MyAlloc((size_t)inSize); 
+      if (inBuffer == 0)
+        throw kCantAllocate;
+    }
+    
+    UInt32 processedSize;
+    if (ReadStream(inStream, inBuffer, (UInt32)inSize, &amp;processedSize) != S_OK)
+      throw &quot;Can not read&quot;;
+    if ((UInt32)inSize != processedSize)
+      throw &quot;Read size error&quot;;
+
+    Byte *outBuffer = 0;
+    size_t outSizeProcessed;
+    if (encodeMode)
+    {
+      // we allocate 105% of original size for output buffer
+      size_t outSize = (size_t)fileSize / 20 * 21 + (1 &lt;&lt; 16);
+      if (outSize != 0)
+      {
+        outBuffer = (Byte *)MyAlloc((size_t)outSize); 
+        if (outBuffer == 0)
+          throw kCantAllocate;
+      }
+      if (!dictionaryIsDefined)
+        dictionary = 1 &lt;&lt; 23;
+      int res = LzmaRamEncode(inBuffer, inSize, outBuffer, outSize, &amp;outSizeProcessed, 
+          dictionary, SZ_FILTER_AUTO);
+      if (res != 0)
+      {
+        fprintf(stderr, &quot;\nEncoder error = %d\n&quot;, (int)res);
+        return 1;
+      }
+    }
+    else
+    {
+      size_t outSize;
+      if (LzmaRamGetUncompressedSize(inBuffer, inSize, &amp;outSize) != 0)
+        throw &quot;data error&quot;;
+      if (outSize != 0)
+      {
+        outBuffer = (Byte *)MyAlloc(outSize); 
+        if (outBuffer == 0)
+          throw kCantAllocate;
+      }
+      int res = LzmaRamDecompress(inBuffer, inSize, outBuffer, outSize, &amp;outSizeProcessed, malloc, free);
+      if (res != 0)
+        throw &quot;LzmaDecoder error&quot;;
+    }
+    if (WriteStream(outStream, outBuffer, (UInt32)outSizeProcessed, &amp;processedSize) != S_OK)
+      throw kWriteError;
+    MyFree(outBuffer);
+    MyFree(inBuffer);
+    return 0;
+  }
+
+
+  UInt64 fileSize;
+  if (encodeMode)
+  {
+    NCompress::NLZMA::CEncoder *encoderSpec = 
+      new NCompress::NLZMA::CEncoder;
+    CMyComPtr&lt;ICompressCoder&gt; encoder = encoderSpec;
+
+    if (!dictionaryIsDefined)
+      dictionary = 1 &lt;&lt; 23;
+
+    UInt32 posStateBits = 2;
+    UInt32 litContextBits = 3; // for normal files
+    // UInt32 litContextBits = 0; // for 32-bit data
+    UInt32 litPosBits = 0;
+    // UInt32 litPosBits = 2; // for 32-bit data
+    UInt32 algorithm = 2;
+    UInt32 numFastBytes = 128;
+    UInt32 matchFinderCycles = 16 + numFastBytes / 2;
+    bool matchFinderCyclesDefined = false;
+
+    bool eos = parser[NKey::kEOS].ThereIs || stdInMode;
+ 
+    if(parser[NKey::kMode].ThereIs)
+      if (!GetNumber(parser[NKey::kMode].PostStrings[0], algorithm))
+        IncorrectCommand();
+
+    if(parser[NKey::kFastBytes].ThereIs)
+      if (!GetNumber(parser[NKey::kFastBytes].PostStrings[0], numFastBytes))
+        IncorrectCommand();
+    if (matchFinderCyclesDefined = parser[NKey::kMatchFinderCycles].ThereIs)
+      if (!GetNumber(parser[NKey::kMatchFinderCycles].PostStrings[0], matchFinderCycles))
+        IncorrectCommand();
+    if(parser[NKey::kLitContext].ThereIs)
+      if (!GetNumber(parser[NKey::kLitContext].PostStrings[0], litContextBits))
+        IncorrectCommand();
+    if(parser[NKey::kLitPos].ThereIs)
+      if (!GetNumber(parser[NKey::kLitPos].PostStrings[0], litPosBits))
+        IncorrectCommand();
+    if(parser[NKey::kPosBits].ThereIs)
+      if (!GetNumber(parser[NKey::kPosBits].PostStrings[0], posStateBits))
+        IncorrectCommand();
+
+    PROPID propIDs[] = 
+    {
+      NCoderPropID::kDictionarySize,
+      NCoderPropID::kPosStateBits,
+      NCoderPropID::kLitContextBits,
+      NCoderPropID::kLitPosBits,
+      NCoderPropID::kAlgorithm,
+      NCoderPropID::kNumFastBytes,
+      NCoderPropID::kMatchFinder,
+      NCoderPropID::kEndMarker,
+      NCoderPropID::kMatchFinderCycles
+    };
+    const int kNumPropsMax = sizeof(propIDs) / sizeof(propIDs[0]);
+    /*
+    NWindows::NCOM::CPropVariant properties[kNumProps];
+    properties[0] = UInt32(dictionary);
+    properties[1] = UInt32(posStateBits);
+    properties[2] = UInt32(litContextBits);
+   
+    properties[3] = UInt32(litPosBits);
+    properties[4] = UInt32(algorithm);
+    properties[5] = UInt32(numFastBytes);
+    properties[6] = mf;
+    properties[7] = eos;
+    */
+    PROPVARIANT properties[kNumPropsMax];
+    for (int p = 0; p &lt; 6; p++)
+      properties[p].vt = VT_UI4;
+
+    properties[0].ulVal = UInt32(dictionary);
+    properties[1].ulVal = UInt32(posStateBits);
+    properties[2].ulVal = UInt32(litContextBits);
+    properties[3].ulVal = UInt32(litPosBits);
+    properties[4].ulVal = UInt32(algorithm);
+    properties[5].ulVal = UInt32(numFastBytes);
+
+    properties[8].vt = VT_UI4;
+    properties[8].ulVal = UInt32(matchFinderCycles);
+    
+    properties[6].vt = VT_BSTR;
+    properties[6].bstrVal = (BSTR)(const wchar_t *)mf;
+
+    properties[7].vt = VT_BOOL;
+    properties[7].boolVal = eos ? VARIANT_TRUE : VARIANT_FALSE;
+
+    int numProps = kNumPropsMax;
+    if (!matchFinderCyclesDefined)
+      numProps--;
+
+    if (encoderSpec-&gt;SetCoderProperties(propIDs, properties, numProps) != S_OK)
+      IncorrectCommand();
+    encoderSpec-&gt;WriteCoderProperties(outStream);
+
+    if (eos || stdInMode)
+      fileSize = (UInt64)(Int64)-1;
+    else
+      inStreamSpec-&gt;File.GetLength(fileSize);
+
+    for (int i = 0; i &lt; 8; i++)
+    {
+      Byte b = Byte(fileSize &gt;&gt; (8 * i));
+      if (outStream-&gt;Write(&amp;b, 1, 0) != S_OK)
+      {
+        fprintf(stderr, kWriteError);
+        return 1;
+      }
+    }
+    HRESULT result = encoder-&gt;Code(inStream, outStream, 0, 0, 0);
+    if (result == E_OUTOFMEMORY)
+    {
+      fprintf(stderr, &quot;\nError: Can not allocate memory\n&quot;);
+      return 1;
+    }   
+    else if (result != S_OK)
+    {
+      fprintf(stderr, &quot;\nEncoder error = %X\n&quot;, (unsigned int)result);
+      return 1;
+    }   
+  }
+  else
+  {
+    NCompress::NLZMA::CDecoder *decoderSpec = 
+        new NCompress::NLZMA::CDecoder;
+    CMyComPtr&lt;ICompressCoder&gt; decoder = decoderSpec;
+    const UInt32 kPropertiesSize = 5;
+    Byte properties[kPropertiesSize];
+    UInt32 processedSize;
+    if (ReadStream(inStream, properties, kPropertiesSize, &amp;processedSize) != S_OK)
+    {
+      fprintf(stderr, kReadError);
+      return 1;
+    }
+    if (processedSize != kPropertiesSize)
+    {
+      fprintf(stderr, kReadError);
+      return 1;
+    }
+    if (decoderSpec-&gt;SetDecoderProperties2(properties, kPropertiesSize) != S_OK)
+    {
+      fprintf(stderr, &quot;SetDecoderProperties error&quot;);
+      return 1;
+    }
+    fileSize = 0;
+    for (int i = 0; i &lt; 8; i++)
+    {
+      Byte b;
+      if (inStream-&gt;Read(&amp;b, 1, &amp;processedSize) != S_OK)
+      {
+        fprintf(stderr, kReadError);
+        return 1;
+      }
+      if (processedSize != 1)
+      {
+        fprintf(stderr, kReadError);
+        return 1;
+      }
+      fileSize |= ((UInt64)b) &lt;&lt; (8 * i);
+    }
+    if (decoder-&gt;Code(inStream, outStream, 0, &amp;fileSize, 0) != S_OK)
+    {
+      fprintf(stderr, &quot;Decoder error&quot;);
+      return 1;
+    }   
+  }
+  return 0;
+}
+
+int main(int n, const char *args[])
+{
+  try { return main2(n, args); }
+  catch(const char *s) 
+  { 
+    fprintf(stderr, &quot;\nError: %s\n&quot;, s);
+    return 1; 
+  }
+  catch(...) 
+  { 
+    fprintf(stderr, &quot;\nError\n&quot;);
+    return 1; 
+  }
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,506 @@
+// LzmaBench.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;LzmaBench.h&quot;
+
+#ifndef _WIN32
+#include &lt;time.h&gt;
+#endif
+
+#include &quot;../../../Common/CRC.h&quot;
+#include &quot;../LZMA/LZMADecoder.h&quot;
+#include &quot;../LZMA/LZMAEncoder.h&quot;
+
+static const UInt32 kAdditionalSize = 
+#ifdef _WIN32_WCE
+(1 &lt;&lt; 20);
+#else
+(6 &lt;&lt; 20);
+#endif
+
+static const UInt32 kCompressedAdditionalSize = (1 &lt;&lt; 10);
+static const UInt32 kMaxLzmaPropSize = 10;
+
+class CRandomGenerator
+{
+  UInt32 A1;
+  UInt32 A2;
+public:
+  CRandomGenerator() { Init(); }
+  void Init() { A1 = 362436069; A2 = 521288629;}
+  UInt32 GetRnd() 
+  {
+    return 
+      ((A1 = 36969 * (A1 &amp; 0xffff) + (A1 &gt;&gt; 16)) &lt;&lt; 16) ^
+      ((A2 = 18000 * (A2 &amp; 0xffff) + (A2 &gt;&gt; 16)) );
+  }
+};
+
+class CBitRandomGenerator
+{
+  CRandomGenerator RG;
+  UInt32 Value;
+  int NumBits;
+public:
+  void Init()
+  {
+    Value = 0;
+    NumBits = 0;
+  }
+  UInt32 GetRnd(int numBits) 
+  {
+    if (NumBits &gt; numBits)
+    {
+      UInt32 result = Value &amp; ((1 &lt;&lt; numBits) - 1);
+      Value &gt;&gt;= numBits;
+      NumBits -= numBits;
+      return result;
+    }
+    numBits -= NumBits;
+    UInt32 result = (Value &lt;&lt; numBits);
+    Value = RG.GetRnd();
+    result |= Value &amp; ((1 &lt;&lt; numBits) - 1);
+    Value &gt;&gt;= numBits;
+    NumBits = 32 - numBits;
+    return result;
+  }
+};
+
+class CBenchRandomGenerator
+{
+  CBitRandomGenerator RG;
+  UInt32 Pos;
+  UInt32 Rep0;
+public:
+  UInt32 BufferSize;
+  Byte *Buffer;
+  CBenchRandomGenerator(): Buffer(0) {} 
+  ~CBenchRandomGenerator() { Free(); }
+  void Free() 
+  { 
+    ::MidFree(Buffer);
+    Buffer = 0;
+  }
+  bool Alloc(UInt32 bufferSize) 
+  {
+    if (Buffer != 0 &amp;&amp; BufferSize == bufferSize)
+      return true;
+    Free();
+    Buffer = (Byte *)::MidAlloc(bufferSize);
+    Pos = 0;
+    BufferSize = bufferSize;
+    return (Buffer != 0);
+  }
+  UInt32 GetRndBit() { return RG.GetRnd(1); }
+  /*
+  UInt32 GetLogRand(int maxLen)
+  {
+    UInt32 len = GetRnd() % (maxLen + 1);
+    return GetRnd() &amp; ((1 &lt;&lt; len) - 1);
+  }
+  */
+  UInt32 GetLogRandBits(int numBits)
+  {
+    UInt32 len = RG.GetRnd(numBits);
+    return RG.GetRnd(len);
+  }
+  UInt32 GetOffset()
+  {
+    if (GetRndBit() == 0)
+      return GetLogRandBits(4);
+    return (GetLogRandBits(4) &lt;&lt; 10) | RG.GetRnd(10);
+  }
+  UInt32 GetLen1() { return RG.GetRnd(1 + (int)RG.GetRnd(2)); }
+  UInt32 GetLen2() { return RG.GetRnd(2 + (int)RG.GetRnd(2)); }
+  void Generate()
+  {
+    RG.Init(); 
+    Rep0 = 1;
+    while(Pos &lt; BufferSize)
+    {
+      if (GetRndBit() == 0 || Pos &lt; 1)
+        Buffer[Pos++] = (Byte)RG.GetRnd(8);
+      else
+      {
+        UInt32 len;
+        if (RG.GetRnd(3) == 0)
+          len = 1 + GetLen1();
+        else
+        {
+          do
+            Rep0 = GetOffset();
+          while (Rep0 &gt;= Pos);
+          Rep0++;
+          len = 2 + GetLen2();
+        }
+        for (UInt32 i = 0; i &lt; len &amp;&amp; Pos &lt; BufferSize; i++, Pos++)
+          Buffer[Pos] = Buffer[Pos - Rep0];
+      }
+    }
+  }
+};
+
+class CBenchmarkInStream: 
+  public ISequentialInStream,
+  public CMyUnknownImp
+{
+  const Byte *Data;
+  UInt32 Pos;
+  UInt32 Size;
+public:
+  MY_UNKNOWN_IMP
+  void Init(const Byte *data, UInt32 size)
+  {
+    Data = data;
+    Size = size;
+    Pos = 0;
+  }
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP CBenchmarkInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  UInt32 remain = Size - Pos;
+  if (size &gt; remain)
+    size = remain;
+  for (UInt32 i = 0; i &lt; size; i++)
+    ((Byte *)data)[i] = Data[Pos + i];
+  Pos += size;
+  if(processedSize != NULL)
+    *processedSize = size;
+  return S_OK;
+}
+  
+class CBenchmarkOutStream: 
+  public ISequentialOutStream,
+  public CMyUnknownImp
+{
+  UInt32 BufferSize;
+  FILE *_f;
+public:
+  UInt32 Pos;
+  Byte *Buffer;
+  CBenchmarkOutStream(): _f(0), Buffer(0) {} 
+  virtual ~CBenchmarkOutStream() { delete []Buffer; }
+  void Init(FILE *f, UInt32 bufferSize) 
+  {
+    delete []Buffer;
+    Buffer = 0;
+    Buffer = new Byte[bufferSize];
+    Pos = 0;
+    BufferSize = bufferSize;
+    _f = f;
+  }
+  MY_UNKNOWN_IMP
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP CBenchmarkOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  UInt32 i;
+  for (i = 0; i &lt; size &amp;&amp; Pos &lt; BufferSize; i++)
+    Buffer[Pos++] = ((const Byte *)data)[i];
+  if(processedSize != NULL)
+    *processedSize = i;
+  if (i != size)
+  {
+    fprintf(_f, &quot;\nERROR: Buffer is full\n&quot;);
+    return E_FAIL;
+  }
+  return S_OK;
+}
+  
+class CCrcOutStream: 
+  public ISequentialOutStream,
+  public CMyUnknownImp
+{
+public:
+  CCRC CRC;
+  MY_UNKNOWN_IMP
+  void Init() { CRC.Init(); }
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP CCrcOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  CRC.Update(data, size);
+  if(processedSize != NULL)
+    *processedSize = size;
+  return S_OK;
+}
+  
+static UInt64 GetTimeCount()
+{
+  #ifdef _WIN32
+  LARGE_INTEGER value;
+  if (::QueryPerformanceCounter(&amp;value))
+    return value.QuadPart;
+  return GetTickCount();
+  #else
+  return clock();
+  #endif 
+}
+
+static UInt64 GetFreq()
+{
+  #ifdef _WIN32
+  LARGE_INTEGER value;
+  if (::QueryPerformanceFrequency(&amp;value))
+    return value.QuadPart;
+  return 1000;
+  #else
+  return CLOCKS_PER_SEC;
+  #endif 
+}
+
+struct CProgressInfo:
+  public ICompressProgressInfo,
+  public CMyUnknownImp
+{
+  UInt64 ApprovedStart;
+  UInt64 InSize;
+  UInt64 Time;
+  void Init()
+  {
+    InSize = 0;
+    Time = 0;
+  }
+  MY_UNKNOWN_IMP
+  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize);
+};
+
+STDMETHODIMP CProgressInfo::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)
+{
+  if (*inSize &gt;= ApprovedStart &amp;&amp; InSize == 0)
+  {
+    Time = ::GetTimeCount();
+    InSize = *inSize;
+  }
+  return S_OK;
+}
+
+static const int kSubBits = 8;
+
+static UInt32 GetLogSize(UInt32 size)
+{
+  for (int i = kSubBits; i &lt; 32; i++)
+    for (UInt32 j = 0; j &lt; (1 &lt;&lt; kSubBits); j++)
+      if (size &lt;= (((UInt32)1) &lt;&lt; i) + (j &lt;&lt; (i - kSubBits)))
+        return (i &lt;&lt; kSubBits) + j;
+  return (32 &lt;&lt; kSubBits);
+}
+
+static UInt64 MyMultDiv64(UInt64 value, UInt64 elapsedTime)
+{
+  UInt64 freq = GetFreq();
+  UInt64 elTime = elapsedTime;
+  while(freq &gt; 1000000)
+  {
+    freq &gt;&gt;= 1;
+    elTime &gt;&gt;= 1;
+  }
+  if (elTime == 0)
+    elTime = 1;
+  return value * freq / elTime;
+}
+
+static UInt64 GetCompressRating(UInt32 dictionarySize, UInt64 elapsedTime, UInt64 size)
+{
+  UInt64 t = GetLogSize(dictionarySize) - (18 &lt;&lt; kSubBits);
+  UInt64 numCommandsForOne = 1060 + ((t * t * 10) &gt;&gt; (2 * kSubBits));
+  UInt64 numCommands = (UInt64)(size) * numCommandsForOne;
+  return MyMultDiv64(numCommands, elapsedTime);
+}
+
+static UInt64 GetDecompressRating(UInt64 elapsedTime, 
+    UInt64 outSize, UInt64 inSize)
+{
+  UInt64 numCommands = inSize * 220 + outSize * 20;
+  return MyMultDiv64(numCommands, elapsedTime);
+}
+
+/*
+static UInt64 GetTotalRating(
+    UInt32 dictionarySize, 
+    bool isBT4,
+    UInt64 elapsedTimeEn, UInt64 sizeEn,
+    UInt64 elapsedTimeDe, 
+    UInt64 inSizeDe, UInt64 outSizeDe)
+{
+  return (GetCompressRating(dictionarySize, isBT4, elapsedTimeEn, sizeEn) + 
+    GetDecompressRating(elapsedTimeDe, inSizeDe, outSizeDe)) / 2;
+}
+*/
+
+static void PrintRating(FILE *f, UInt64 rating)
+{
+  fprintf(f, &quot;%5d MIPS&quot;, (unsigned int)(rating / 1000000));
+}
+
+static void PrintResults(
+    FILE *f, 
+    UInt32 dictionarySize,
+    UInt64 elapsedTime, 
+    UInt64 size, 
+    bool decompressMode, UInt64 secondSize)
+{
+  UInt64 speed = MyMultDiv64(size, elapsedTime);
+  fprintf(f, &quot;%6d KB/s  &quot;, (unsigned int)(speed / 1024));
+  UInt64 rating;
+  if (decompressMode)
+    rating = GetDecompressRating(elapsedTime, size, secondSize);
+  else
+    rating = GetCompressRating(dictionarySize, elapsedTime, size);
+  PrintRating(f, rating);
+}
+
+static void ThrowError(FILE *f, HRESULT result, const char *s)
+{
+  fprintf(f, &quot;\nError: &quot;);
+  if (result == E_ABORT)
+    fprintf(f, &quot;User break&quot;);
+  if (result == E_OUTOFMEMORY)
+    fprintf(f, &quot;Can not allocate memory&quot;);
+  else
+    fprintf(f, s);
+  fprintf(f, &quot;\n&quot;);
+}
+
+const wchar_t *bt2 = L&quot;BT2&quot;;
+const wchar_t *bt4 = L&quot;BT4&quot;;
+
+int LzmaBenchmark(FILE *f, UInt32 numIterations, UInt32 dictionarySize)
+{
+  if (numIterations == 0)
+    return 0;
+  if (dictionarySize &lt; (1 &lt;&lt; 18))
+  {
+    fprintf(f, &quot;\nError: dictionary size for benchmark must be &gt;= 19 (512 KB)\n&quot;);
+    return 1;
+  }
+  fprintf(f, &quot;\n       Compressing                Decompressing\n\n&quot;);
+  NCompress::NLZMA::CEncoder *encoderSpec = new NCompress::NLZMA::CEncoder;
+  CMyComPtr&lt;ICompressCoder&gt; encoder = encoderSpec;
+
+  NCompress::NLZMA::CDecoder *decoderSpec = new NCompress::NLZMA::CDecoder;
+  CMyComPtr&lt;ICompressCoder&gt; decoder = decoderSpec;
+
+  CBenchmarkOutStream *propStreamSpec = new CBenchmarkOutStream;
+  CMyComPtr&lt;ISequentialOutStream&gt; propStream = propStreamSpec;
+  propStreamSpec-&gt;Init(f, kMaxLzmaPropSize);
+  
+  PROPID propIDs[] = 
+  { 
+    NCoderPropID::kDictionarySize
+  };
+  const int kNumProps = sizeof(propIDs) / sizeof(propIDs[0]);
+  PROPVARIANT properties[kNumProps];
+  properties[0].vt = VT_UI4;
+  properties[0].ulVal = UInt32(dictionarySize);
+
+  const UInt32 kBufferSize = dictionarySize + kAdditionalSize;
+  const UInt32 kCompressedBufferSize = (kBufferSize / 2) + kCompressedAdditionalSize;
+
+  if (encoderSpec-&gt;SetCoderProperties(propIDs, properties, kNumProps) != S_OK)
+  {
+    fprintf(f, &quot;\nError: Incorrect command\n&quot;);
+    return 1;
+  }
+  encoderSpec-&gt;WriteCoderProperties(propStream);
+
+  CBenchRandomGenerator rg;
+  if (!rg.Alloc(kBufferSize))
+  {
+    fprintf(f, &quot;\nError: Can't allocate memory\n&quot;);
+    return 1;
+  }
+
+  rg.Generate();
+  CCRC crc;
+  crc.Update(rg.Buffer, rg.BufferSize);
+
+  CProgressInfo *progressInfoSpec = new CProgressInfo;
+  CMyComPtr&lt;ICompressProgressInfo&gt; progressInfo = progressInfoSpec;
+
+  progressInfoSpec-&gt;ApprovedStart = dictionarySize;
+
+  UInt64 totalBenchSize = 0;
+  UInt64 totalEncodeTime = 0;
+  UInt64 totalDecodeTime = 0;
+  UInt64 totalCompressedSize = 0;
+
+  for (UInt32 i = 0; i &lt; numIterations; i++)
+  {
+    progressInfoSpec-&gt;Init();
+    CBenchmarkInStream *inStreamSpec = new CBenchmarkInStream;
+    inStreamSpec-&gt;Init(rg.Buffer, rg.BufferSize);
+    CMyComPtr&lt;ISequentialInStream&gt; inStream = inStreamSpec;
+    CBenchmarkOutStream *outStreamSpec = new CBenchmarkOutStream;
+    outStreamSpec-&gt;Init(f, kCompressedBufferSize);
+    CMyComPtr&lt;ISequentialOutStream&gt; outStream = outStreamSpec;
+    HRESULT result = encoder-&gt;Code(inStream, outStream, 0, 0, progressInfo);
+    UInt64 encodeTime = ::GetTimeCount() - progressInfoSpec-&gt;Time;
+    UInt32 compressedSize = outStreamSpec-&gt;Pos;
+    if(result != S_OK)
+    {
+      ThrowError(f, result, &quot;Encoder Error&quot;);
+      return 1;
+    }
+    if (progressInfoSpec-&gt;InSize == 0)
+    {
+      fprintf(f, &quot;\nError: Internal ERROR 1282\n&quot;);
+      return 1;
+    }
+  
+    ///////////////////////
+    // Decompressing
+  
+    CCrcOutStream *crcOutStreamSpec = new CCrcOutStream;
+    CMyComPtr&lt;ISequentialOutStream&gt; crcOutStream = crcOutStreamSpec;
+    
+    UInt64 decodeTime;
+    for (int j = 0; j &lt; 2; j++)
+    {
+      inStreamSpec-&gt;Init(outStreamSpec-&gt;Buffer, compressedSize);
+      crcOutStreamSpec-&gt;Init();
+      
+      if (decoderSpec-&gt;SetDecoderProperties2(propStreamSpec-&gt;Buffer, propStreamSpec-&gt;Pos) != S_OK)
+      {
+        fprintf(f, &quot;\nError: Set Decoder Properties Error\n&quot;);
+        return 1;
+      }
+      UInt64 outSize = kBufferSize;
+      UInt64 startTime = ::GetTimeCount();
+      result = decoder-&gt;Code(inStream, crcOutStream, 0, &amp;outSize, 0);
+      decodeTime = ::GetTimeCount() - startTime;
+      if(result != S_OK)
+      {
+        ThrowError(f, result, &quot;Decode Error&quot;);
+        return 1;
+      }
+      if (crcOutStreamSpec-&gt;CRC.GetDigest() != crc.GetDigest())
+      {
+        fprintf(f, &quot;\nError: CRC Error\n&quot;);
+        return 1;
+      }
+    }
+    UInt64 benchSize = kBufferSize - progressInfoSpec-&gt;InSize;
+    PrintResults(f, dictionarySize, encodeTime, benchSize, false, 0);
+    fprintf(f, &quot;     &quot;);
+    PrintResults(f, dictionarySize, decodeTime, kBufferSize, true, compressedSize);
+    fprintf(f, &quot;\n&quot;);
+
+    totalBenchSize += benchSize;
+    totalEncodeTime += encodeTime;
+    totalDecodeTime += decodeTime;
+    totalCompressedSize += compressedSize;
+  }
+  fprintf(f, &quot;---------------------------------------------------\n&quot;);
+  PrintResults(f, dictionarySize, totalEncodeTime, totalBenchSize, false, 0);
+  fprintf(f, &quot;     &quot;);
+  PrintResults(f, dictionarySize, totalDecodeTime, 
+      kBufferSize * numIterations, true, totalCompressedSize);
+  fprintf(f, &quot;    Average\n&quot;);
+  return 0;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,11 @@
+// LzmaBench.h
+
+#ifndef __LzmaBench_h
+#define __LzmaBench_h
+
+#include &lt;stdio.h&gt;
+#include &quot;../../../Common/Types.h&quot;
+
+int LzmaBenchmark(FILE *f, UInt32 numIterations, UInt32 dictionarySize);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaBench.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,228 @@
+// LzmaRam.cpp
+
+#include &quot;StdAfx.h&quot;
+#include &quot;../../../Common/Types.h&quot;
+#include &quot;../LZMA/LZMADecoder.h&quot;
+#include &quot;../LZMA/LZMAEncoder.h&quot;
+#include &quot;LzmaRam.h&quot;
+
+extern &quot;C&quot;
+{
+#include &quot;../Branch/BranchX86.h&quot;
+}
+
+class CInStreamRam: 
+  public ISequentialInStream,
+  public CMyUnknownImp
+{
+  const Byte *Data;
+  size_t Size;
+  size_t Pos;
+public:
+  MY_UNKNOWN_IMP
+  void Init(const Byte *data, size_t size)
+  {
+    Data = data;
+    Size = size;
+    Pos = 0;
+  }
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP CInStreamRam::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  UInt32 remain = Size - Pos;
+  if (size &gt; remain)
+    size = remain;
+  for (UInt32 i = 0; i &lt; size; i++)
+    ((Byte *)data)[i] = Data[Pos + i];
+  Pos += size;
+  if(processedSize != NULL)
+    *processedSize = size;
+  return S_OK;
+}
+  
+class COutStreamRam: 
+  public ISequentialOutStream,
+  public CMyUnknownImp
+{
+  size_t Size;
+public:
+  Byte *Data;
+  size_t Pos;
+  bool Overflow;
+  void Init(Byte *data, size_t size)
+  {
+    Data = data;
+    Size = size;
+    Pos = 0;
+    Overflow = false;
+  }
+  void SetPos(size_t pos)
+  {
+    Overflow = false;
+    Pos = pos;
+  }
+  MY_UNKNOWN_IMP
+  HRESULT WriteByte(Byte b)
+  {
+    if (Pos &gt;= Size)
+    {
+      Overflow = true;
+      return E_FAIL;
+    }
+    Data[Pos++] = b;
+    return S_OK;
+  }
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP COutStreamRam::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  UInt32 i;
+  for (i = 0; i &lt; size &amp;&amp; Pos &lt; Size; i++)
+    Data[Pos++] = ((const Byte *)data)[i];
+  if(processedSize != NULL)
+    *processedSize = i;
+  if (i != size)
+  {
+    Overflow = true;
+    return E_FAIL;
+  }
+  return S_OK;
+}
+  
+#define SZE_FAIL (1)
+#define SZE_OUTOFMEMORY (2)
+#define SZE_OUT_OVERFLOW (3)
+
+int LzmaRamEncode(
+    const Byte *inBuffer, size_t inSize, 
+    Byte *outBuffer, size_t outSize, size_t *outSizeProcessed, 
+    UInt32 dictionarySize, ESzFilterMode filterMode)
+{
+  #ifndef _NO_EXCEPTIONS
+  try { 
+  #endif
+
+  *outSizeProcessed = 0;
+  const size_t kIdSize = 1;
+  const size_t kLzmaPropsSize = 5;
+  const size_t kMinDestSize = kIdSize + kLzmaPropsSize + 8;
+  if (outSize &lt; kMinDestSize)
+    return SZE_OUT_OVERFLOW;
+  NCompress::NLZMA::CEncoder *encoderSpec = new NCompress::NLZMA::CEncoder;
+  CMyComPtr&lt;ICompressCoder&gt; encoder = encoderSpec;
+
+  PROPID propIDs[] = 
+  { 
+    NCoderPropID::kAlgorithm,
+    NCoderPropID::kDictionarySize,  
+    NCoderPropID::kNumFastBytes,
+  };
+  const int kNumProps = sizeof(propIDs) / sizeof(propIDs[0]);
+  PROPVARIANT properties[kNumProps];
+  properties[0].vt = VT_UI4;
+  properties[1].vt = VT_UI4;
+  properties[2].vt = VT_UI4;
+  properties[0].ulVal = (UInt32)2;
+  properties[1].ulVal = (UInt32)dictionarySize;
+  properties[2].ulVal = (UInt32)64;
+
+  if (encoderSpec-&gt;SetCoderProperties(propIDs, properties, kNumProps) != S_OK)
+    return 1;
+  
+  COutStreamRam *outStreamSpec = new COutStreamRam;
+  if (outStreamSpec == 0)
+    return SZE_OUTOFMEMORY;
+  CMyComPtr&lt;ISequentialOutStream&gt; outStream = outStreamSpec;
+  CInStreamRam *inStreamSpec = new CInStreamRam;
+  if (inStreamSpec == 0)
+    return SZE_OUTOFMEMORY;
+  CMyComPtr&lt;ISequentialInStream&gt; inStream = inStreamSpec;
+
+  outStreamSpec-&gt;Init(outBuffer, outSize);
+  if (outStreamSpec-&gt;WriteByte(0) != S_OK)
+    return SZE_OUT_OVERFLOW;
+
+  if (encoderSpec-&gt;WriteCoderProperties(outStream) != S_OK)
+    return SZE_OUT_OVERFLOW;
+  if (outStreamSpec-&gt;Pos != kIdSize + kLzmaPropsSize)
+    return 1;
+  
+  int i;
+  for (i = 0; i &lt; 8; i++)
+  {
+    UInt64 t = (UInt64)(inSize);
+    if (outStreamSpec-&gt;WriteByte((Byte)((t) &gt;&gt; (8 * i))) != S_OK)
+      return SZE_OUT_OVERFLOW;
+  }
+
+  Byte *filteredStream = 0;
+
+  bool useFilter = (filterMode != SZ_FILTER_NO);
+  if (useFilter)
+  {
+    if (inSize != 0)
+    {
+      filteredStream = (Byte *)MyAlloc(inSize);
+      if (filteredStream == 0)
+        return SZE_OUTOFMEMORY;
+      memmove(filteredStream, inBuffer, inSize);
+    }
+    UInt32 _prevMask;
+    UInt32 _prevPos;
+    x86_Convert_Init(_prevMask, _prevPos);
+    x86_Convert(filteredStream, (UInt32)inSize, 0, &amp;_prevMask, &amp;_prevPos, 1);
+  }
+  
+  UInt32 minSize = 0;
+  int numPasses = (filterMode == SZ_FILTER_AUTO) ? 3 : 1;
+  bool bestIsFiltered = false;
+  int mainResult = 0;
+  size_t startPos = outStreamSpec-&gt;Pos;
+  for (i = 0; i &lt; numPasses; i++)
+  {
+    if (numPasses &gt; 1 &amp;&amp; i == numPasses - 1 &amp;&amp; !bestIsFiltered)
+      break;
+    outStreamSpec-&gt;SetPos(startPos);
+    bool curModeIsFiltered = false;
+    if (useFilter &amp;&amp; i == 0)
+      curModeIsFiltered = true;
+    if (numPasses &gt; 1 &amp;&amp; i == numPasses - 1)
+      curModeIsFiltered = true;
+
+    inStreamSpec-&gt;Init(curModeIsFiltered ? filteredStream : inBuffer, inSize);
+    
+    HRESULT lzmaResult = encoder-&gt;Code(inStream, outStream, 0, 0, 0);
+    
+    mainResult = 0;
+    if (lzmaResult == E_OUTOFMEMORY)
+    {
+      mainResult = SZE_OUTOFMEMORY;
+      break;
+    } 
+    if (i == 0 || outStreamSpec-&gt;Pos &lt;= minSize)
+    {
+      minSize = outStreamSpec-&gt;Pos;
+      bestIsFiltered = curModeIsFiltered;
+    }
+    if (outStreamSpec-&gt;Overflow)
+      mainResult = SZE_OUT_OVERFLOW;
+    else if (lzmaResult != S_OK)
+    {
+      mainResult = SZE_FAIL;
+      break;
+    } 
+  }
+  *outSizeProcessed = outStreamSpec-&gt;Pos;
+  if (bestIsFiltered)
+    outBuffer[0] = 1;
+  if (useFilter)
+    MyFree(filteredStream);
+  return mainResult;
+  
+  #ifndef _NO_EXCEPTIONS
+  } catch(...) { return SZE_OUTOFMEMORY; }
+  #endif
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,46 @@
+// LzmaRam.h
+
+#ifndef __LzmaRam_h
+#define __LzmaRam_h
+
+#include &lt;stdlib.h&gt;
+#include &quot;../../../Common/Types.h&quot;
+
+/*
+LzmaRamEncode: BCJ + LZMA RAM-&gt;RAM compressing.
+It uses .lzma format, but it writes one additional byte to .lzma file:
+  0: - no filter
+  1: - x86(BCJ) filter.
+
+To provide best compression ratio dictionarySize mustbe &gt;= inSize
+
+LzmaRamEncode allocates Data with MyAlloc/BigAlloc functions.
+RAM Requirements:
+  RamSize = dictionarySize * 9.5 + 6MB + FilterBlockSize 
+    FilterBlockSize = 0, if useFilter == false
+    FilterBlockSize = inSize, if useFilter == true
+
+  Return code:
+    0 - OK
+    1 - Unspecified Error
+    2 - Memory allocating error
+    3 - Output buffer OVERFLOW
+
+If you use SZ_FILTER_AUTO mode, then encoder will use 2 or 3 passes:
+  2 passes when FILTER_NO provides better compression.
+  3 passes when FILTER_YES provides better compression.
+*/
+
+enum ESzFilterMode 
+{
+  SZ_FILTER_NO,
+  SZ_FILTER_YES,
+  SZ_FILTER_AUTO
+};
+
+int LzmaRamEncode(
+    const Byte *inBuffer, size_t inSize, 
+    Byte *outBuffer, size_t outSize, size_t *outSizeProcessed, 
+    UInt32 dictionarySize, ESzFilterMode filterMode);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRam.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,79 @@
+/* LzmaRamDecode.c */
+
+#include &quot;LzmaRamDecode.h&quot;
+#ifdef _SZ_ONE_DIRECTORY
+#include &quot;LzmaDecode.h&quot;
+#include &quot;BranchX86.h&quot;
+#else
+#include &quot;../LZMA_C/LzmaDecode.h&quot;
+#include &quot;../Branch/BranchX86.h&quot;
+#endif
+
+#define LZMA_PROPS_SIZE 14
+#define LZMA_SIZE_OFFSET 6
+
+int LzmaRamGetUncompressedSize(
+    const unsigned char *inBuffer, 
+    size_t inSize, 
+    size_t *outSize)
+{
+  unsigned int i;
+  if (inSize &lt; LZMA_PROPS_SIZE)
+    return 1;
+  *outSize = 0;
+  for(i = 0; i &lt; sizeof(size_t); i++)
+    *outSize += ((size_t)inBuffer[LZMA_SIZE_OFFSET + i]) &lt;&lt; (8 * i);
+  for(; i &lt; 8; i++)
+    if (inBuffer[LZMA_SIZE_OFFSET + i] != 0)
+      return 1;
+  return 0;
+}
+
+#define SZE_DATA_ERROR (1)
+#define SZE_OUTOFMEMORY (2)
+
+int LzmaRamDecompress(
+    const unsigned char *inBuffer, 
+    size_t inSize,
+    unsigned char *outBuffer,
+    size_t outSize,
+    size_t *outSizeProcessed,
+    void * (*allocFunc)(size_t size), 
+    void (*freeFunc)(void *))
+{
+  CLzmaDecoderState state;  /* it's about 24 bytes structure, if int is 32-bit */
+  int result;
+  SizeT outSizeProcessedLoc;
+  SizeT inProcessed;
+  int useFilter;
+  
+  if (inSize &lt; LZMA_PROPS_SIZE)
+    return 1;
+  useFilter = inBuffer[0];
+
+  *outSizeProcessed = 0;
+  if (useFilter &gt; 1)
+    return 1;
+
+  if (LzmaDecodeProperties(&amp;state.Properties, inBuffer + 1, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+    return 1;
+  state.Probs = (CProb *)allocFunc(LzmaGetNumProbs(&amp;state.Properties) * sizeof(CProb));
+  if (state.Probs == 0)
+    return SZE_OUTOFMEMORY;
+  
+  result = LzmaDecode(&amp;state,
+    inBuffer + LZMA_PROPS_SIZE, (SizeT)inSize - LZMA_PROPS_SIZE, &amp;inProcessed,
+    outBuffer, (SizeT)outSize, &amp;outSizeProcessedLoc);
+  freeFunc(state.Probs);
+  if (result != LZMA_RESULT_OK)
+    return 1;
+  *outSizeProcessed = (size_t)outSizeProcessedLoc;
+  if (useFilter == 1)
+  {
+    UInt32 _prevMask;
+    UInt32 _prevPos;
+    x86_Convert_Init(_prevMask, _prevPos);
+    x86_Convert(outBuffer, (UInt32)outSizeProcessedLoc, 0, &amp;_prevMask, &amp;_prevPos, 0);
+  }
+  return 0;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,55 @@
+/* LzmaRamDecode.h */
+
+#ifndef __LzmaRamDecode_h
+#define __LzmaRamDecode_h
+
+#include &lt;stdlib.h&gt;
+
+/*
+LzmaRamGetUncompressedSize:
+  In: 
+    inBuffer - input data
+    inSize   - input data size
+  Out: 
+    outSize  - uncompressed size
+  Return code:
+    0 - OK
+    1 - Error in headers
+*/
+
+int LzmaRamGetUncompressedSize(
+    const unsigned char *inBuffer, 
+    size_t inSize,
+    size_t *outSize);
+
+
+/*
+LzmaRamDecompress:
+  In: 
+    inBuffer  - input data
+    inSize    - input data size
+    outBuffer - output data
+    outSize   - output size
+    allocFunc - alloc function (can be malloc)
+    freeFunc  - free function (can be free)
+  Out: 
+    outSizeProcessed - processed size
+  Return code:
+    0 - OK
+    1 - Error in headers / data stream
+    2 - Memory allocating error
+
+Memory requirements depend from properties of LZMA stream.
+With default lzma settings it's about 16 KB.
+*/
+
+int LzmaRamDecompress(
+    const unsigned char *inBuffer, 
+    size_t inSize,
+    unsigned char *outBuffer,
+    size_t outSize,
+    size_t *outSizeProcessed,
+    void * (*allocFunc)(size_t size), 
+    void (*freeFunc)(void *));
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,3 @@
+// StdAfx.cpp
+
+#include &quot;StdAfx.h&quot;


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,8 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include &quot;../../../Common/MyWindows.h&quot;
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/StdAfx.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,100 @@
+PROG = lzma.exe
+CFLAGS = $(CFLAGS) -I ../../../
+LIBS = $(LIBS) oleaut32.lib user32.lib
+
+!IFNDEF O
+!IFDEF CPU
+O=$(CPU)
+!ELSE
+O=O
+!ENDIF
+!ENDIF
+
+CFLAGS = $(CFLAGS) -nologo -EHsc -c -Fo$O/ -GS- 
+CFLAGS_O1 = $(CFLAGS) -O1
+CFLAGS_O2 = $(CFLAGS) -O2
+
+LFLAGS = $(LFLAGS) -nologo -OPT:NOWIN98
+
+PROGPATH = $O\$(PROG)
+
+COMPL_O1   = $(CPP) $(CFLAGS_O1) $**
+COMPL_O2   = $(CPP) $(CFLAGS_O2) $**
+COMPL      = $(CPP) $(CFLAGS_O1) $**
+
+
+LZMA_OBJS = \
+  $O\LzmaAlone.obj \
+  $O\LzmaBench.obj \
+  $O\LzmaRam.obj \
+
+LZMA_OPT_OBJS = \
+  $O\LZMADecoder.obj \
+  $O\LZMAEncoder.obj \
+
+COMMON_OBJS = \
+  $O\Alloc.obj \
+  $O\CRC.obj \
+  $O\CommandLineParser.obj \
+  $O\String.obj \
+  $O\StringConvert.obj \
+  $O\StringToInt.obj \
+  $O\Vector.obj
+
+7ZIP_COMMON_OBJS = \
+  $O\InBuffer.obj \
+  $O\OutBuffer.obj \
+  $O\StreamUtils.obj \
+
+LZ_OBJS = \
+  $O\LZInWindow.obj \
+  $O\LZOutWindow.obj \
+
+
+OBJS = \
+  $(LZMA_OBJS) \
+  $(LZMA_OPT_OBJS) \
+  $(COMMON_OBJS) \
+  $(7ZIP_COMMON_OBJS) \
+  $(LZ_OBJS) \
+  $O\LzmaRamDecode.obj \
+  $O\LzmaDecode.obj \
+  $O\FileStreams.obj \
+  $O\FileIO.obj \
+  $O\RangeCoderBit.obj \
+  $O\BranchX86.obj \
+
+all: $(PROGPATH) 
+
+clean:
+	-del /Q $(PROGPATH) $O\*.exe $O\*.dll $O\*.obj $O\*.lib $O\*.exp $O\*.res $O\*.pch 
+
+$O:
+	if not exist &quot;$O&quot; mkdir &quot;$O&quot;
+
+$(PROGPATH): $O $(OBJS)
+	link $(LFLAGS) -out:$(PROGPATH) $(OBJS) $(LIBS)
+
+
+$(LZMA_OBJS): $(*B).cpp
+	$(COMPL)
+$(LZMA_OPT_OBJS): ../LZMA/$(*B).cpp
+	$(COMPL_O2)
+$(COMMON_OBJS): ../../../Common/$(*B).cpp
+	$(COMPL)
+$(7ZIP_COMMON_OBJS): ../../Common/$(*B).cpp
+	$(COMPL)
+$(LZ_OBJS): ../LZ/$(*B).cpp
+	$(COMPL)
+$O\RangeCoderBit.obj: ../RangeCoder/$(*B).cpp
+	$(COMPL)
+$O\LzmaRamDecode.obj: LzmaRamDecode.c
+	$(COMPL_O1)
+$O\LzmaDecode.obj: ../LZMA_C/LzmaDecode.c
+	$(COMPL_O2)
+$O\BranchX86.obj: ../Branch/BranchX86.c
+	$(COMPL_O2)
+$O\FileStreams.obj: ../../Common/FileStreams.cpp
+	$(COMPL)
+$O\FileIO.obj: ../../../Windows/FileIO.cpp
+	$(COMPL)


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile.gcc
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile.gcc	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile.gcc	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,113 @@
+PROG = lzma
+CXX = g++ -O2 -Wall
+CXX_C = gcc -O2 -Wall
+LIB = -lm
+RM = rm -f
+CFLAGS = -c -I ../../../
+
+OBJS = \
+  LzmaAlone.o \
+  LzmaBench.o \
+  LzmaRam.o \
+  LzmaRamDecode.o \
+  LzmaDecode.o \
+  BranchX86.o \
+  LZMADecoder.o \
+  LZMAEncoder.o \
+  LZInWindow.o \
+  LZOutWindow.o \
+  RangeCoderBit.o \
+  InBuffer.o \
+  OutBuffer.o \
+  FileStreams.o \
+  StreamUtils.o \
+  Alloc.o \
+  C_FileIO.o \
+  CommandLineParser.o \
+  CRC.o \
+  String.o \
+  StringConvert.o \
+  StringToInt.o \
+  Vector.o \
+
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB)
+
+LzmaAlone.o: LzmaAlone.cpp
+	$(CXX) $(CFLAGS) LzmaAlone.cpp
+
+LzmaBench.o: LzmaBench.cpp
+	$(CXX) $(CFLAGS) LzmaBench.cpp
+
+LzmaRam.o: LzmaRam.cpp
+	$(CXX) $(CFLAGS) LzmaRam.cpp
+
+LzmaRamDecode.o: LzmaRamDecode.c
+	$(CXX_C) $(CFLAGS) LzmaRamDecode.c
+
+LzmaDecode.o: ../LZMA_C/LzmaDecode.c
+	$(CXX_C) $(CFLAGS) ../LZMA_C/LzmaDecode.c
+
+BranchX86.o: ../Branch/BranchX86.c
+	$(CXX_C) $(CFLAGS) ../Branch/BranchX86.c
+
+LZMADecoder.o: ../LZMA/LZMADecoder.cpp
+	$(CXX) $(CFLAGS) ../LZMA/LZMADecoder.cpp
+
+LZMAEncoder.o: ../LZMA/LZMAEncoder.cpp
+	$(CXX) $(CFLAGS) ../LZMA/LZMAEncoder.cpp
+
+LZInWindow.o: ../LZ/LZInWindow.cpp
+	$(CXX) $(CFLAGS) ../LZ/LZInWindow.cpp
+
+LZOutWindow.o: ../LZ/LZOutWindow.cpp
+	$(CXX) $(CFLAGS) ../LZ/LZOutWindow.cpp
+
+RangeCoderBit.o: ../RangeCoder/RangeCoderBit.cpp
+	$(CXX) $(CFLAGS) ../RangeCoder/RangeCoderBit.cpp
+
+InBuffer.o: ../../Common/InBuffer.cpp
+	$(CXX) $(CFLAGS) ../../Common/InBuffer.cpp
+
+OutBuffer.o: ../../Common/OutBuffer.cpp
+	$(CXX) $(CFLAGS) ../../Common/OutBuffer.cpp
+
+FileStreams.o: ../../Common/FileStreams.cpp
+	$(CXX) $(CFLAGS) ../../Common/FileStreams.cpp
+
+StreamUtils.o: ../../Common/StreamUtils.cpp
+	$(CXX) $(CFLAGS) ../../Common/StreamUtils.cpp
+
+Alloc.o: ../../../Common/Alloc.cpp
+	$(CXX) $(CFLAGS) ../../../Common/Alloc.cpp
+
+C_FileIO.o: ../../../Common/C_FileIO.cpp
+	$(CXX) $(CFLAGS) ../../../Common/C_FileIO.cpp
+
+CommandLineParser.o: ../../../Common/CommandLineParser.cpp
+	$(CXX) $(CFLAGS) ../../../Common/CommandLineParser.cpp
+
+CRC.o: ../../../Common/CRC.cpp
+	$(CXX) $(CFLAGS) ../../../Common/CRC.cpp
+
+MyWindows.o: ../../../Common/MyWindows.cpp
+	$(CXX) $(CFLAGS) ../../../Common/MyWindows.cpp
+
+String.o: ../../../Common/String.cpp
+	$(CXX) $(CFLAGS) ../../../Common/String.cpp
+
+StringConvert.o: ../../../Common/StringConvert.cpp
+	$(CXX) $(CFLAGS) ../../../Common/StringConvert.cpp
+
+StringToInt.o: ../../../Common/StringToInt.cpp
+	$(CXX) $(CFLAGS) ../../../Common/StringToInt.cpp
+
+Vector.o: ../../../Common/Vector.cpp
+	$(CXX) $(CFLAGS) ../../../Common/Vector.cpp
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_Alone/makefile.gcc
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,584 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  <A HREF="http://www.7-zip.org/">http://www.7-zip.org/</A>
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include &quot;LzmaDecode.h&quot;
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i &lt; 5; i++) { RC_TEST; Code = (Code &lt;&lt; 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback-&gt;Read(InCallback, &amp;Buffer, &amp;size); if (result != LZMA_RESULT_OK) return result; \
+  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range &lt; kTopValue) { RC_TEST; Range &lt;&lt;= 8; Code = (Code &lt;&lt; 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range &gt;&gt; kNumBitModelTotalBits) * *(p); if (Code &lt; bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) &gt;&gt; kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) &gt;&gt; kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi &lt;&lt;= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 &lt;&lt; numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 &lt;&lt; kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax &lt;&lt; kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax &lt;&lt; kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex &gt;&gt; 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates &lt;&lt; kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size &lt; LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 &gt;= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes-&gt;pb = 0; prop0 &gt;= (9 * 5); propsRes-&gt;pb++, prop0 -= (9 * 5));
+    for (propsRes-&gt;lp = 0; prop0 &gt;= 9; propsRes-&gt;lp++, prop0 -= 9);
+    propsRes-&gt;lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes-&gt;lc = prop0 % 9;
+    propsRes-&gt;pb = remainder / 5;
+    propsRes-&gt;lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes-&gt;DictionarySize = 0;
+    for (i = 0; i &lt; 4; i++)
+      propsRes-&gt;DictionarySize += (UInt32)(propsData[1 + i]) &lt;&lt; (i * 8);
+    if (propsRes-&gt;DictionarySize == 0)
+      propsRes-&gt;DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs-&gt;Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 &lt;&lt; (vs-&gt;Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 &lt;&lt; (vs-&gt;Properties.lp)) - 1;
+  int lc = vs-&gt;Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs-&gt;Range;
+  UInt32 Code = vs-&gt;Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs-&gt;Buffer;
+  const Byte *BufferLim = vs-&gt;BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs-&gt;State;
+  UInt32 rep0 = vs-&gt;Reps[0], rep1 = vs-&gt;Reps[1], rep2 = vs-&gt;Reps[2], rep3 = vs-&gt;Reps[3];
+  int len = vs-&gt;RemainLen;
+  UInt32 globalPos = vs-&gt;GlobalPos;
+  UInt32 distanceLimit = vs-&gt;DistanceLimit;
+
+  Byte *dictionary = vs-&gt;Dictionary;
+  UInt32 dictionarySize = vs-&gt;Properties.DictionarySize;
+  UInt32 dictionaryPos = vs-&gt;DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs-&gt;TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE &lt;&lt; (lc + vs-&gt;Properties.lp));
+      UInt32 i;
+      for (i = 0; i &lt; numProbs; i++)
+        p[i] = kBitModelTotal &gt;&gt; 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 &amp;&amp; nowPos &lt; outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos &gt;= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE &lt;&lt; (lc + vs-&gt;Properties.lp));
+    for (i = 0; i &lt; numProbs; i++)
+      p[i] = kBitModelTotal &gt;&gt; 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos &lt; outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        &amp; posStateMask);
+
+    prob = p + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        &amp; literalPosMask) &lt;&lt; lc) + (previousByte &gt;&gt; (8 - lc))));
+
+      if (state &gt;= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos &gt;= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte &lt;&lt;= 1;
+          bit = (matchByte &amp; 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol &lt; 0x100);
+      }
+      while (symbol &lt; 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit &lt; dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state &lt; 4) state = 0;
+      else if (state &lt; 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state &lt; kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+            
+            state = state &lt; kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos &gt;= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit &lt; dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state &lt; kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state &lt; 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt; 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot &gt;= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot &gt;&gt; 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot &amp; 1));
+          if (posSlot &lt; kEndPosModelIndex)
+          {
+            rep0 &lt;&lt;= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range &gt;&gt;= 1;
+              rep0 &lt;&lt;= 1;
+              if (Code &gt;= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 &lt;&lt;= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i &lt;&lt;= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 &gt; distanceLimit) 
+      #else
+      if (rep0 &gt; nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit &gt; (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos &gt;= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 &amp;&amp; nowPos &lt; outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs-&gt;Range = Range;
+  vs-&gt;Code = Code;
+  vs-&gt;DictionaryPos = dictionaryPos;
+  vs-&gt;GlobalPos = globalPos + (UInt32)nowPos;
+  vs-&gt;DistanceLimit = distanceLimit;
+  vs-&gt;Reps[0] = rep0;
+  vs-&gt;Reps[1] = rep1;
+  vs-&gt;Reps[2] = rep2;
+  vs-&gt;Reps[3] = rep3;
+  vs-&gt;State = state;
+  vs-&gt;RemainLen = len;
+  vs-&gt;TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs-&gt;Buffer = Buffer;
+  vs-&gt;BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  <A HREF="http://www.7-zip.org/">http://www.7-zip.org/</A>
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include &quot;LzmaTypes.h&quot;
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE &lt;&lt; ((Properties)-&gt;lc + (Properties)-&gt;lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)-&gt;RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecode.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,712 @@
+/*
+  LzmaDecodeSize.c
+  LZMA Decoder (optimized for Size version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  <A HREF="http://www.7-zip.org/">http://www.7-zip.org/</A>
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include &quot;LzmaDecode.h&quot;
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+typedef struct _CRangeDecoder
+{
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+  #ifdef _LZMA_IN_CB
+  ILzmaInCallback *InCallback;
+  int Result;
+  #endif
+  int ExtraBytes;
+} CRangeDecoder;
+
+Byte RangeDecoderReadByte(CRangeDecoder *rd)
+{
+  if (rd-&gt;Buffer == rd-&gt;BufferLim)
+  {
+    #ifdef _LZMA_IN_CB
+    SizeT size;
+    rd-&gt;Result = rd-&gt;InCallback-&gt;Read(rd-&gt;InCallback, &amp;rd-&gt;Buffer, &amp;size);
+    rd-&gt;BufferLim = rd-&gt;Buffer + size;
+    if (size == 0)
+    #endif
+    {
+      rd-&gt;ExtraBytes = 1;
+      return 0xFF;
+    }
+  }
+  return (*rd-&gt;Buffer++);
+}
+
+/* #define ReadByte (*rd-&gt;Buffer++) */
+#define ReadByte (RangeDecoderReadByte(rd))
+
+void RangeDecoderInit(CRangeDecoder *rd
+  #ifndef _LZMA_IN_CB
+    , const Byte *stream, SizeT bufferSize
+  #endif
+    )
+{
+  int i;
+  #ifdef _LZMA_IN_CB
+  rd-&gt;Buffer = rd-&gt;BufferLim = 0;
+  #else
+  rd-&gt;Buffer = stream;
+  rd-&gt;BufferLim = stream + bufferSize;
+  #endif
+  rd-&gt;ExtraBytes = 0;
+  rd-&gt;Code = 0;
+  rd-&gt;Range = (0xFFFFFFFF);
+  for(i = 0; i &lt; 5; i++)
+    rd-&gt;Code = (rd-&gt;Code &lt;&lt; 8) | ReadByte;
+}
+
+#define RC_INIT_VAR UInt32 range = rd-&gt;Range; UInt32 code = rd-&gt;Code;        
+#define RC_FLUSH_VAR rd-&gt;Range = range; rd-&gt;Code = code;
+#define RC_NORMALIZE if (range &lt; kTopValue) { range &lt;&lt;= 8; code = (code &lt;&lt; 8) | ReadByte; }
+
+UInt32 RangeDecoderDecodeDirectBits(CRangeDecoder *rd, int numTotalBits)
+{
+  RC_INIT_VAR
+  UInt32 result = 0;
+  int i;
+  for (i = numTotalBits; i != 0; i--)
+  {
+    /* UInt32 t; */
+    range &gt;&gt;= 1;
+
+    result &lt;&lt;= 1;
+    if (code &gt;= range)
+    {
+      code -= range;
+      result |= 1;
+    }
+    /*
+    t = (code - range) &gt;&gt; 31;
+    t &amp;= 1;
+    code -= range &amp; (t - 1);
+    result = (result + result) | (1 - t);
+    */
+    RC_NORMALIZE
+  }
+  RC_FLUSH_VAR
+  return result;
+}
+
+int RangeDecoderBitDecode(CProb *prob, CRangeDecoder *rd)
+{
+  UInt32 bound = (rd-&gt;Range &gt;&gt; kNumBitModelTotalBits) * *prob;
+  if (rd-&gt;Code &lt; bound)
+  {
+    rd-&gt;Range = bound;
+    *prob += (kBitModelTotal - *prob) &gt;&gt; kNumMoveBits;
+    if (rd-&gt;Range &lt; kTopValue)
+    {
+      rd-&gt;Code = (rd-&gt;Code &lt;&lt; 8) | ReadByte;
+      rd-&gt;Range &lt;&lt;= 8;
+    }
+    return 0;
+  }
+  else
+  {
+    rd-&gt;Range -= bound;
+    rd-&gt;Code -= bound;
+    *prob -= (*prob) &gt;&gt; kNumMoveBits;
+    if (rd-&gt;Range &lt; kTopValue)
+    {
+      rd-&gt;Code = (rd-&gt;Code &lt;&lt; 8) | ReadByte;
+      rd-&gt;Range &lt;&lt;= 8;
+    }
+    return 1;
+  }
+}
+
+#define RC_GET_BIT2(prob, mi, A0, A1) \
+  UInt32 bound = (range &gt;&gt; kNumBitModelTotalBits) * *prob; \
+  if (code &lt; bound) \
+    { A0; range = bound; *prob += (kBitModelTotal - *prob) &gt;&gt; kNumMoveBits; mi &lt;&lt;= 1; } \
+  else \
+    { A1; range -= bound; code -= bound; *prob -= (*prob) &gt;&gt; kNumMoveBits; mi = (mi + mi) + 1; } \
+  RC_NORMALIZE
+
+#define RC_GET_BIT(prob, mi) RC_GET_BIT2(prob, mi, ; , ;)               
+
+int RangeDecoderBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+{
+  int mi = 1;
+  int i;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  for(i = numLevels; i != 0; i--)
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + mi;
+    RC_GET_BIT(prob, mi)
+    #else
+    mi = (mi + mi) + RangeDecoderBitDecode(probs + mi, rd);
+    #endif
+  }
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return mi - (1 &lt;&lt; numLevels);
+}
+
+int RangeDecoderReverseBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+{
+  int mi = 1;
+  int i;
+  int symbol = 0;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  for(i = 0; i &lt; numLevels; i++)
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + mi;
+    RC_GET_BIT2(prob, mi, ; , symbol |= (1 &lt;&lt; i))
+    #else
+    int bit = RangeDecoderBitDecode(probs + mi, rd);
+    mi = mi + mi + bit;
+    symbol |= (bit &lt;&lt; i);
+    #endif
+  }
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
+Byte LzmaLiteralDecode(CProb *probs, CRangeDecoder *rd)
+{ 
+  int symbol = 1;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  do
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + symbol;
+    RC_GET_BIT(prob, symbol)
+    #else
+    symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
+    #endif
+  }
+  while (symbol &lt; 0x100);
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
+Byte LzmaLiteralDecodeMatch(CProb *probs, CRangeDecoder *rd, Byte matchByte)
+{ 
+  int symbol = 1;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  do
+  {
+    int bit;
+    int matchBit = (matchByte &gt;&gt; 7) &amp; 1;
+    matchByte &lt;&lt;= 1;
+    #ifdef _LZMA_LOC_OPT
+    {
+      CProb *prob = probs + 0x100 + (matchBit &lt;&lt; 8) + symbol;
+      RC_GET_BIT2(prob, symbol, bit = 0, bit = 1)
+    }
+    #else
+    bit = RangeDecoderBitDecode(probs + 0x100 + (matchBit &lt;&lt; 8) + symbol, rd);
+    symbol = (symbol &lt;&lt; 1) | bit;
+    #endif
+    if (matchBit != bit)
+    {
+      while (symbol &lt; 0x100)
+      {
+        #ifdef _LZMA_LOC_OPT
+        CProb *prob = probs + symbol;
+        RC_GET_BIT(prob, symbol)
+        #else
+        symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
+        #endif
+      }
+      break;
+    }
+  }
+  while (symbol &lt; 0x100);
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 &lt;&lt; kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax &lt;&lt; kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax &lt;&lt; kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+int LzmaLenDecode(CProb *p, CRangeDecoder *rd, int posState)
+{
+  if(RangeDecoderBitDecode(p + LenChoice, rd) == 0)
+    return RangeDecoderBitTreeDecode(p + LenLow +
+        (posState &lt;&lt; kLenNumLowBits), kLenNumLowBits, rd);
+  if(RangeDecoderBitDecode(p + LenChoice2, rd) == 0)
+    return kLenNumLowSymbols + RangeDecoderBitTreeDecode(p + LenMid +
+        (posState &lt;&lt; kLenNumMidBits), kLenNumMidBits, rd);
+  return kLenNumLowSymbols + kLenNumMidSymbols + 
+      RangeDecoderBitTreeDecode(p + LenHigh, kLenNumHighBits, rd);
+}
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex &gt;&gt; 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates &lt;&lt; kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size &lt; LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 &gt;= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes-&gt;pb = 0; prop0 &gt;= (9 * 5); propsRes-&gt;pb++, prop0 -= (9 * 5));
+    for (propsRes-&gt;lp = 0; prop0 &gt;= 9; propsRes-&gt;lp++, prop0 -= 9);
+    propsRes-&gt;lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes-&gt;lc = prop0 % 9;
+    propsRes-&gt;pb = remainder / 5;
+    propsRes-&gt;lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes-&gt;DictionarySize = 0;
+    for (i = 0; i &lt; 4; i++)
+      propsRes-&gt;DictionarySize += (UInt32)(propsData[1 + i]) &lt;&lt; (i * 8);
+    if (propsRes-&gt;DictionarySize == 0)
+      propsRes-&gt;DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs-&gt;Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 &lt;&lt; (vs-&gt;Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 &lt;&lt; (vs-&gt;Properties.lp)) - 1;
+  int lc = vs-&gt;Properties.lc;
+  CRangeDecoder rd;
+
+  #ifdef _LZMA_OUT_READ
+  
+  int state = vs-&gt;State;
+  UInt32 rep0 = vs-&gt;Reps[0], rep1 = vs-&gt;Reps[1], rep2 = vs-&gt;Reps[2], rep3 = vs-&gt;Reps[3];
+  int len = vs-&gt;RemainLen;
+  UInt32 globalPos = vs-&gt;GlobalPos;
+  UInt32 distanceLimit = vs-&gt;DistanceLimit;
+
+  Byte *dictionary = vs-&gt;Dictionary;
+  UInt32 dictionarySize = vs-&gt;Properties.DictionarySize;
+  UInt32 dictionaryPos = vs-&gt;DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  rd.Range = vs-&gt;Range;
+  rd.Code = vs-&gt;Code;
+  #ifdef _LZMA_IN_CB
+  rd.InCallback = InCallback;
+  rd.Buffer = vs-&gt;Buffer;
+  rd.BufferLim = vs-&gt;BufferLim;
+  #else
+  rd.Buffer = inStream;
+  rd.BufferLim = inStream + inSize;
+  #endif
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs-&gt;TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE &lt;&lt; (lc + vs-&gt;Properties.lp));
+      UInt32 i;
+      for (i = 0; i &lt; numProbs; i++)
+        p[i] = kBitModelTotal &gt;&gt; 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      RangeDecoderInit(&amp;rd
+          #ifndef _LZMA_IN_CB
+          , inStream, inSize
+          #endif
+          );
+      #ifdef _LZMA_IN_CB
+      if (rd.Result != LZMA_RESULT_OK)
+        return rd.Result;
+      #endif
+      if (rd.ExtraBytes != 0)
+        return LZMA_RESULT_DATA_ERROR;
+    }
+    len = 0;
+  }
+  while(len != 0 &amp;&amp; nowPos &lt; outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos &gt;= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #ifdef _LZMA_IN_CB
+  rd.Result = LZMA_RESULT_OK;
+  #endif
+  rd.ExtraBytes = 0;
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE &lt;&lt; (lc + vs-&gt;Properties.lp));
+    for (i = 0; i &lt; numProbs; i++)
+      p[i] = kBitModelTotal &gt;&gt; 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  rd.InCallback = InCallback;
+  #endif
+  RangeDecoderInit(&amp;rd
+      #ifndef _LZMA_IN_CB
+      , inStream, inSize
+      #endif
+      );
+
+  #ifdef _LZMA_IN_CB
+  if (rd.Result != LZMA_RESULT_OK)
+    return rd.Result;
+  #endif
+  if (rd.ExtraBytes != 0)
+    return LZMA_RESULT_DATA_ERROR;
+
+  #endif /* _LZMA_OUT_READ */
+
+
+  while(nowPos &lt; outSize)
+  {
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        &amp; posStateMask);
+    #ifdef _LZMA_IN_CB
+    if (rd.Result != LZMA_RESULT_OK)
+      return rd.Result;
+    #endif
+    if (rd.ExtraBytes != 0)
+      return LZMA_RESULT_DATA_ERROR;
+    if (RangeDecoderBitDecode(p + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState, &amp;rd) == 0)
+    {
+      CProb *probs = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        &amp; literalPosMask) &lt;&lt; lc) + (previousByte &gt;&gt; (8 - lc))));
+
+      if (state &gt;= kNumLitStates)
+      {
+        Byte matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos &gt;= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        previousByte = LzmaLiteralDecodeMatch(probs, &amp;rd, matchByte);
+      }
+      else
+        previousByte = LzmaLiteralDecode(probs, &amp;rd);
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit &lt; dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state &lt; 4) state = 0;
+      else if (state &lt; 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      if (RangeDecoderBitDecode(p + IsRep + state, &amp;rd) == 1)
+      {
+        if (RangeDecoderBitDecode(p + IsRepG0 + state, &amp;rd) == 0)
+        {
+          if (RangeDecoderBitDecode(p + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState, &amp;rd) == 0)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+      
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+
+            state = state &lt; 7 ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos &gt;= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit &lt; dictionarySize)
+              distanceLimit++;
+            #endif
+            continue;
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          if(RangeDecoderBitDecode(p + IsRepG1 + state, &amp;rd) == 0)
+            distance = rep1;
+          else 
+          {
+            if(RangeDecoderBitDecode(p + IsRepG2 + state, &amp;rd) == 0)
+              distance = rep2;
+            else
+            {
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        len = LzmaLenDecode(p + RepLenCoder, &amp;rd, posState);
+        state = state &lt; 7 ? 8 : 11;
+      }
+      else
+      {
+        int posSlot;
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state &lt; 7 ? 7 : 10;
+        len = LzmaLenDecode(p + LenCoder, &amp;rd, posState);
+        posSlot = RangeDecoderBitTreeDecode(p + PosSlot +
+            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt; 
+            kNumPosSlotBits), kNumPosSlotBits, &amp;rd);
+        if (posSlot &gt;= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot &gt;&gt; 1) - 1);
+          rep0 = ((2 | ((UInt32)posSlot &amp; 1)) &lt;&lt; numDirectBits);
+          if (posSlot &lt; kEndPosModelIndex)
+          {
+            rep0 += RangeDecoderReverseBitTreeDecode(
+                p + SpecPos + rep0 - posSlot - 1, numDirectBits, &amp;rd);
+          }
+          else
+          {
+            rep0 += RangeDecoderDecodeDirectBits(&amp;rd, 
+                numDirectBits - kNumAlignBits) &lt;&lt; kNumAlignBits;
+            rep0 += RangeDecoderReverseBitTreeDecode(p + Align, kNumAlignBits, &amp;rd);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 &gt; distanceLimit) 
+      #else
+      if (rep0 &gt; nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit &gt; (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos &gt;= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 &amp;&amp; nowPos &lt; outSize);
+    }
+  }
+
+
+  #ifdef _LZMA_OUT_READ
+  vs-&gt;Range = rd.Range;
+  vs-&gt;Code = rd.Code;
+  vs-&gt;DictionaryPos = dictionaryPos;
+  vs-&gt;GlobalPos = globalPos + (UInt32)nowPos;
+  vs-&gt;DistanceLimit = distanceLimit;
+  vs-&gt;Reps[0] = rep0;
+  vs-&gt;Reps[1] = rep1;
+  vs-&gt;Reps[2] = rep2;
+  vs-&gt;Reps[3] = rep3;
+  vs-&gt;State = state;
+  vs-&gt;RemainLen = len;
+  vs-&gt;TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs-&gt;Buffer = rd.Buffer;
+  vs-&gt;BufferLim = rd.BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(rd.Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,521 @@
+/*
+  LzmaStateDecode.c
+  LZMA Decoder (State version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  <A HREF="http://www.7-zip.org/">http://www.7-zip.org/</A>
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include &quot;LzmaStateDecode.h&quot;
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 &lt;&lt; kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 &lt;&lt; kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i &lt; 5; i++) { Code = (Code &lt;&lt; 8) | RC_READ_BYTE; }}
+
+#define RC_NORMALIZE if (Range &lt; kTopValue) { Range &lt;&lt;= 8; Code = (Code &lt;&lt; 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range &gt;&gt; kNumBitModelTotalBits) * *(p); if (Code &lt; bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) &gt;&gt; kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) &gt;&gt; kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi &lt;&lt;= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 &lt;&lt; numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 &lt;&lt; kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 &lt;&lt; kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 &lt;&lt; kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 &lt;&lt; kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax &lt;&lt; kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax &lt;&lt; kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 &lt;&lt; (kEndPosModelIndex &gt;&gt; 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 &lt;&lt; kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates &lt;&lt; kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates &lt;&lt; kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+/* kRequiredInBufferSize = number of required input bytes for worst case: 
+   longest match with longest distance.
+   kLzmaInBufferSize must be larger than kRequiredInBufferSize 
+   23 bits = 2 (match select) + 10 (len) + 6 (distance) + 4(align) + 1 (RC_NORMALIZE)
+*/
+
+#define kRequiredInBufferSize ((23 * (kNumBitModelTotalBits - kNumMoveBits + 1) + 26 + 9) / 8)
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size &lt; LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 &gt;= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes-&gt;pb = 0; prop0 &gt;= (9 * 5); propsRes-&gt;pb++, prop0 -= (9 * 5));
+    for (propsRes-&gt;lp = 0; prop0 &gt;= 9; propsRes-&gt;lp++, prop0 -= 9);
+    propsRes-&gt;lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes-&gt;lc = prop0 % 9;
+    propsRes-&gt;pb = remainder / 5;
+    propsRes-&gt;lp = remainder % 5;
+    */
+  }
+
+  {
+    int i;
+    propsRes-&gt;DictionarySize = 0;
+    for (i = 0; i &lt; 4; i++)
+      propsRes-&gt;DictionarySize += (UInt32)(propsData[1 + i]) &lt;&lt; (i * 8);
+    if (propsRes-&gt;DictionarySize == 0)
+      propsRes-&gt;DictionarySize = 1;
+    return LZMA_RESULT_OK;
+  }
+}
+
+int LzmaDecode(
+    CLzmaDecoderState *vs,
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed,
+    int finishDecoding)
+{
+  UInt32 Range = vs-&gt;Range;
+  UInt32 Code = vs-&gt;Code;
+
+  unsigned char *Buffer = vs-&gt;Buffer;
+  int BufferSize = vs-&gt;BufferSize; /* don't change it to unsigned int */
+  CProb *p = vs-&gt;Probs;
+
+  int state = vs-&gt;State;
+  unsigned char previousByte;
+  UInt32 rep0 = vs-&gt;Reps[0], rep1 = vs-&gt;Reps[1], rep2 = vs-&gt;Reps[2], rep3 = vs-&gt;Reps[3];
+  SizeT nowPos = 0;
+  UInt32 posStateMask = (1 &lt;&lt; (vs-&gt;Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 &lt;&lt; (vs-&gt;Properties.lp)) - 1;
+  int lc = vs-&gt;Properties.lc;
+  int len = vs-&gt;RemainLen;
+  UInt32 globalPos = vs-&gt;GlobalPos;
+  UInt32 distanceLimit = vs-&gt;DistanceLimit;
+
+  unsigned char *dictionary = vs-&gt;Dictionary;
+  UInt32 dictionarySize = vs-&gt;Properties.DictionarySize;
+  UInt32 dictionaryPos = vs-&gt;DictionaryPos;
+
+  unsigned char tempDictionary[4];
+
+  (*inSizeProcessed) = 0;
+  (*outSizeProcessed) = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs-&gt;TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    while (inSize &gt; 0 &amp;&amp; BufferSize &lt; kLzmaInBufferSize)
+    {
+      Buffer[BufferSize++] = *inStream++;
+      (*inSizeProcessed)++;
+      inSize--;
+    }
+    if (BufferSize &lt; 5)
+    {
+      vs-&gt;BufferSize = BufferSize;
+      return finishDecoding ? LZMA_RESULT_DATA_ERROR : LZMA_RESULT_OK;
+    }
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE &lt;&lt; (lc + vs-&gt;Properties.lp));
+      UInt32 i;
+      for (i = 0; i &lt; numProbs; i++)
+        p[i] = kBitModelTotal &gt;&gt; 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      RC_INIT;
+    }
+    len = 0;
+  }
+  while(len != 0 &amp;&amp; nowPos &lt; outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos &gt;= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  while(1)
+  {
+    int bufferPos = (int)(Buffer - vs-&gt;Buffer);
+    if (BufferSize - bufferPos &lt; kRequiredInBufferSize)
+    {
+      int i;
+      BufferSize -= bufferPos;
+      if (BufferSize &lt; 0)
+        return LZMA_RESULT_DATA_ERROR;
+      for (i = 0; i &lt; BufferSize; i++)
+        vs-&gt;Buffer[i] = Buffer[i];
+      Buffer = vs-&gt;Buffer;
+      while (inSize &gt; 0 &amp;&amp; BufferSize &lt; kLzmaInBufferSize)
+      {
+        Buffer[BufferSize++] = *inStream++;
+        (*inSizeProcessed)++;
+        inSize--;
+      }
+      if (BufferSize &lt; kRequiredInBufferSize &amp;&amp; !finishDecoding)
+        break;
+    }
+    if (nowPos &gt;= outSize)
+      break;
+    {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)((nowPos + globalPos) &amp; posStateMask);
+
+    prob = p + IsMatch + (state &lt;&lt; kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        ((((nowPos + globalPos)&amp; literalPosMask) &lt;&lt; lc) + (previousByte &gt;&gt; (8 - lc))));
+
+      if (state &gt;= kNumLitStates)
+      {
+        int matchByte;
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos &gt;= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte &lt;&lt;= 1;
+          bit = (matchByte &amp; 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol &lt; 0x100);
+      }
+      while (symbol &lt; 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (unsigned char)symbol;
+
+      outStream[nowPos++] = previousByte;
+      if (distanceLimit &lt; dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      if (state &lt; 4) state = 0;
+      else if (state &lt; 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state &lt; kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state &lt;&lt; kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            UInt32 pos;
+            UpdateBit0(prob);
+            if (distanceLimit == 0)
+              return LZMA_RESULT_DATA_ERROR;
+            if (distanceLimit &lt; dictionarySize)
+              distanceLimit++;
+            state = state &lt; kNumLitStates ? 9 : 11;
+            pos = dictionaryPos - rep0;
+            if (pos &gt;= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            outStream[nowPos++] = previousByte;
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state &lt; kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState &lt;&lt; kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState &lt;&lt; kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state &lt; 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len &lt; kNumLenToPosStates ? len : kNumLenToPosStates - 1) &lt;&lt; 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot &gt;= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot &gt;&gt; 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot &amp; 1));
+          if (posSlot &lt; kEndPosModelIndex)
+          {
+            rep0 &lt;&lt;= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range &gt;&gt;= 1;
+              rep0 &lt;&lt;= 1;
+              if (Code &gt;= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 &lt;&lt;= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i &lt;&lt;= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      if (rep0 &gt; distanceLimit) 
+        return LZMA_RESULT_DATA_ERROR;
+      if (dictionarySize - distanceLimit &gt; (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+
+      do
+      {
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos &gt;= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 &amp;&amp; nowPos &lt; outSize);
+    }
+    }
+  }
+  RC_NORMALIZE;
+
+  BufferSize -= (int)(Buffer - vs-&gt;Buffer);
+  if (BufferSize &lt; 0)
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    int i;
+    for (i = 0; i &lt; BufferSize; i++)
+      vs-&gt;Buffer[i] = Buffer[i];
+  }
+  vs-&gt;BufferSize = BufferSize;
+  vs-&gt;Range = Range;
+  vs-&gt;Code = Code;
+  vs-&gt;DictionaryPos = dictionaryPos;
+  vs-&gt;GlobalPos = (UInt32)(globalPos + nowPos);
+  vs-&gt;DistanceLimit = distanceLimit;
+  vs-&gt;Reps[0] = rep0;
+  vs-&gt;Reps[1] = rep1;
+  vs-&gt;Reps[2] = rep2;
+  vs-&gt;Reps[3] = rep3;
+  vs-&gt;State = state;
+  vs-&gt;RemainLen = len;
+  vs-&gt;TempDictionary[0] = tempDictionary[0];
+
+  (*outSizeProcessed) = nowPos;
+  return LZMA_RESULT_OK;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,96 @@
+/* 
+  LzmaStateDecode.h
+  LZMA Decoder interface (State version)
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  <A HREF="http://www.7-zip.org/">http://www.7-zip.org/</A>
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMASTATEDECODE_H
+#define __LZMASTATEDECODE_H
+
+#include &quot;LzmaTypes.h&quot;
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  UInt32 DictionarySize;
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(lzmaProps) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE &lt;&lt; ((lzmaProps)-&gt;lc + (lzmaProps)-&gt;lp)))
+
+#define kLzmaInBufferSize 64   /* don't change it. it must be larger than kRequiredInBufferSize */
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+  unsigned char *Dictionary;
+
+  unsigned char Buffer[kLzmaInBufferSize];
+  int BufferSize;
+
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;  /* -2: decoder needs internal initialization
+                     -1: stream was finished, 
+                      0: ok
+                    &gt; 0: need to write RemainLen bytes as match Reps[0],
+                  */
+  unsigned char TempDictionary[4];  /* it's required when DictionarySize = 0 */
+} CLzmaDecoderState;
+
+#define LzmaDecoderInit(vs) { (vs)-&gt;RemainLen = kLzmaNeedInitId; (vs)-&gt;BufferSize = 0; }
+
+/* LzmaDecode: decoding from input stream to output stream.
+  If finishDecoding != 0, then there are no more bytes in input stream
+  after inStream[inSize - 1]. */
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    const unsigned char *inStream, SizeT inSize,  SizeT *inSizeProcessed,
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed,
+    int finishDecoding);
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateDecode.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateTest.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateTest.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateTest.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,195 @@
+/* 
+LzmaStateTest.c
+Test application for LZMA Decoder (State version)
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.26 (2005-08-02)
+*/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;LzmaStateDecode.h&quot;
+
+const char *kCantReadMessage = &quot;Can not read input file&quot;;
+const char *kCantWriteMessage = &quot;Can not write output file&quot;;
+const char *kCantAllocateMessage = &quot;Can not allocate memory&quot;;
+
+#define kInBufferSize (1 &lt;&lt; 15)
+#define kOutBufferSize (1 &lt;&lt; 15)
+
+unsigned char g_InBuffer[kInBufferSize];
+unsigned char g_OutBuffer[kOutBufferSize];
+
+size_t MyReadFile(FILE *file, void *data, size_t size)
+  { return fread(data, 1, size, file); }
+
+int MyReadFileAndCheck(FILE *file, void *data, size_t size)
+  { return (MyReadFile(file, data, size) == size); }
+
+int PrintError(char *buffer, const char *message)
+{
+  sprintf(buffer + strlen(buffer), &quot;\nError: &quot;);
+  sprintf(buffer + strlen(buffer), message);
+  return 1;
+}
+
+int main3(FILE *inFile, FILE *outFile, char *rs)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need &gt;= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0; 
+  
+  int waitEOS = 1; 
+  /* waitEOS = 1, if there is no uncompressed size in headers, 
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+
+  int i;
+  int res = 0;
+  CLzmaDecoderState state;  /* it's about 140 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+  SizeT inAvail = 0;
+  unsigned char *inBuffer = 0;
+
+  if (sizeof(UInt32) &lt; 4)
+    return PrintError(rs, &quot;LZMA decoder needs correct UInt32&quot;);
+
+  /* Read LZMA properties for compressed stream */
+
+  if (!MyReadFileAndCheck(inFile, properties, sizeof(properties)))
+    return PrintError(rs, kCantReadMessage);
+
+  /* Read uncompressed size */
+  
+  for (i = 0; i &lt; 8; i++)
+  {
+    unsigned char b;
+    if (!MyReadFileAndCheck(inFile, &amp;b, 1))
+      return PrintError(rs, kCantReadMessage);
+    if (b != 0xFF)
+      waitEOS = 0;
+    if (i &lt; 4)
+      outSize += (UInt32)(b) &lt;&lt; (i * 8);
+    else
+      outSizeHigh += (UInt32)(b) &lt;&lt; ((i - 4) * 8);
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  
+  if (LzmaDecodeProperties(&amp;state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+    return PrintError(rs, &quot;Incorrect stream properties&quot;);
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&amp;state.Properties) * sizeof(CProb));
+  if (state.Probs == 0)
+    return PrintError(rs, kCantAllocateMessage);
+  
+  if (state.Properties.DictionarySize == 0)
+    state.Dictionary = 0;
+  else
+  {
+    state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+    if (state.Dictionary == 0)
+    {
+      free(state.Probs);
+      return PrintError(rs, kCantAllocateMessage);
+    }
+  }
+  
+  /* Decompress */
+  
+  LzmaDecoderInit(&amp;state);
+  
+  do
+  {
+    SizeT inProcessed, outProcessed;
+    int finishDecoding;
+    UInt32 outAvail = kOutBufferSize;
+    if (!waitEOS &amp;&amp; outSizeHigh == 0 &amp;&amp; outAvail &gt; outSize)
+      outAvail = outSize;
+    if (inAvail == 0)
+    {
+      inAvail = (SizeT)MyReadFile(inFile, g_InBuffer, kInBufferSize);
+      inBuffer = g_InBuffer;
+    }
+    finishDecoding = (inAvail == 0);
+    res = LzmaDecode(&amp;state,
+        inBuffer, inAvail, &amp;inProcessed,
+        g_OutBuffer, outAvail, &amp;outProcessed,
+        finishDecoding);
+    if (res != 0)
+    {
+      sprintf(rs + strlen(rs), &quot;\nDecoding error = %d\n&quot;, res);
+      res = 1;
+      break;
+    }
+    inAvail -= inProcessed;
+    inBuffer += inProcessed;
+    
+    if (outFile != 0)  
+      if (fwrite(g_OutBuffer, 1, outProcessed, outFile) != outProcessed)
+      {
+        PrintError(rs, kCantWriteMessage);
+        res = 1;
+        break;
+      }
+      
+    if (outSize &lt; outProcessed)
+      outSizeHigh--;
+    outSize -= (UInt32)outProcessed;
+    outSize &amp;= 0xFFFFFFFF;
+
+    if (outProcessed == 0 &amp;&amp; finishDecoding)
+    {
+      if (!waitEOS &amp;&amp; (outSize != 0 || outSizeHigh != 0))
+        res = 1;
+      break;
+    }
+  }
+  while ((outSize != 0 &amp;&amp; outSizeHigh == 0) || outSizeHigh != 0  || waitEOS);
+
+  free(state.Dictionary);
+  free(state.Probs);
+  return res;
+}
+
+int main2(int numArgs, const char *args[], char *rs)
+{
+  FILE *inFile = 0;
+  FILE *outFile = 0;
+  int res;
+
+  sprintf(rs + strlen(rs), &quot;\nLZMA Decoder 4.26 Copyright (c) 1999-2005 Igor Pavlov  2005-08-02\n&quot;);
+  if (numArgs &lt; 2 || numArgs &gt; 3)
+  {
+    sprintf(rs + strlen(rs), &quot;\nUsage:  lzmadec file.lzma [outFile]\n&quot;);
+    return 1;
+  }
+
+  inFile = fopen(args[1], &quot;rb&quot;);
+  if (inFile == 0)
+    return PrintError(rs, &quot;Can not open input file&quot;);
+
+  if (numArgs &gt; 2)
+  {
+    outFile = fopen(args[2], &quot;wb+&quot;);
+    if (outFile == 0)
+      return PrintError(rs, &quot;Can not open output file&quot;);
+  }
+
+  res = main3(inFile, outFile, rs);
+
+  if (outFile != 0)
+    fclose(outFile);
+  fclose(inFile);
+  return res;
+}
+
+int main(int numArgs, const char *args[])
+{
+  char rs[800] = { 0 };
+  int res = main2(numArgs, args, rs);
+  printf(rs);
+  return res;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaStateTest.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTest.c
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTest.c	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTest.c	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,342 @@
+/* 
+LzmaTest.c
+Test application for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.26 (2005-08-05)
+*/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;LzmaDecode.h&quot;
+
+const char *kCantReadMessage = &quot;Can not read input file&quot;;
+const char *kCantWriteMessage = &quot;Can not write output file&quot;;
+const char *kCantAllocateMessage = &quot;Can not allocate memory&quot;;
+
+size_t MyReadFile(FILE *file, void *data, size_t size)
+{ 
+  if (size == 0)
+    return 0;
+  return fread(data, 1, size, file); 
+}
+
+int MyReadFileAndCheck(FILE *file, void *data, size_t size)
+  { return (MyReadFile(file, data, size) == size);} 
+
+size_t MyWriteFile(FILE *file, const void *data, size_t size)
+{ 
+  if (size == 0)
+    return 0;
+  return fwrite(data, 1, size, file); 
+}
+
+int MyWriteFileAndCheck(FILE *file, const void *data, size_t size)
+  { return (MyWriteFile(file, data, size) == size); }
+
+#ifdef _LZMA_IN_CB
+#define kInBufferSize (1 &lt;&lt; 15)
+typedef struct _CBuffer
+{
+  ILzmaInCallback InCallback;
+  FILE *File;
+  unsigned char Buffer[kInBufferSize];
+} CBuffer;
+
+int LzmaReadCompressed(void *object, const unsigned char **buffer, SizeT *size)
+{
+  CBuffer *b = (CBuffer *)object;
+  *buffer = b-&gt;Buffer;
+  *size = (SizeT)MyReadFile(b-&gt;File, b-&gt;Buffer, kInBufferSize);
+  return LZMA_RESULT_OK;
+}
+CBuffer g_InBuffer;
+
+#endif
+
+#ifdef _LZMA_OUT_READ
+#define kOutBufferSize (1 &lt;&lt; 15)
+unsigned char g_OutBuffer[kOutBufferSize];
+#endif
+
+int PrintError(char *buffer, const char *message)
+{
+  sprintf(buffer + strlen(buffer), &quot;\nError: &quot;);
+  sprintf(buffer + strlen(buffer), message);
+  return 1;
+}
+
+int main3(FILE *inFile, FILE *outFile, char *rs)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need &gt;= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0;
+  #ifndef _LZMA_OUT_READ
+  SizeT outSizeFull;
+  unsigned char *outStream;
+  #endif
+  
+  int waitEOS = 1; 
+  /* waitEOS = 1, if there is no uncompressed size in headers, 
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+
+  #ifndef _LZMA_IN_CB
+  SizeT compressedSize;
+  unsigned char *inStream;
+  #endif
+
+  CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+  int res;
+
+  #ifdef _LZMA_IN_CB
+  g_InBuffer.File = inFile;
+  #endif
+
+  if (sizeof(UInt32) &lt; 4)
+    return PrintError(rs, &quot;LZMA decoder needs correct UInt32&quot;);
+
+  #ifndef _LZMA_IN_CB
+  {
+    long length;
+    fseek(inFile, 0, SEEK_END);
+    length = ftell(inFile);
+    fseek(inFile, 0, SEEK_SET);
+    if ((long)(SizeT)length != length)
+      return PrintError(rs, &quot;Too big compressed stream&quot;);
+    compressedSize = (SizeT)(length - (LZMA_PROPERTIES_SIZE + 8));
+  }
+  #endif
+
+  /* Read LZMA properties for compressed stream */
+
+  if (!MyReadFileAndCheck(inFile, properties, sizeof(properties)))
+    return PrintError(rs, kCantReadMessage);
+
+  /* Read uncompressed size */
+
+  {
+    int i;
+    for (i = 0; i &lt; 8; i++)
+    {
+      unsigned char b;
+      if (!MyReadFileAndCheck(inFile, &amp;b, 1))
+        return PrintError(rs, kCantReadMessage);
+      if (b != 0xFF)
+        waitEOS = 0;
+      if (i &lt; 4)
+        outSize += (UInt32)(b) &lt;&lt; (i * 8);
+      else
+        outSizeHigh += (UInt32)(b) &lt;&lt; ((i - 4) * 8);
+    }
+    
+    #ifndef _LZMA_OUT_READ
+    if (waitEOS)
+      return PrintError(rs, &quot;Stream with EOS marker is not supported&quot;);
+    outSizeFull = (SizeT)outSize;
+    if (sizeof(SizeT) &gt;= 8)
+      outSizeFull |= (((SizeT)outSizeHigh &lt;&lt; 16) &lt;&lt; 16);
+    else if (outSizeHigh != 0 || (UInt32)(SizeT)outSize != outSize)
+      return PrintError(rs, &quot;Too big uncompressed stream&quot;);
+    #endif
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  
+  if (LzmaDecodeProperties(&amp;state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+    return PrintError(rs, &quot;Incorrect stream properties&quot;);
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&amp;state.Properties) * sizeof(CProb));
+
+  #ifdef _LZMA_OUT_READ
+  if (state.Properties.DictionarySize == 0)
+    state.Dictionary = 0;
+  else
+    state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+  #else
+  if (outSizeFull == 0)
+    outStream = 0;
+  else
+    outStream = (unsigned char *)malloc(outSizeFull);
+  #endif
+
+  #ifndef _LZMA_IN_CB
+  if (compressedSize == 0)
+    inStream = 0;
+  else
+    inStream = (unsigned char *)malloc(compressedSize);
+  #endif
+
+  if (state.Probs == 0 
+    #ifdef _LZMA_OUT_READ
+    || (state.Dictionary == 0 &amp;&amp; state.Properties.DictionarySize != 0)
+    #else
+    || (outStream == 0 &amp;&amp; outSizeFull != 0)
+    #endif
+    #ifndef _LZMA_IN_CB
+    || (inStream == 0 &amp;&amp; compressedSize != 0)
+    #endif
+    )
+  {
+    free(state.Probs);
+    #ifdef _LZMA_OUT_READ
+    free(state.Dictionary);
+    #else
+    free(outStream);
+    #endif
+    #ifndef _LZMA_IN_CB
+    free(inStream);
+    #endif
+    return PrintError(rs, kCantAllocateMessage);
+  }
+
+  /* Decompress */
+
+  #ifdef _LZMA_IN_CB
+  g_InBuffer.InCallback.Read = LzmaReadCompressed;
+  #else
+  if (!MyReadFileAndCheck(inFile, inStream, compressedSize))
+    return PrintError(rs, kCantReadMessage);
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  {
+    #ifndef _LZMA_IN_CB
+    SizeT inAvail = compressedSize;
+    const unsigned char *inBuffer = inStream;
+    #endif
+    LzmaDecoderInit(&amp;state);
+    do
+    {
+      #ifndef _LZMA_IN_CB
+      SizeT inProcessed;
+      #endif
+      SizeT outProcessed;
+      SizeT outAvail = kOutBufferSize;
+      if (!waitEOS &amp;&amp; outSizeHigh == 0 &amp;&amp; outAvail &gt; outSize)
+        outAvail = (SizeT)outSize;
+      res = LzmaDecode(&amp;state,
+        #ifdef _LZMA_IN_CB
+        &amp;g_InBuffer.InCallback,
+        #else
+        inBuffer, inAvail, &amp;inProcessed,
+        #endif
+        g_OutBuffer, outAvail, &amp;outProcessed);
+      if (res != 0)
+      {
+        sprintf(rs + strlen(rs), &quot;\nDecoding error = %d\n&quot;, res);
+        res = 1;
+        break;
+      }
+      #ifndef _LZMA_IN_CB
+      inAvail -= inProcessed;
+      inBuffer += inProcessed;
+      #endif
+      
+      if (outFile != 0)  
+        if (!MyWriteFileAndCheck(outFile, g_OutBuffer, (size_t)outProcessed))
+        {
+          PrintError(rs, kCantWriteMessage);
+          res = 1;
+          break;
+        }
+        
+      if (outSize &lt; outProcessed)
+        outSizeHigh--;
+      outSize -= (UInt32)outProcessed;
+      outSize &amp;= 0xFFFFFFFF;
+        
+      if (outProcessed == 0)
+      {
+        if (!waitEOS &amp;&amp; (outSize != 0 || outSizeHigh != 0))
+          res = 1;
+        break;
+      }
+    }
+    while ((outSize != 0 &amp;&amp; outSizeHigh == 0) || outSizeHigh != 0  || waitEOS);
+  }
+
+  #else
+  {
+    #ifndef _LZMA_IN_CB
+    SizeT inProcessed;
+    #endif
+    SizeT outProcessed;
+    res = LzmaDecode(&amp;state,
+      #ifdef _LZMA_IN_CB
+      &amp;g_InBuffer.InCallback,
+      #else
+      inStream, compressedSize, &amp;inProcessed,
+      #endif
+      outStream, outSizeFull, &amp;outProcessed);
+    if (res != 0)
+    {
+      sprintf(rs + strlen(rs), &quot;\nDecoding error = %d\n&quot;, res);
+      res = 1;
+    }
+    else if (outFile != 0)
+    {
+      if (!MyWriteFileAndCheck(outFile, outStream, (size_t)outProcessed))
+      {
+        PrintError(rs, kCantWriteMessage);
+        res = 1;
+      }
+    }
+  }
+  #endif
+
+  free(state.Probs);
+  #ifdef _LZMA_OUT_READ
+  free(state.Dictionary);
+  #else
+  free(outStream);
+  #endif
+  #ifndef _LZMA_IN_CB
+  free(inStream);
+  #endif
+  return res;
+}
+
+int main2(int numArgs, const char *args[], char *rs)
+{
+  FILE *inFile = 0;
+  FILE *outFile = 0;
+  int res;
+
+  sprintf(rs + strlen(rs), &quot;\nLZMA Decoder 4.26 Copyright (c) 1999-2005 Igor Pavlov  2005-08-05\n&quot;);
+  if (numArgs &lt; 2 || numArgs &gt; 3)
+  {
+    sprintf(rs + strlen(rs), &quot;\nUsage:  lzmadec file.lzma [outFile]\n&quot;);
+    return 1;
+  }
+
+  inFile = fopen(args[1], &quot;rb&quot;);
+  if (inFile == 0)
+    return PrintError(rs, &quot;Can not open input file&quot;);
+
+  if (numArgs &gt; 2)
+  {
+    outFile = fopen(args[2], &quot;wb+&quot;);
+    if (outFile == 0)
+      return PrintError(rs, &quot;Can not open output file&quot;);
+  }
+
+  res = main3(inFile, outFile, rs);
+
+  if (outFile != 0)
+    fclose(outFile);
+  fclose(inFile);
+  return res;
+}
+
+int main(int numArgs, const char *args[])
+{
+  char rs[800] = { 0 };
+  int res = main2(numArgs, args, rs);
+  printf(rs);
+  return res;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTest.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTypes.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTypes.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTypes.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include &lt;stddef.h&gt;
+typedef size_t SizeT;
+#else
+typedef UInt32 SizeT;
+#endif
+#endif
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/LzmaTypes.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,43 @@
+PROG = lzmaDec.exe
+
+!IFNDEF O
+!IFDEF CPU
+O=$(CPU)
+!ELSE
+O=O
+!ENDIF
+!ENDIF
+
+CFLAGS = $(CFLAGS) -nologo -c -Fo$O/ -GS- 
+CFLAGS_O1 = $(CFLAGS) -O1
+CFLAGS_O2 = $(CFLAGS) -O2
+
+LFLAGS = $(LFLAGS) -nologo -OPT:NOWIN98
+
+PROGPATH = $O\$(PROG)
+
+COMPL_O1   = $(CPP) $(CFLAGS_O1) $**
+COMPL_O2   = $(CPP) $(CFLAGS_O2) $**
+COMPL      = $(CPP) $(CFLAGS_O1) $**
+
+
+OBJS = \
+  $O\LzmaTest.obj \
+  $O\LzmaDecode.obj \
+
+all: $(PROGPATH) 
+
+clean:
+	-del /Q $(PROGPATH) $O\*.exe $O\*.dll $O\*.obj $O\*.lib $O\*.exp $O\*.res $O\*.pch 
+
+$O:
+	if not exist &quot;$O&quot; mkdir &quot;$O&quot;
+
+$(PROGPATH): $O $(OBJS)
+	link $(LFLAGS) -out:$(PROGPATH) $(OBJS) $(LIBS)
+
+
+$O\LzmaTest.obj: $(*B).c
+	$(COMPL)
+$O\LzmaDecode.obj: ../../Compress/LZMA_C/$(*B).c
+	$(COMPL_O2)


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile.gcc
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile.gcc	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile.gcc	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,23 @@
+PROG = lzmadec
+CXX = gcc 
+LIB = 
+RM = rm -f
+CFLAGS = -c -O2 -Wall -pedantic -D _LZMA_PROB32 
+
+OBJS = LzmaTest.o LzmaDecode.o 
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB)
+
+LzmaTest.o: LzmaTest.c
+	$(CXX) $(CFLAGS) LzmaTest.c
+
+LzmaDecode.o: LzmaDecode.c
+	$(CXX) $(CFLAGS) LzmaDecode.c
+
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/LZMA_C/makefile.gcc
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoder.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoder.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoder.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,205 @@
+// Compress/RangeCoder/RangeCoder.h
+
+#ifndef __COMPRESS_RANGECODER_H
+#define __COMPRESS_RANGECODER_H
+
+#include &quot;../../Common/InBuffer.h&quot;
+#include &quot;../../Common/OutBuffer.h&quot;
+
+namespace NCompress {
+namespace NRangeCoder {
+
+const int kNumTopBits = 24;
+const UInt32 kTopValue = (1 &lt;&lt; kNumTopBits);
+
+class CEncoder
+{
+  UInt32 _cacheSize;
+  Byte _cache;
+public:
+  UInt64 Low;
+  UInt32 Range;
+  COutBuffer Stream;
+  bool Create(UInt32 bufferSize) { return Stream.Create(bufferSize); }
+
+  void SetStream(ISequentialOutStream *stream) { Stream.SetStream(stream); }
+  void Init()
+  {
+    Stream.Init();
+    Low = 0;
+    Range = 0xFFFFFFFF;
+    _cacheSize = 1;
+    _cache = 0;
+  }
+
+  void FlushData()
+  {
+    // Low += 1; 
+    for(int i = 0; i &lt; 5; i++)
+      ShiftLow();
+  }
+
+  HRESULT FlushStream() { return Stream.Flush();  }
+
+  void ReleaseStream() { Stream.ReleaseStream(); }
+
+  void Encode(UInt32 start, UInt32 size, UInt32 total)
+  {
+    Low += start * (Range /= total);
+    Range *= size;
+    while (Range &lt; kTopValue)
+    {
+      Range &lt;&lt;= 8;
+      ShiftLow();
+    }
+  }
+
+  void ShiftLow()
+  {
+    if ((UInt32)Low &lt; (UInt32)0xFF000000 || (int)(Low &gt;&gt; 32) != 0) 
+    {
+      Byte temp = _cache;
+      do
+      {
+        Stream.WriteByte((Byte)(temp + (Byte)(Low &gt;&gt; 32)));
+        temp = 0xFF;
+      }
+      while(--_cacheSize != 0);
+      _cache = (Byte)((UInt32)Low &gt;&gt; 24);                      
+    } 
+    _cacheSize++;                               
+    Low = (UInt32)Low &lt;&lt; 8;                           
+  }
+  
+  void EncodeDirectBits(UInt32 value, int numTotalBits)
+  {
+    for (int i = numTotalBits - 1; i &gt;= 0; i--)
+    {
+      Range &gt;&gt;= 1;
+      if (((value &gt;&gt; i) &amp; 1) == 1)
+        Low += Range;
+      if (Range &lt; kTopValue)
+      {
+        Range &lt;&lt;= 8;
+        ShiftLow();
+      }
+    }
+  }
+
+  void EncodeBit(UInt32 size0, UInt32 numTotalBits, UInt32 symbol)
+  {
+    UInt32 newBound = (Range &gt;&gt; numTotalBits) * size0;
+    if (symbol == 0)
+      Range = newBound;
+    else
+    {
+      Low += newBound;
+      Range -= newBound;
+    }
+    while (Range &lt; kTopValue)
+    {
+      Range &lt;&lt;= 8;
+      ShiftLow();
+    }
+  }
+
+  UInt64 GetProcessedSize() {  return Stream.GetProcessedSize() + _cacheSize + 4; }
+};
+
+class CDecoder
+{
+public:
+  CInBuffer Stream;
+  UInt32 Range;
+  UInt32 Code;
+  bool Create(UInt32 bufferSize) { return Stream.Create(bufferSize); }
+
+  void Normalize()
+  {
+    while (Range &lt; kTopValue)
+    {
+      Code = (Code &lt;&lt; 8) | Stream.ReadByte();
+      Range &lt;&lt;= 8;
+    }
+  }
+  
+  void SetStream(ISequentialInStream *stream) { Stream.SetStream(stream); }
+  void Init()
+  {
+    Stream.Init();
+    Code = 0;
+    Range = 0xFFFFFFFF;
+    for(int i = 0; i &lt; 5; i++)
+      Code = (Code &lt;&lt; 8) | Stream.ReadByte();
+  }
+
+  void ReleaseStream() { Stream.ReleaseStream(); }
+
+  UInt32 GetThreshold(UInt32 total)
+  {
+    return (Code) / ( Range /= total);
+  }
+
+  void Decode(UInt32 start, UInt32 size)
+  {
+    Code -= start * Range;
+    Range *= size;
+    Normalize();
+  }
+
+  UInt32 DecodeDirectBits(int numTotalBits)
+  {
+    UInt32 range = Range;
+    UInt32 code = Code;        
+    UInt32 result = 0;
+    for (int i = numTotalBits; i != 0; i--)
+    {
+      range &gt;&gt;= 1;
+      /*
+      result &lt;&lt;= 1;
+      if (code &gt;= range)
+      {
+        code -= range;
+        result |= 1;
+      }
+      */
+      UInt32 t = (code - range) &gt;&gt; 31;
+      code -= range &amp; (t - 1);
+      result = (result &lt;&lt; 1) | (1 - t);
+
+      if (range &lt; kTopValue)
+      {
+        code = (code &lt;&lt; 8) | Stream.ReadByte();
+        range &lt;&lt;= 8; 
+      }
+    }
+    Range = range;
+    Code = code;
+    return result;
+  }
+
+  UInt32 DecodeBit(UInt32 size0, UInt32 numTotalBits)
+  {
+    UInt32 newBound = (Range &gt;&gt; numTotalBits) * size0;
+    UInt32 symbol;
+    if (Code &lt; newBound)
+    {
+      symbol = 0;
+      Range = newBound;
+    }
+    else
+    {
+      symbol = 1;
+      Code -= newBound;
+      Range -= newBound;
+    }
+    Normalize();
+    return symbol;
+  }
+
+  UInt64 GetProcessedSize() {return Stream.GetProcessedSize(); }
+};
+
+}}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoder.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,80 @@
+// Compress/RangeCoder/RangeCoderBit.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;RangeCoderBit.h&quot;
+
+namespace NCompress {
+namespace NRangeCoder {
+
+UInt32 CPriceTables::ProbPrices[kBitModelTotal &gt;&gt; kNumMoveReducingBits];
+static CPriceTables g_PriceTables;
+
+CPriceTables::CPriceTables() { Init(); }
+
+void CPriceTables::Init()
+{
+  const int kNumBits = (kNumBitModelTotalBits - kNumMoveReducingBits);
+  for(int i = kNumBits - 1; i &gt;= 0; i--)
+  {
+    UInt32 start = 1 &lt;&lt; (kNumBits - i - 1);
+    UInt32 end = 1 &lt;&lt; (kNumBits - i);
+    for (UInt32 j = start; j &lt; end; j++)
+      ProbPrices[j] = (i &lt;&lt; kNumBitPriceShiftBits) + 
+          (((end - j) &lt;&lt; kNumBitPriceShiftBits) &gt;&gt; (kNumBits - i - 1));
+  }
+
+  /*
+  // simplest: bad solution
+  for(UInt32 i = 1; i &lt; (kBitModelTotal &gt;&gt; kNumMoveReducingBits) - 1; i++)
+    ProbPrices[i] = kBitPrice;
+  */
+  
+  /*
+  const double kDummyMultMid = (1.0 / kBitPrice) / 2;
+  const double kDummyMultMid = 0;
+  // float solution
+  double ln2 = log(double(2));
+  double lnAll = log(double(kBitModelTotal &gt;&gt; kNumMoveReducingBits));
+  for(UInt32 i = 1; i &lt; (kBitModelTotal &gt;&gt; kNumMoveReducingBits) - 1; i++)
+    ProbPrices[i] = UInt32((fabs(lnAll - log(double(i))) / ln2 + kDummyMultMid) * kBitPrice);
+  */
+  
+  /*
+  // experimental, slow, solution:
+  for(UInt32 i = 1; i &lt; (kBitModelTotal &gt;&gt; kNumMoveReducingBits) - 1; i++)
+  {
+    const int kCyclesBits = 5;
+    const UInt32 kCycles = (1 &lt;&lt; kCyclesBits);
+
+    UInt32 range = UInt32(-1);
+    UInt32 bitCount = 0;
+    for (UInt32 j = 0; j &lt; kCycles; j++)
+    {
+      range &gt;&gt;= (kNumBitModelTotalBits - kNumMoveReducingBits);
+      range *= i;
+      while(range &lt; (1 &lt;&lt; 31))
+      {
+        range &lt;&lt;= 1;
+        bitCount++;
+      }
+    }
+    bitCount &lt;&lt;= kNumBitPriceShiftBits;
+    range -= (1 &lt;&lt; 31);
+    for (int k = kNumBitPriceShiftBits - 1; k &gt;= 0; k--)
+    {
+      range &lt;&lt;= 1;
+      if (range &gt; (1 &lt;&lt; 31))
+      {
+        bitCount += (1 &lt;&lt; k);
+        range -= (1 &lt;&lt; 31);
+      }
+    }
+    ProbPrices[i] = (bitCount 
+      // + (1 &lt;&lt; (kCyclesBits - 1))
+      ) &gt;&gt; kCyclesBits;
+  }
+  */
+}
+
+}}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,120 @@
+// Compress/RangeCoder/RangeCoderBit.h
+
+#ifndef __COMPRESS_RANGECODER_BIT_H
+#define __COMPRESS_RANGECODER_BIT_H
+
+#include &quot;RangeCoder.h&quot;
+
+namespace NCompress {
+namespace NRangeCoder {
+
+const int kNumBitModelTotalBits  = 11;
+const UInt32 kBitModelTotal = (1 &lt;&lt; kNumBitModelTotalBits);
+
+const int kNumMoveReducingBits = 2;
+
+const int kNumBitPriceShiftBits = 6;
+const UInt32 kBitPrice = 1 &lt;&lt; kNumBitPriceShiftBits;
+
+class CPriceTables
+{
+public:
+  static UInt32 ProbPrices[kBitModelTotal &gt;&gt; kNumMoveReducingBits];
+  static void Init();
+  CPriceTables();
+};
+
+template &lt;int numMoveBits&gt;
+class CBitModel
+{
+public:
+  UInt32 Prob;
+  void UpdateModel(UInt32 symbol)
+  {
+    /*
+    Prob -= (Prob + ((symbol - 1) &amp; ((1 &lt;&lt; numMoveBits) - 1))) &gt;&gt; numMoveBits;
+    Prob += (1 - symbol) &lt;&lt; (kNumBitModelTotalBits - numMoveBits);
+    */
+    if (symbol == 0)
+      Prob += (kBitModelTotal - Prob) &gt;&gt; numMoveBits;
+    else
+      Prob -= (Prob) &gt;&gt; numMoveBits;
+  }
+public:
+  void Init() { Prob = kBitModelTotal / 2; }
+};
+
+template &lt;int numMoveBits&gt;
+class CBitEncoder: public CBitModel&lt;numMoveBits&gt;
+{
+public:
+  void Encode(CEncoder *encoder, UInt32 symbol)
+  {
+    /*
+    encoder-&gt;EncodeBit(this-&gt;Prob, kNumBitModelTotalBits, symbol);
+    this-&gt;UpdateModel(symbol);
+    */
+    UInt32 newBound = (encoder-&gt;Range &gt;&gt; kNumBitModelTotalBits) * this-&gt;Prob;
+    if (symbol == 0)
+    {
+      encoder-&gt;Range = newBound;
+      this-&gt;Prob += (kBitModelTotal - this-&gt;Prob) &gt;&gt; numMoveBits;
+    }
+    else
+    {
+      encoder-&gt;Low += newBound;
+      encoder-&gt;Range -= newBound;
+      this-&gt;Prob -= (this-&gt;Prob) &gt;&gt; numMoveBits;
+    }
+    if (encoder-&gt;Range &lt; kTopValue)
+    {
+      encoder-&gt;Range &lt;&lt;= 8;
+      encoder-&gt;ShiftLow();
+    }
+  }
+  UInt32 GetPrice(UInt32 symbol) const
+  {
+    return CPriceTables::ProbPrices[
+      (((this-&gt;Prob - symbol) ^ ((-(int)symbol))) &amp; (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits];
+  }
+  UInt32 GetPrice0() const { return CPriceTables::ProbPrices[this-&gt;Prob &gt;&gt; kNumMoveReducingBits]; }
+  UInt32 GetPrice1() const { return CPriceTables::ProbPrices[(kBitModelTotal - this-&gt;Prob) &gt;&gt; kNumMoveReducingBits]; }
+};
+
+
+template &lt;int numMoveBits&gt;
+class CBitDecoder: public CBitModel&lt;numMoveBits&gt;
+{
+public:
+  UInt32 Decode(CDecoder *decoder)
+  {
+    UInt32 newBound = (decoder-&gt;Range &gt;&gt; kNumBitModelTotalBits) * this-&gt;Prob;
+    if (decoder-&gt;Code &lt; newBound)
+    {
+      decoder-&gt;Range = newBound;
+      this-&gt;Prob += (kBitModelTotal - this-&gt;Prob) &gt;&gt; numMoveBits;
+      if (decoder-&gt;Range &lt; kTopValue)
+      {
+        decoder-&gt;Code = (decoder-&gt;Code &lt;&lt; 8) | decoder-&gt;Stream.ReadByte();
+        decoder-&gt;Range &lt;&lt;= 8;
+      }
+      return 0;
+    }
+    else
+    {
+      decoder-&gt;Range -= newBound;
+      decoder-&gt;Code -= newBound;
+      this-&gt;Prob -= (this-&gt;Prob) &gt;&gt; numMoveBits;
+      if (decoder-&gt;Range &lt; kTopValue)
+      {
+        decoder-&gt;Code = (decoder-&gt;Code &lt;&lt; 8) | decoder-&gt;Stream.ReadByte();
+        decoder-&gt;Range &lt;&lt;= 8;
+      }
+      return 1;
+    }
+  }
+};
+
+}}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBit.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,161 @@
+// Compress/RangeCoder/RangeCoderBitTree.h
+
+#ifndef __COMPRESS_RANGECODER_BIT_TREE_H
+#define __COMPRESS_RANGECODER_BIT_TREE_H
+
+#include &quot;RangeCoderBit.h&quot;
+#include &quot;RangeCoderOpt.h&quot;
+
+namespace NCompress {
+namespace NRangeCoder {
+
+template &lt;int numMoveBits, int NumBitLevels&gt;
+class CBitTreeEncoder
+{
+  CBitEncoder&lt;numMoveBits&gt; Models[1 &lt;&lt; NumBitLevels];
+public:
+  void Init()
+  {
+    for(UInt32 i = 1; i &lt; (1 &lt;&lt; NumBitLevels); i++)
+      Models[i].Init();
+  }
+  void Encode(CEncoder *rangeEncoder, UInt32 symbol)
+  {
+    UInt32 modelIndex = 1;
+    for (int bitIndex = NumBitLevels; bitIndex != 0 ;)
+    {
+      bitIndex--;
+      UInt32 bit = (symbol &gt;&gt; bitIndex) &amp; 1;
+      Models[modelIndex].Encode(rangeEncoder, bit);
+      modelIndex = (modelIndex &lt;&lt; 1) | bit;
+    }
+  };
+  void ReverseEncode(CEncoder *rangeEncoder, UInt32 symbol)
+  {
+    UInt32 modelIndex = 1;
+    for (int i = 0; i &lt; NumBitLevels; i++)
+    {
+      UInt32 bit = symbol &amp; 1;
+      Models[modelIndex].Encode(rangeEncoder, bit);
+      modelIndex = (modelIndex &lt;&lt; 1) | bit;
+      symbol &gt;&gt;= 1;
+    }
+  }
+  UInt32 GetPrice(UInt32 symbol) const
+  {
+    symbol |= (1 &lt;&lt; NumBitLevels);
+    UInt32 price = 0;
+    while (symbol != 1)
+    {
+      price += Models[symbol &gt;&gt; 1].GetPrice(symbol &amp; 1);
+      symbol &gt;&gt;= 1;
+    }
+    return price;
+  }
+  UInt32 ReverseGetPrice(UInt32 symbol) const
+  {
+    UInt32 price = 0;
+    UInt32 modelIndex = 1;
+    for (int i = NumBitLevels; i != 0; i--)
+    {
+      UInt32 bit = symbol &amp; 1;
+      symbol &gt;&gt;= 1;
+      price += Models[modelIndex].GetPrice(bit);
+      modelIndex = (modelIndex &lt;&lt; 1) | bit;
+    }
+    return price;
+  }
+};
+
+template &lt;int numMoveBits, int NumBitLevels&gt;
+class CBitTreeDecoder
+{
+  CBitDecoder&lt;numMoveBits&gt; Models[1 &lt;&lt; NumBitLevels];
+public:
+  void Init()
+  {
+    for(UInt32 i = 1; i &lt; (1 &lt;&lt; NumBitLevels); i++)
+      Models[i].Init();
+  }
+  UInt32 Decode(CDecoder *rangeDecoder)
+  {
+    UInt32 modelIndex = 1;
+    RC_INIT_VAR
+    for(int bitIndex = NumBitLevels; bitIndex != 0; bitIndex--)
+    {
+      // modelIndex = (modelIndex &lt;&lt; 1) + Models[modelIndex].Decode(rangeDecoder);
+      RC_GETBIT(numMoveBits, Models[modelIndex].Prob, modelIndex)
+    }
+    RC_FLUSH_VAR
+    return modelIndex - (1 &lt;&lt; NumBitLevels);
+  };
+  UInt32 ReverseDecode(CDecoder *rangeDecoder)
+  {
+    UInt32 modelIndex = 1;
+    UInt32 symbol = 0;
+    RC_INIT_VAR
+    for(int bitIndex = 0; bitIndex &lt; NumBitLevels; bitIndex++)
+    {
+      // UInt32 bit = Models[modelIndex].Decode(rangeDecoder);
+      // modelIndex &lt;&lt;= 1;
+      // modelIndex += bit;
+      // symbol |= (bit &lt;&lt; bitIndex);
+      RC_GETBIT2(numMoveBits, Models[modelIndex].Prob, modelIndex, ; , symbol |= (1 &lt;&lt; bitIndex))
+    }
+    RC_FLUSH_VAR
+    return symbol;
+  }
+};
+
+template &lt;int numMoveBits&gt;
+void ReverseBitTreeEncode(CBitEncoder&lt;numMoveBits&gt; *Models, 
+    CEncoder *rangeEncoder, int NumBitLevels, UInt32 symbol)
+{
+  UInt32 modelIndex = 1;
+  for (int i = 0; i &lt; NumBitLevels; i++)
+  {
+    UInt32 bit = symbol &amp; 1;
+    Models[modelIndex].Encode(rangeEncoder, bit);
+    modelIndex = (modelIndex &lt;&lt; 1) | bit;
+    symbol &gt;&gt;= 1;
+  }
+}
+
+template &lt;int numMoveBits&gt;
+UInt32 ReverseBitTreeGetPrice(CBitEncoder&lt;numMoveBits&gt; *Models, 
+    UInt32 NumBitLevels, UInt32 symbol)
+{
+  UInt32 price = 0;
+  UInt32 modelIndex = 1;
+  for (int i = NumBitLevels; i != 0; i--)
+  {
+    UInt32 bit = symbol &amp; 1;
+    symbol &gt;&gt;= 1;
+    price += Models[modelIndex].GetPrice(bit);
+    modelIndex = (modelIndex &lt;&lt; 1) | bit;
+  }
+  return price;
+}
+
+template &lt;int numMoveBits&gt;
+UInt32 ReverseBitTreeDecode(CBitDecoder&lt;numMoveBits&gt; *Models, 
+    CDecoder *rangeDecoder, int NumBitLevels)
+{
+  UInt32 modelIndex = 1;
+  UInt32 symbol = 0;
+  RC_INIT_VAR
+  for(int bitIndex = 0; bitIndex &lt; NumBitLevels; bitIndex++)
+  {
+    // UInt32 bit = Models[modelIndex].Decode(rangeDecoder);
+    // modelIndex &lt;&lt;= 1;
+    // modelIndex += bit;
+    // symbol |= (bit &lt;&lt; bitIndex);
+    RC_GETBIT2(numMoveBits, Models[modelIndex].Prob, modelIndex, ; , symbol |= (1 &lt;&lt; bitIndex))
+  }
+  RC_FLUSH_VAR
+  return symbol;
+}
+
+}}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderOpt.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderOpt.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderOpt.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,31 @@
+// Compress/RangeCoder/RangeCoderOpt.h
+
+#ifndef __COMPRESS_RANGECODER_OPT_H
+#define __COMPRESS_RANGECODER_OPT_H
+
+#define RC_INIT_VAR \
+  UInt32 range = rangeDecoder-&gt;Range; \
+  UInt32 code = rangeDecoder-&gt;Code;        
+
+#define RC_FLUSH_VAR \
+  rangeDecoder-&gt;Range = range; \
+  rangeDecoder-&gt;Code = code;
+
+#define RC_NORMALIZE \
+  if (range &lt; NCompress::NRangeCoder::kTopValue) \
+    { code = (code &lt;&lt; 8) | rangeDecoder-&gt;Stream.ReadByte(); range &lt;&lt;= 8; }
+
+#define RC_GETBIT2(numMoveBits, prob, mi, A0, A1) \
+  { UInt32 bound = (range &gt;&gt; NCompress::NRangeCoder::kNumBitModelTotalBits) * prob; \
+  if (code &lt; bound) \
+  { A0; range = bound; \
+    prob += (NCompress::NRangeCoder::kBitModelTotal - prob) &gt;&gt; numMoveBits; \
+    mi &lt;&lt;= 1; } \
+  else \
+  { A1; range -= bound; code -= bound; prob -= (prob) &gt;&gt; numMoveBits; \
+    mi = (mi + mi) + 1; }} \
+  RC_NORMALIZE
+
+#define RC_GETBIT(numMoveBits, prob, mi) RC_GETBIT2(numMoveBits, prob, mi, ; , ;)
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/RangeCoderOpt.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/StdAfx.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/StdAfx.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/StdAfx.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,6 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/Compress/RangeCoder/StdAfx.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/ICoder.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/ICoder.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/ICoder.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,163 @@
+// ICoder.h
+
+#ifndef __ICODER_H
+#define __ICODER_H
+
+#include &quot;IStream.h&quot;
+
+// &quot;23170F69-40C1-278A-0000-000400xx0000&quot;
+#define CODER_INTERFACE(i, x) \
+DEFINE_GUID(IID_ ## i, \
+0x23170F69, 0x40C1, 0x278A, 0x00, 0x00, 0x00, 0x04, 0x00, x, 0x00, 0x00); \
+struct i: public IUnknown
+
+CODER_INTERFACE(ICompressProgressInfo, 0x04)
+{
+  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize) PURE;
+};
+
+CODER_INTERFACE(ICompressCoder, 0x05)
+{
+  STDMETHOD(Code)(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, 
+      const UInt64 *outSize,
+      ICompressProgressInfo *progress) PURE;
+};
+
+CODER_INTERFACE(ICompressCoder2, 0x18)
+{
+  STDMETHOD(Code)(ISequentialInStream **inStreams,
+      const UInt64 **inSizes, 
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams, 
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress) PURE;
+};
+
+namespace NCoderPropID
+{
+  enum EEnum
+  {
+    kDictionarySize = 0x400,
+    kUsedMemorySize,
+    kOrder,
+    kPosStateBits = 0x440,
+    kLitContextBits,
+    kLitPosBits,
+    kNumFastBytes = 0x450,
+    kMatchFinder,
+    kMatchFinderCycles,
+    kNumPasses = 0x460, 
+    kAlgorithm = 0x470,
+    kMultiThread = 0x480,
+    kNumThreads,
+    kEndMarker = 0x490
+  };
+}
+
+CODER_INTERFACE(ICompressSetCoderProperties, 0x20)
+{
+  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, 
+      const PROPVARIANT *properties, UInt32 numProperties) PURE;
+};
+
+/*
+CODER_INTERFACE(ICompressSetCoderProperties, 0x21)
+{
+  STDMETHOD(SetDecoderProperties)(ISequentialInStream *inStream) PURE;
+};
+*/
+
+CODER_INTERFACE(ICompressSetDecoderProperties2, 0x22)
+{
+  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size) PURE;
+};
+
+CODER_INTERFACE(ICompressWriteCoderProperties, 0x23)
+{
+  STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStreams) PURE;
+};
+
+CODER_INTERFACE(ICompressGetInStreamProcessedSize, 0x24)
+{
+  STDMETHOD(GetInStreamProcessedSize)(UInt64 *value) PURE;
+};
+
+CODER_INTERFACE(ICompressSetCoderMt, 0x25)
+{
+  STDMETHOD(SetNumberOfThreads)(UInt32 numThreads) PURE;
+};
+
+CODER_INTERFACE(ICompressGetSubStreamSize, 0x30)
+{
+  STDMETHOD(GetSubStreamSize)(UInt64 subStream, UInt64 *value) PURE;
+};
+
+CODER_INTERFACE(ICompressSetInStream, 0x31)
+{
+  STDMETHOD(SetInStream)(ISequentialInStream *inStream) PURE;
+  STDMETHOD(ReleaseInStream)() PURE;
+};
+
+CODER_INTERFACE(ICompressSetOutStream, 0x32)
+{
+  STDMETHOD(SetOutStream)(ISequentialOutStream *outStream) PURE;
+  STDMETHOD(ReleaseOutStream)() PURE;
+};
+
+CODER_INTERFACE(ICompressSetInStreamSize, 0x33)
+{
+  STDMETHOD(SetInStreamSize)(const UInt64 *inSize) PURE;
+};
+
+CODER_INTERFACE(ICompressSetOutStreamSize, 0x34)
+{
+  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize) PURE;
+};
+
+CODER_INTERFACE(ICompressFilter, 0x40)
+{
+  STDMETHOD(Init)() PURE;
+  STDMETHOD_(UInt32, Filter)(Byte *data, UInt32 size) PURE;
+  // Filter return outSize (UInt32)
+  // if (outSize &lt;= size): Filter have converted outSize bytes
+  // if (outSize &gt; size): Filter have not converted anything.
+  //      and it needs at least outSize bytes to convert one block 
+  //      (it's for crypto block algorithms).
+};
+
+CODER_INTERFACE(ICryptoProperties, 0x80)
+{
+  STDMETHOD(SetKey)(const Byte *data, UInt32 size) PURE;
+  STDMETHOD(SetInitVector)(const Byte *data, UInt32 size) PURE;
+};
+
+CODER_INTERFACE(ICryptoSetPassword, 0x90)
+{
+  STDMETHOD(CryptoSetPassword)(const Byte *data, UInt32 size) PURE;
+};
+
+CODER_INTERFACE(ICryptoSetCRC, 0xA0)
+{
+  STDMETHOD(CryptoSetCRC)(UInt32 crc) PURE;
+};
+
+//////////////////////
+// It's for DLL file
+namespace NMethodPropID
+{
+  enum EEnum
+  {
+    kID,
+    kName,
+    kDecoder,
+    kEncoder,
+    kInStreams,
+    kOutStreams,
+    kDescription
+  };
+}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/ICoder.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/IStream.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/IStream.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/IStream.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,62 @@
+// IStream.h
+
+#ifndef __ISTREAM_H
+#define __ISTREAM_H
+
+#include &quot;../Common/MyUnknown.h&quot;
+#include &quot;../Common/Types.h&quot;
+
+// &quot;23170F69-40C1-278A-0000-000300xx0000&quot;
+
+#define STREAM_INTERFACE_SUB(i, b, x) \
+DEFINE_GUID(IID_ ## i, \
+0x23170F69, 0x40C1, 0x278A, 0x00, 0x00, 0x00, 0x03, 0x00, x, 0x00, 0x00); \
+struct i: public b
+
+#define STREAM_INTERFACE(i, x) STREAM_INTERFACE_SUB(i, IUnknown, x)
+
+STREAM_INTERFACE(ISequentialInStream, 0x01)
+{
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize) PURE;
+  /*
+  Out: if size != 0, return_value = S_OK and (*processedSize == 0),
+    then there are no more bytes in stream.
+  if (size &gt; 0) &amp;&amp; there are bytes in stream, 
+  this function must read at least 1 byte.
+  This function is allowed to read less than number of remaining bytes in stream.
+  You must call Read function in loop, if you need exact amount of data
+  */
+};
+
+STREAM_INTERFACE(ISequentialOutStream, 0x02)
+{
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize) PURE;
+  /*
+  if (size &gt; 0) this function must write at least 1 byte.
+  This function is allowed to write less than &quot;size&quot;.
+  You must call Write function in loop, if you need to write exact amount of data
+  */
+};
+
+STREAM_INTERFACE_SUB(IInStream, ISequentialInStream, 0x03)
+{
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition) PURE;
+};
+
+STREAM_INTERFACE_SUB(IOutStream, ISequentialOutStream, 0x04)
+{
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition) PURE;
+  STDMETHOD(SetSize)(Int64 newSize) PURE;
+};
+
+STREAM_INTERFACE(IStreamGetSize, 0x06)
+{
+  STDMETHOD(GetSize)(UInt64 *size) PURE;
+};
+
+STREAM_INTERFACE(IOutStreamFlush, 0x07)
+{
+  STDMETHOD(Flush)() PURE;
+};
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/7zip/IStream.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,118 @@
+// Common/Alloc.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#ifdef _WIN32
+#include &quot;MyWindows.h&quot;
+#else
+#include &lt;stdlib.h&gt;
+#endif
+
+#include &quot;Alloc.h&quot;
+
+/* #define _SZ_ALLOC_DEBUG */
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+#ifdef _SZ_ALLOC_DEBUG
+#include &lt;stdio.h&gt;
+int g_allocCount = 0;
+int g_allocCountMid = 0;
+int g_allocCountBig = 0;
+#endif
+
+void *MyAlloc(size_t size) throw()
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc %10d bytes; count = %10d&quot;, size, g_allocCount++);
+  #endif
+  return ::malloc(size);
+}
+
+void MyFree(void *address) throw()
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, &quot;\nFree; count = %10d&quot;, --g_allocCount);
+  #endif
+  
+  ::free(address);
+}
+
+#ifdef _WIN32
+
+void *MidAlloc(size_t size) throw()
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc_Mid %10d bytes;  count = %10d&quot;, size, g_allocCountMid++);
+  #endif
+  return ::VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void MidFree(void *address) throw()
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, &quot;\nFree_Mid; count = %10d&quot;, --g_allocCountMid);
+  #endif
+  if (address == 0)
+    return;
+  ::VirtualFree(address, 0, MEM_RELEASE);
+}
+
+static SIZE_T g_LargePageSize = 
+    #ifdef _WIN64
+    (1 &lt;&lt; 21);
+    #else
+    (1 &lt;&lt; 22);
+    #endif
+
+typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
+
+bool SetLargePageSize()
+{
+  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
+        ::GetProcAddress(::GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;GetLargePageMinimum&quot;);
+  if (largePageMinimum == 0)
+    return false;
+  SIZE_T size = largePageMinimum();
+  if (size == 0 || (size &amp; (size - 1)) != 0)
+    return false;
+  g_LargePageSize = size;
+  return true;
+}
+
+
+void *BigAlloc(size_t size) throw()
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, &quot;\nAlloc_Big %10d bytes;  count = %10d&quot;, size, g_allocCountBig++);
+  #endif
+  
+  if (size &gt;= (1 &lt;&lt; 18))
+  {
+    void *res = ::VirtualAlloc(0, (size + g_LargePageSize - 1) &amp; (~(g_LargePageSize - 1)), 
+        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
+    if (res != 0)
+      return res;
+  }
+  return ::VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void BigFree(void *address) throw()
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, &quot;\nFree_Big; count = %10d&quot;, --g_allocCountBig);
+  #endif
+  
+  if (address == 0)
+    return;
+  ::VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,29 @@
+// Common/Alloc.h
+
+#ifndef __COMMON_ALLOC_H
+#define __COMMON_ALLOC_H
+
+#include &lt;stddef.h&gt;
+
+void *MyAlloc(size_t size) throw();
+void MyFree(void *address) throw();
+
+#ifdef _WIN32
+
+bool SetLargePageSize();
+
+void *MidAlloc(size_t size) throw();
+void MidFree(void *address) throw();
+void *BigAlloc(size_t size) throw();
+void BigFree(void *address) throw();
+
+#else
+
+#define MidAlloc(size) MyAlloc(size)
+#define MidFree(address) MyFree(address)
+#define BigAlloc(size) MyAlloc(size)
+#define BigFree(address) MyFree(address)
+
+#endif
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Alloc.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,61 @@
+// Common/CRC.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;CRC.h&quot;
+
+static const UInt32 kCRCPoly = 0xEDB88320;
+
+UInt32 CCRC::Table[256];
+
+void CCRC::InitTable()
+{
+  for (UInt32 i = 0; i &lt; 256; i++)
+  {
+    UInt32 r = i;
+    for (int j = 0; j &lt; 8; j++)
+      if (r &amp; 1) 
+        r = (r &gt;&gt; 1) ^ kCRCPoly;
+      else     
+        r &gt;&gt;= 1;
+    CCRC::Table[i] = r;
+  }
+}
+
+class CCRCTableInit
+{
+public:
+  CCRCTableInit() { CCRC::InitTable(); }
+} g_CRCTableInit;
+
+void CCRC::UpdateByte(Byte b)
+{
+  _value = Table[((Byte)(_value)) ^ b] ^ (_value &gt;&gt; 8);
+}
+
+void CCRC::UpdateUInt16(UInt16 v)
+{
+  UpdateByte(Byte(v));
+  UpdateByte(Byte(v &gt;&gt; 8));
+}
+
+void CCRC::UpdateUInt32(UInt32 v)
+{
+  for (int i = 0; i &lt; 4; i++)
+    UpdateByte((Byte)(v &gt;&gt; (8 * i)));
+}
+
+void CCRC::UpdateUInt64(UInt64 v)
+{
+  for (int i = 0; i &lt; 8; i++)
+    UpdateByte((Byte)(v &gt;&gt; (8 * i)));
+}
+
+void CCRC::Update(const void *data, size_t size)
+{
+  UInt32 v = _value;
+  const Byte *p = (const Byte *)data;
+  for (; size &gt; 0 ; size--, p++)
+    v = Table[((Byte)(v)) ^ *p] ^ (v &gt;&gt; 8);
+  _value = v;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,36 @@
+// Common/CRC.h
+
+#ifndef __COMMON_CRC_H
+#define __COMMON_CRC_H
+
+#include &lt;stddef.h&gt;
+#include &quot;Types.h&quot;
+
+class CCRC
+{
+  UInt32 _value;
+public:
+	static UInt32 Table[256];
+	static void InitTable();
+
+  CCRC():  _value(0xFFFFFFFF){};
+  void Init() { _value = 0xFFFFFFFF; }
+  void UpdateByte(Byte v);
+  void UpdateUInt16(UInt16 v);
+  void UpdateUInt32(UInt32 v);
+  void UpdateUInt64(UInt64 v);
+  void Update(const void *data, size_t size);
+  UInt32 GetDigest() const { return _value ^ 0xFFFFFFFF; } 
+  static UInt32 CalculateDigest(const void *data, size_t size)
+  {
+    CCRC crc;
+    crc.Update(data, size);
+    return crc.GetDigest();
+  }
+  static bool VerifyDigest(UInt32 digest, const void *data, size_t size)
+  {
+    return (CalculateDigest(data, size) == digest);
+  }
+};
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CRC.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,78 @@
+// Common/C_FileIO.h
+
+#include &quot;C_FileIO.h&quot;
+
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+
+namespace NC {
+namespace NFile {
+namespace NIO {
+
+bool CFileBase::OpenBinary(const char *name, int flags)
+{
+  #ifdef O_BINARY
+  flags |= O_BINARY;
+  #endif
+  Close();
+  _handle = ::open(name, flags, 0666);
+  return _handle != -1;
+}
+
+bool CFileBase::Close()
+{
+  if(_handle == -1)
+    return true;
+  if (close(_handle) != 0)
+    return false;
+  _handle = -1;
+  return true;
+}
+
+bool CFileBase::GetLength(UInt64 &amp;length) const
+{
+  off_t curPos = Seek(0, SEEK_CUR);
+  off_t lengthTemp = Seek(0, SEEK_END);
+  Seek(curPos, SEEK_SET);
+  length = (UInt64)lengthTemp;
+  return true;
+}
+
+off_t CFileBase::Seek(off_t distanceToMove, int moveMethod) const
+{
+  return ::lseek(_handle, distanceToMove, moveMethod);
+}
+
+/////////////////////////
+// CInFile
+
+bool CInFile::Open(const char *name)
+{
+  return CFileBase::OpenBinary(name, O_RDONLY);
+}
+
+ssize_t CInFile::Read(void *data, size_t size)
+{
+  return read(_handle, data, size);
+}
+
+/////////////////////////
+// COutFile
+
+bool COutFile::Create(const char *name, bool createAlways)
+{
+  if (createAlways)
+  {
+    Close();
+    _handle = ::creat(name, 0666);
+    return _handle != -1;
+  }
+  return OpenBinary(name, O_CREAT | O_EXCL | O_WRONLY);
+}
+
+ssize_t COutFile::Write(const void *data, size_t size)
+{
+  return write(_handle, data, size);
+}
+
+}}}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,45 @@
+// Common/C_FileIO.h
+
+#ifndef __COMMON_C_FILEIO_H
+#define __COMMON_C_FILEIO_H
+
+#include &lt;stdio.h&gt;
+#include &lt;sys/types.h&gt;
+
+#include &quot;Types.h&quot;
+#include &quot;MyWindows.h&quot;
+
+namespace NC {
+namespace NFile {
+namespace NIO {
+
+class CFileBase
+{
+protected:
+  int _handle;
+  bool OpenBinary(const char *name, int flags);
+public:
+  CFileBase(): _handle(-1) {};
+  ~CFileBase() { Close(); }
+  bool Close();
+  bool GetLength(UInt64 &amp;length) const;
+  off_t Seek(off_t distanceToMove, int moveMethod) const;
+};
+
+class CInFile: public CFileBase
+{
+public:
+  bool Open(const char *name);
+  ssize_t Read(void *data, size_t size);
+};
+
+class COutFile: public CFileBase
+{
+public:
+  bool Create(const char *name, bool createAlways);
+  ssize_t Write(const void *data, size_t size);
+};
+
+}}}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/C_FileIO.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/ComTry.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/ComTry.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/ComTry.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,17 @@
+// ComTry.h
+
+#ifndef __COM_TRY_H
+#define __COM_TRY_H
+
+#include &quot;MyWindows.h&quot;
+// #include &quot;Exception.h&quot;
+// #include &quot;NewHandler.h&quot;
+
+#define COM_TRY_BEGIN try {
+#define COM_TRY_END } catch(...) { return E_OUTOFMEMORY; }
+  
+  // catch(const CNewException &amp;) { return E_OUTOFMEMORY; }\
+  // catch(const CSystemException &amp;e) { return e.ErrorCode; }\
+  // catch(...) { return E_FAIL; }
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/ComTry.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,232 @@
+// CommandLineParser.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;CommandLineParser.h&quot;
+
+namespace NCommandLineParser {
+
+void SplitCommandLine(const UString &amp;src, UString &amp;dest1, UString &amp;dest2)
+{
+  dest1.Empty();
+  dest2.Empty();
+  bool quoteMode = false;
+  int i;
+  for (i = 0; i &lt; src.Length(); i++)
+  {
+    wchar_t c = src[i];
+    if (c == L'\&quot;')
+      quoteMode = !quoteMode;
+    else if (c == L' ' &amp;&amp; !quoteMode)
+    {
+      i++;
+      break;
+    }
+    else 
+      dest1 += c;
+  }
+  dest2 = src.Mid(i);
+}
+
+void SplitCommandLine(const UString &amp;s, UStringVector &amp;parts)
+{
+  UString sTemp = s;
+  sTemp.Trim();
+  parts.Clear();
+  while (true)
+  {
+    UString s1, s2;
+    SplitCommandLine(sTemp, s1, s2);
+    // s1.Trim();
+    // s2.Trim();
+    if (!s1.IsEmpty())
+      parts.Add(s1);
+    if (s2.IsEmpty())
+      return;
+    sTemp = s2;
+  }
+}
+
+
+static const wchar_t kSwitchID1 = '-';
+// static const wchar_t kSwitchID2 = '/';
+
+static const wchar_t kSwitchMinus = '-';
+static const wchar_t *kStopSwitchParsing = L&quot;--&quot;;
+
+static bool IsItSwitchChar(wchar_t c)
+{ 
+  return (c == kSwitchID1 /*|| c == kSwitchID2 */); 
+}
+
+CParser::CParser(int numSwitches):
+  _numSwitches(numSwitches)
+{
+  _switches = new CSwitchResult[_numSwitches];
+}
+
+CParser::~CParser()
+{
+  delete []_switches;
+}
+
+void CParser::ParseStrings(const CSwitchForm *switchForms, 
+  const UStringVector &amp;commandStrings)
+{
+  int numCommandStrings = commandStrings.Size();
+  bool stopSwitch = false;
+  for (int i = 0; i &lt; numCommandStrings; i++)
+  {
+    const UString &amp;s = commandStrings[i];
+    if (stopSwitch)
+      NonSwitchStrings.Add(s);
+    else
+      if (s == kStopSwitchParsing)
+        stopSwitch = true;
+      else
+        if (!ParseString(s, switchForms))
+          NonSwitchStrings.Add(s);
+  }
+}
+
+// if string contains switch then function updates switch structures
+// out: (string is a switch)
+bool CParser::ParseString(const UString &amp;s, const CSwitchForm *switchForms)
+{
+  int len = s.Length();
+  if (len == 0) 
+    return false;
+  int pos = 0;
+  if (!IsItSwitchChar(s[pos]))
+    return false;
+  while(pos &lt; len)
+  {
+    if (IsItSwitchChar(s[pos]))
+      pos++;
+    const int kNoLen = -1;
+    int matchedSwitchIndex = 0; // GCC Warning
+    int maxLen = kNoLen;
+    for(int switchIndex = 0; switchIndex &lt; _numSwitches; switchIndex++)
+    {
+      int switchLen = MyStringLen(switchForms[switchIndex].IDString);
+      if (switchLen &lt;= maxLen || pos + switchLen &gt; len) 
+        continue;
+
+      UString temp = s + pos;
+      temp = temp.Left(switchLen);
+      if(temp.CompareNoCase(switchForms[switchIndex].IDString) == 0)
+      // if(_strnicmp(switchForms[switchIndex].IDString, LPCSTR(s) + pos, switchLen) == 0)
+      {
+        matchedSwitchIndex = switchIndex;
+        maxLen = switchLen;
+      }
+    }
+    if (maxLen == kNoLen)
+      throw &quot;maxLen == kNoLen&quot;;
+    CSwitchResult &amp;matchedSwitch = _switches[matchedSwitchIndex];
+    const CSwitchForm &amp;switchForm = switchForms[matchedSwitchIndex];
+    if ((!switchForm.Multi) &amp;&amp; matchedSwitch.ThereIs)
+      throw &quot;switch must be single&quot;;
+    matchedSwitch.ThereIs = true;
+    pos += maxLen;
+    int tailSize = len - pos;
+    NSwitchType::EEnum type = switchForm.Type;
+    switch(type)
+    {
+      case NSwitchType::kPostMinus:
+        {
+          if (tailSize == 0)
+            matchedSwitch.WithMinus = false;
+          else
+          {
+            matchedSwitch.WithMinus = (s[pos] == kSwitchMinus);
+            if (matchedSwitch.WithMinus)
+              pos++;
+          }
+          break;
+        }
+      case NSwitchType::kPostChar:
+        {
+          if (tailSize &lt; switchForm.MinLen)
+            throw &quot;switch is not full&quot;;
+          UString set = switchForm.PostCharSet;
+          const int kEmptyCharValue = -1;
+          if (tailSize == 0)
+            matchedSwitch.PostCharIndex = kEmptyCharValue;
+          else
+          {
+            int index = set.Find(s[pos]);
+            if (index &lt; 0)
+              matchedSwitch.PostCharIndex =  kEmptyCharValue;
+            else
+            {
+              matchedSwitch.PostCharIndex = index;
+              pos++;
+            }
+          }
+          break;
+        }
+      case NSwitchType::kLimitedPostString: 
+      case NSwitchType::kUnLimitedPostString: 
+        {
+          int minLen = switchForm.MinLen;
+          if (tailSize &lt; minLen)
+            throw &quot;switch is not full&quot;;
+          if (type == NSwitchType::kUnLimitedPostString)
+          {
+            matchedSwitch.PostStrings.Add(s.Mid(pos));
+            return true;
+          }
+          int maxLen = switchForm.MaxLen;
+          UString stringSwitch = s.Mid(pos, minLen);
+          pos += minLen;
+          for(int i = minLen; i &lt; maxLen &amp;&amp; pos &lt; len; i++, pos++)
+          {
+            wchar_t c = s[pos];
+            if (IsItSwitchChar(c))
+              break;
+            stringSwitch += c;
+          }
+          matchedSwitch.PostStrings.Add(stringSwitch);
+          break;
+        }
+      case NSwitchType::kSimple:
+          break;
+    }
+  }
+  return true;
+}
+
+const CSwitchResult&amp; CParser::operator[](size_t index) const
+{
+  return _switches[index];
+}
+
+/////////////////////////////////
+// Command parsing procedures
+
+int ParseCommand(int numCommandForms, const CCommandForm *commandForms, 
+    const UString &amp;commandString, UString &amp;postString)
+{
+  for(int i = 0; i &lt; numCommandForms; i++)
+  {
+    const UString id = commandForms[i].IDString;
+    if (commandForms[i].PostStringMode)
+    {
+      if(commandString.Find(id) == 0)
+      {
+        postString = commandString.Mid(id.Length());
+        return i;
+      }
+    }
+    else
+      if (commandString == id)
+      {
+        postString.Empty();
+        return i;
+      }
+  }
+  return -1;
+}
+   
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,72 @@
+// Common/CommandLineParser.h
+
+#ifndef __COMMON_COMMANDLINEPARSER_H
+#define __COMMON_COMMANDLINEPARSER_H
+
+#include &quot;Common/String.h&quot;
+
+namespace NCommandLineParser {
+
+void SplitCommandLine(const UString &amp;src, UString &amp;dest1, UString &amp;dest2);
+void SplitCommandLine(const UString &amp;s, UStringVector &amp;parts);
+
+namespace NSwitchType {
+  enum EEnum
+  { 
+    kSimple,
+    kPostMinus,
+    kLimitedPostString,
+    kUnLimitedPostString,
+    kPostChar
+  };
+}
+
+struct CSwitchForm
+{
+  const wchar_t *IDString;
+  NSwitchType::EEnum Type;
+  bool Multi;
+  int MinLen;
+  int MaxLen;
+  const wchar_t *PostCharSet;
+};
+
+struct CSwitchResult
+{
+  bool ThereIs;
+  bool WithMinus;
+  UStringVector PostStrings;
+  int PostCharIndex;
+  CSwitchResult(): ThereIs(false) {};
+};
+  
+class CParser
+{
+  int _numSwitches;
+  CSwitchResult *_switches;
+  bool ParseString(const UString &amp;s, const CSwitchForm *switchForms); 
+public:
+  UStringVector NonSwitchStrings;
+  CParser(int numSwitches);
+  ~CParser();
+  void ParseStrings(const CSwitchForm *switchForms, 
+    const UStringVector &amp;commandStrings);
+  const CSwitchResult&amp; operator[](size_t index) const;
+};
+
+/////////////////////////////////
+// Command parsing procedures
+
+struct CCommandForm
+{
+  wchar_t *IDString;
+  bool PostStringMode;
+};
+
+// Returns: Index of form and postString; -1, if there is no match
+int ParseCommand(int numCommandForms, const CCommandForm *commandForms, 
+    const UString &amp;commandString, UString &amp;postString);
+
+}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/CommandLineParser.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Defs.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Defs.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Defs.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,20 @@
+// Common/Defs.h
+
+#ifndef __COMMON_DEFS_H
+#define __COMMON_DEFS_H
+
+template &lt;class T&gt; inline T MyMin(T a, T b)
+  {  return a &lt; b ? a : b; }
+template &lt;class T&gt; inline T MyMax(T a, T b)
+  {  return a &gt; b ? a : b; }
+
+template &lt;class T&gt; inline int MyCompare(T a, T b)
+  {  return a &lt; b ? -1 : (a == b ? 0 : 1); }
+
+inline int BoolToInt(bool value)
+  { return (value ? 1: 0); }
+
+inline bool IntToBool(int value)
+  { return (value != 0); }
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Defs.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyCom.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyCom.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyCom.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,203 @@
+// MyCom.h
+
+#ifndef __MYCOM_H
+#define __MYCOM_H
+
+#include &quot;MyWindows.h&quot;
+
+#define RINOK(x) { HRESULT __result_ = (x); if(__result_ != S_OK) return __result_; }
+
+template &lt;class T&gt;
+class CMyComPtr
+{
+  T* _p;
+public:
+  // typedef T _PtrClass;
+  CMyComPtr() { _p = NULL;}
+  CMyComPtr(T* p) {if ((_p = p) != NULL) p-&gt;AddRef(); }
+  CMyComPtr(const CMyComPtr&lt;T&gt;&amp; lp)
+  {
+    if ((_p = lp._p) != NULL)
+      _p-&gt;AddRef();
+  }
+  ~CMyComPtr() { if (_p) _p-&gt;Release(); }
+  void Release() { if (_p) { _p-&gt;Release(); _p = NULL; } }
+  operator T*() const {  return (T*)_p;  }
+  // T&amp; operator*() const {  return *_p; }
+  T** operator&amp;() { return &amp;_p; }
+  T* operator-&gt;() const { return _p; }
+  T* operator=(T* p) 
+  { 
+    if (p != 0)
+      p-&gt;AddRef();
+    if (_p) 
+      _p-&gt;Release();
+    _p = p;
+    return p;
+  }
+  T* operator=(const CMyComPtr&lt;T&gt;&amp; lp) { return (*this = lp._p); }
+  bool operator!() const { return (_p == NULL); }
+  // bool operator==(T* pT) const {  return _p == pT; }
+  // Compare two objects for equivalence
+  void Attach(T* p2)
+  {
+    Release();
+    _p = p2;
+  }
+  T* Detach()
+  {
+    T* pt = _p;
+    _p = NULL;
+    return pt;
+  }
+  #ifdef _WIN32
+  HRESULT CoCreateInstance(REFCLSID rclsid, REFIID iid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
+  {
+    return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, iid, (void**)&amp;_p);
+  }
+  #endif
+  /*
+  HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
+  {
+    CLSID clsid;
+    HRESULT hr = CLSIDFromProgID(szProgID, &amp;clsid);
+    ATLASSERT(_p == NULL);
+    if (SUCCEEDED(hr))
+      hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&amp;_p);
+    return hr;
+  }
+  */
+  template &lt;class Q&gt;
+  HRESULT QueryInterface(REFGUID iid, Q** pp) const
+  {
+    return _p-&gt;QueryInterface(iid, (void**)pp);
+  }
+};
+
+//////////////////////////////////////////////////////////
+
+class CMyComBSTR
+{
+public:
+  BSTR m_str;
+  CMyComBSTR() { m_str = NULL; }
+  CMyComBSTR(LPCOLESTR pSrc) {  m_str = ::SysAllocString(pSrc);  }
+  // CMyComBSTR(int nSize) { m_str = ::SysAllocStringLen(NULL, nSize); }
+  // CMyComBSTR(int nSize, LPCOLESTR sz) { m_str = ::SysAllocStringLen(sz, nSize);  }
+  CMyComBSTR(const CMyComBSTR&amp; src) { m_str = src.MyCopy(); }
+  /*
+  CMyComBSTR(REFGUID src)
+  {
+    LPOLESTR szGuid;
+    StringFromCLSID(src, &amp;szGuid);
+    m_str = ::SysAllocString(szGuid);
+    CoTaskMemFree(szGuid);
+  }
+  */
+  ~CMyComBSTR() { ::SysFreeString(m_str); }
+  CMyComBSTR&amp; operator=(const CMyComBSTR&amp; src)
+  {
+    if (m_str != src.m_str)
+    {
+      if (m_str)
+        ::SysFreeString(m_str);
+      m_str = src.MyCopy();
+    }
+    return *this;
+  }
+  CMyComBSTR&amp; operator=(LPCOLESTR pSrc)
+  {
+    ::SysFreeString(m_str);
+    m_str = ::SysAllocString(pSrc);
+    return *this;
+  }
+  unsigned int Length() const { return ::SysStringLen(m_str); }
+  operator BSTR() const { return m_str; }
+  BSTR* operator&amp;() { return &amp;m_str; }
+  BSTR MyCopy() const 
+  { 
+    int byteLen = ::SysStringByteLen(m_str);
+    BSTR res = ::SysAllocStringByteLen(NULL, byteLen);
+    memmove(res, m_str, byteLen);
+    return res;
+  }
+  void Attach(BSTR src) {  m_str = src; }
+  BSTR Detach()
+  {
+    BSTR s = m_str;
+    m_str = NULL;
+    return s;
+  }
+  void Empty()
+  {
+    ::SysFreeString(m_str);
+    m_str = NULL;
+  }
+  bool operator!() const {  return (m_str == NULL); }
+};
+
+
+//////////////////////////////////////////////////////////
+
+class CMyUnknownImp
+{
+public:
+  ULONG __m_RefCount;
+  CMyUnknownImp(): __m_RefCount(0) {}
+};
+
+#define MY_QUERYINTERFACE_BEGIN STDMETHOD(QueryInterface) \
+    (REFGUID iid, void **outObject) { 
+
+#define MY_QUERYINTERFACE_ENTRY(i) if (iid == IID_ ## i) \
+    { *outObject = (void *)(i *)this; AddRef(); return S_OK; }
+
+#define MY_QUERYINTERFACE_END return E_NOINTERFACE; }
+
+#define MY_ADDREF_RELEASE \
+STDMETHOD_(ULONG, AddRef)() { return ++__m_RefCount; } \
+STDMETHOD_(ULONG, Release)() { if (--__m_RefCount != 0)  \
+  return __m_RefCount; delete this; return 0; }
+
+#define MY_UNKNOWN_IMP_SPEC(i) \
+  MY_QUERYINTERFACE_BEGIN \
+  i \
+  MY_QUERYINTERFACE_END \
+  MY_ADDREF_RELEASE
+
+
+#define MY_UNKNOWN_IMP STDMETHOD(QueryInterface)(REFGUID, void **) { \
+  MY_QUERYINTERFACE_END \
+  MY_ADDREF_RELEASE
+
+#define MY_UNKNOWN_IMP1(i) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i) \
+  )
+
+#define MY_UNKNOWN_IMP2(i1, i2) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i1) \
+  MY_QUERYINTERFACE_ENTRY(i2) \
+  )
+
+#define MY_UNKNOWN_IMP3(i1, i2, i3) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i1) \
+  MY_QUERYINTERFACE_ENTRY(i2) \
+  MY_QUERYINTERFACE_ENTRY(i3) \
+  )
+
+#define MY_UNKNOWN_IMP4(i1, i2, i3, i4) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i1) \
+  MY_QUERYINTERFACE_ENTRY(i2) \
+  MY_QUERYINTERFACE_ENTRY(i3) \
+  MY_QUERYINTERFACE_ENTRY(i4) \
+  )
+
+#define MY_UNKNOWN_IMP5(i1, i2, i3, i4, i5) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i1) \
+  MY_QUERYINTERFACE_ENTRY(i2) \
+  MY_QUERYINTERFACE_ENTRY(i3) \
+  MY_QUERYINTERFACE_ENTRY(i4) \
+  MY_QUERYINTERFACE_ENTRY(i5) \
+  )
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyCom.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyGuidDef.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyGuidDef.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyGuidDef.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,54 @@
+// Common/MyGuidDef.h
+
+#ifndef GUID_DEFINED
+#define GUID_DEFINED
+
+#include &quot;Types.h&quot;
+
+typedef struct {
+  UInt32 Data1;
+  UInt16 Data2;
+  UInt16 Data3;
+  unsigned char Data4[8];
+} GUID;
+
+#ifdef __cplusplus
+#define REFGUID const GUID &amp;
+#else
+#define REFGUID const GUID *
+#endif
+
+#define REFCLSID REFGUID
+#define REFIID REFGUID
+
+#ifdef __cplusplus
+inline bool operator==(REFGUID g1, REFGUID g2)
+{ 
+  for (int i = 0; i &lt; (int)sizeof(g1); i++)
+    if (((unsigned char *)&amp;g1)[i] != ((unsigned char *)&amp;g2)[i])
+      return false;
+  return true;
+}
+inline bool operator!=(REFGUID g1, REFGUID g2) { return !(g1 == g2); }
+#endif
+
+#ifdef __cplusplus
+  #define MY_EXTERN_C extern &quot;C&quot;
+#else
+  #define MY_EXTERN_C extern
+#endif
+
+#endif // GUID_DEFINED
+
+
+#ifdef DEFINE_GUID
+#undef DEFINE_GUID
+#endif
+
+#ifdef INITGUID
+  #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+    MY_EXTERN_C const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
+#else
+  #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+    MY_EXTERN_C const GUID name
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyGuidDef.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyInitGuid.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyInitGuid.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyInitGuid.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,13 @@
+// Common/MyInitGuid.h
+
+#ifndef __COMMON_MYINITGUID_H
+#define __COMMON_MYINITGUID_H
+
+#ifdef _WIN32
+#include &lt;initguid.h&gt;
+#else
+#define INITGUID
+#include &quot;MyGuidDef.h&quot;
+#endif
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyInitGuid.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyUnknown.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyUnknown.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyUnknown.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,24 @@
+// MyUnknown.h
+
+#ifndef __MYUNKNOWN_H
+#define __MYUNKNOWN_H
+
+#ifdef _WIN32
+
+#ifdef _WIN32_WCE
+#if (_WIN32_WCE &gt; 300)
+#include &lt;basetyps.h&gt;
+#else
+#define MIDL_INTERFACE(x) struct 
+#endif
+#else
+#include &lt;basetyps.h&gt;
+#endif
+
+#include &lt;unknwn.h&gt;
+
+#else 
+#include &quot;MyWindows.h&quot;
+#endif
+  
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyUnknown.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyWindows.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyWindows.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyWindows.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,200 @@
+// MyWindows.h
+
+#ifndef __MYWINDOWS_H
+#define __MYWINDOWS_H
+
+#ifdef _WIN32
+
+#include &lt;windows.h&gt;
+
+#define CHAR_PATH_SEPARATOR '\\'
+#define WCHAR_PATH_SEPARATOR L'\\'
+#define STRING_PATH_SEPARATOR &quot;\\&quot;
+#define WSTRING_PATH_SEPARATOR L&quot;\\&quot;
+
+#else
+
+#define CHAR_PATH_SEPARATOR '/'
+#define WCHAR_PATH_SEPARATOR L'/'
+#define STRING_PATH_SEPARATOR &quot;/&quot;
+#define WSTRING_PATH_SEPARATOR L&quot;/&quot;
+
+#include &lt;stddef.h&gt; // for wchar_t
+#include &lt;string.h&gt;
+
+#include &quot;MyGuidDef.h&quot;
+
+typedef char CHAR;
+typedef unsigned char UCHAR;
+
+#undef BYTE
+typedef unsigned char BYTE;
+
+typedef short SHORT;
+typedef unsigned short USHORT;
+
+#undef WORD
+typedef unsigned short WORD;
+typedef short VARIANT_BOOL;
+
+typedef int INT;
+typedef Int32 INT32;
+typedef unsigned int UINT;
+typedef UInt32 UINT32;
+typedef INT32 LONG;   // LONG, ULONG and DWORD must be 32-bit
+typedef UINT32 ULONG;
+
+#undef DWORD
+typedef UINT32 DWORD;
+
+typedef Int64 LONGLONG;
+typedef UInt64 ULONGLONG;
+
+typedef struct LARGE_INTEGER { LONGLONG QuadPart; }LARGE_INTEGER;
+typedef struct _ULARGE_INTEGER { ULONGLONG QuadPart;} ULARGE_INTEGER;
+
+typedef const CHAR *LPCSTR;
+typedef CHAR TCHAR;
+typedef const TCHAR *LPCTSTR;
+typedef wchar_t WCHAR;
+typedef WCHAR OLECHAR;
+typedef const WCHAR *LPCWSTR;
+typedef OLECHAR *BSTR;
+typedef const OLECHAR *LPCOLESTR;
+typedef OLECHAR *LPOLESTR;
+
+typedef struct _FILETIME
+{
+  DWORD dwLowDateTime;
+  DWORD dwHighDateTime;
+}FILETIME;
+
+#define HRESULT LONG
+#define FAILED(Status) ((HRESULT)(Status)&lt;0)
+typedef ULONG PROPID;
+typedef LONG SCODE;
+
+#define S_OK    ((HRESULT)0x00000000L)
+#define S_FALSE ((HRESULT)0x00000001L)
+#define E_NOTIMPL ((HRESULT)0x80004001L)
+#define E_NOINTERFACE ((HRESULT)0x80004002L)
+#define E_ABORT ((HRESULT)0x80004004L)
+#define E_FAIL ((HRESULT)0x80004005L)
+#define STG_E_INVALIDFUNCTION ((HRESULT)0x80030001L)
+#define E_OUTOFMEMORY ((HRESULT)0x8007000EL)
+#define E_INVALIDARG ((HRESULT)0x80070057L)
+
+#ifdef _MSC_VER
+#define STDMETHODCALLTYPE __stdcall 
+#else
+#define STDMETHODCALLTYPE 
+#endif
+
+#define STDMETHOD_(t, f) virtual t STDMETHODCALLTYPE f
+#define STDMETHOD(f) STDMETHOD_(HRESULT, f)
+#define STDMETHODIMP_(type) type STDMETHODCALLTYPE
+#define STDMETHODIMP STDMETHODIMP_(HRESULT)
+
+#define PURE = 0
+
+#define MIDL_INTERFACE(x) struct 
+
+struct IUnknown
+{
+  STDMETHOD(QueryInterface) (REFIID iid, void **outObject) PURE;
+  STDMETHOD_(ULONG, AddRef)() PURE;
+  STDMETHOD_(ULONG, Release)() PURE;
+};
+
+typedef IUnknown *LPUNKNOWN;
+
+#define VARIANT_TRUE ((VARIANT_BOOL)-1)
+#define VARIANT_FALSE ((VARIANT_BOOL)0)
+
+enum VARENUM
+{	
+  VT_EMPTY	= 0,
+	VT_NULL	= 1,
+	VT_I2	= 2,
+	VT_I4	= 3,
+	VT_R4	= 4,
+	VT_R8	= 5,
+	VT_CY	= 6,
+	VT_DATE	= 7,
+	VT_BSTR	= 8,
+	VT_DISPATCH	= 9,
+	VT_ERROR	= 10,
+	VT_BOOL	= 11,
+	VT_VARIANT	= 12,
+	VT_UNKNOWN	= 13,
+	VT_DECIMAL	= 14,
+	VT_I1	= 16,
+	VT_UI1	= 17,
+	VT_UI2	= 18,
+	VT_UI4	= 19,
+	VT_I8	= 20,
+	VT_UI8	= 21,
+	VT_INT	= 22,
+	VT_UINT	= 23,
+	VT_VOID	= 24,
+	VT_HRESULT	= 25,
+	VT_FILETIME	= 64
+};
+
+typedef unsigned short VARTYPE;
+typedef WORD PROPVAR_PAD1;
+typedef WORD PROPVAR_PAD2;
+typedef WORD PROPVAR_PAD3;
+
+typedef struct tagPROPVARIANT
+{
+  VARTYPE vt;
+  PROPVAR_PAD1 wReserved1;
+  PROPVAR_PAD2 wReserved2;
+  PROPVAR_PAD3 wReserved3;
+  union 
+  {
+    CHAR cVal;
+    UCHAR bVal;
+    SHORT iVal;
+    USHORT uiVal;
+    LONG lVal;
+    ULONG ulVal;
+    INT intVal;
+    UINT uintVal;
+    LARGE_INTEGER hVal;
+    ULARGE_INTEGER uhVal;
+    VARIANT_BOOL boolVal;
+    SCODE scode;
+    FILETIME filetime;
+    BSTR bstrVal;
+  };
+} PROPVARIANT;
+
+typedef PROPVARIANT tagVARIANT;
+typedef tagVARIANT VARIANT;
+typedef VARIANT VARIANTARG;
+
+MY_EXTERN_C BSTR SysAllocStringByteLen(LPCSTR psz, UINT len);
+MY_EXTERN_C BSTR SysAllocString(const OLECHAR *sz);
+MY_EXTERN_C void SysFreeString(BSTR bstr);
+MY_EXTERN_C UINT SysStringByteLen(BSTR bstr);
+MY_EXTERN_C UINT SysStringLen(BSTR bstr);
+
+MY_EXTERN_C DWORD GetLastError();
+MY_EXTERN_C HRESULT VariantClear(VARIANTARG *prop);
+MY_EXTERN_C HRESULT VariantCopy(VARIANTARG *dest, VARIANTARG *src);
+MY_EXTERN_C LONG CompareFileTime(const FILETIME* ft1, const FILETIME* ft2);
+
+#define CP_ACP    0
+#define CP_OEMCP  1
+
+typedef enum tagSTREAM_SEEK
+{	
+  STREAM_SEEK_SET	= 0,
+  STREAM_SEEK_CUR	= 1,
+  STREAM_SEEK_END	= 2
+} STREAM_SEEK;
+
+#endif
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/MyWindows.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,116 @@
+// NewHandler.cpp
+ 
+#include &quot;StdAfx.h&quot;
+
+#include &lt;stdlib.h&gt;
+
+#include &quot;NewHandler.h&quot;
+
+// #define DEBUG_MEMORY_LEAK
+
+#ifndef DEBUG_MEMORY_LEAK
+
+#ifdef _WIN32
+void * 
+#ifdef _MSC_VER
+__cdecl 
+#endif
+operator new(size_t size)
+{
+  // void *p = ::HeapAlloc(::GetProcessHeap(), 0, size);
+  void *p = ::malloc(size);
+  if (p == 0)
+    throw CNewException();
+  return p;
+}
+
+void 
+#ifdef _MSC_VER
+__cdecl 
+#endif
+operator delete(void *p) throw()
+{
+  /*
+  if (p == 0)
+    return;
+  ::HeapFree(::GetProcessHeap(), 0, p);
+  */
+  ::free(p);
+}
+#endif
+
+#else
+
+#pragma init_seg(lib)
+const int kDebugSize = 1000000;
+static void *a[kDebugSize];
+static int index = 0;
+
+static int numAllocs = 0;
+void * __cdecl operator new(size_t size)
+{
+  numAllocs++;
+  void *p = HeapAlloc(GetProcessHeap(), 0, size);
+  if (index == 40)
+  {
+    int t = 1;
+  }
+  if (index &lt; kDebugSize)
+  {
+    a[index] = p;
+    index++;
+  }
+  if (p == 0)
+    throw CNewException();
+  printf(&quot;Alloc %6d, size = %8d\n&quot;, numAllocs, size);
+  return p;
+}
+
+class CC
+{
+public:
+  CC()
+  {
+    for (int i = 0; i &lt; kDebugSize; i++)
+      a[i] = 0;
+  }
+  ~CC()
+  {
+    for (int i = 0; i &lt; kDebugSize; i++)
+      if (a[i] != 0)
+        return;
+  }
+} g_CC;
+
+
+void __cdecl operator delete(void *p)
+{
+  if (p == 0)
+    return;
+  /*
+  for (int i = 0; i &lt; index; i++)
+    if (a[i] == p)
+      a[i] = 0;
+  */
+  HeapFree(GetProcessHeap(), 0, p);
+  numAllocs--;
+  printf(&quot;Free %d\n&quot;, numAllocs);
+}
+
+#endif
+
+/*
+int MemErrorVC(size_t)
+{
+  throw CNewException();
+  // return 1;
+}
+CNewHandlerSetter::CNewHandlerSetter()
+{
+  // MemErrorOldVCFunction = _set_new_handler(MemErrorVC);
+}
+CNewHandlerSetter::~CNewHandlerSetter()
+{
+  // _set_new_handler(MemErrorOldVCFunction);
+}
+*/


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,16 @@
+// Common/NewHandler.h
+
+#ifndef __COMMON_NEWHANDLER_H
+#define __COMMON_NEWHANDLER_H
+
+class CNewException {};
+
+#ifdef _WIN32
+void 
+#ifdef _MSC_VER
+__cdecl 
+#endif
+operator delete(void *p) throw();
+#endif 
+
+#endif 


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/NewHandler.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StdAfx.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StdAfx.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StdAfx.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,9 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+// #include &quot;MyWindows.h&quot;
+#include &quot;NewHandler.h&quot;
+
+#endif 


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StdAfx.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,198 @@
+// Common/String.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#ifdef _WIN32
+#include &quot;StringConvert.h&quot;
+#else
+#include &lt;ctype.h&gt;
+#endif
+
+#include &quot;Common/String.h&quot;
+
+
+#ifdef _WIN32
+
+#ifndef _UNICODE
+
+wchar_t MyCharUpper(wchar_t c)
+{
+  if (c == 0)
+    return 0;
+  wchar_t *res = CharUpperW((LPWSTR)(unsigned int)c);
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return (wchar_t)(unsigned int)res;
+  const int kBufferSize = 4;
+  char s[kBufferSize + 1];
+  int numChars = ::WideCharToMultiByte(CP_ACP, 0, &amp;c, 1, s, kBufferSize, 0, 0);
+  if (numChars == 0 || numChars &gt; kBufferSize)
+    return c;
+  s[numChars] = 0;
+  ::CharUpperA(s);
+  ::MultiByteToWideChar(CP_ACP, 0, s, numChars, &amp;c, 1);
+  return c;
+}
+
+wchar_t MyCharLower(wchar_t c)
+{
+  if (c == 0)
+    return 0;
+  wchar_t *res = CharLowerW((LPWSTR)(unsigned int)c);
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return (wchar_t)(unsigned int)res;
+  const int kBufferSize = 4;
+  char s[kBufferSize + 1];
+  int numChars = ::WideCharToMultiByte(CP_ACP, 0, &amp;c, 1, s, kBufferSize, 0, 0);
+  if (numChars == 0 || numChars &gt; kBufferSize)
+    return c;
+  s[numChars] = 0;
+  ::CharLowerA(s);
+  ::MultiByteToWideChar(CP_ACP, 0, s, numChars, &amp;c, 1);
+  return c;
+}
+
+wchar_t * MyStringUpper(wchar_t *s)
+{
+  if (s == 0)
+    return 0;
+  wchar_t *res = CharUpperW(s);
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return res;
+  AString a = UnicodeStringToMultiByte(s);
+  a.MakeUpper();
+  return MyStringCopy(s, (const wchar_t *)MultiByteToUnicodeString(a));
+}
+
+wchar_t * MyStringLower(wchar_t *s)
+{ 
+  if (s == 0)
+    return 0;
+  wchar_t *res = CharLowerW(s);
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return res;
+  AString a = UnicodeStringToMultiByte(s);
+  a.MakeLower();
+  return MyStringCopy(s, (const wchar_t *)MultiByteToUnicodeString(a));
+}
+
+#endif
+
+/*
+inline int ConvertCompareResult(int r) { return r - 2; }
+
+int MyStringCollate(const wchar_t *s1, const wchar_t *s2)
+{ 
+  int res = CompareStringW(
+        LOCALE_USER_DEFAULT, SORT_STRINGSORT, s1, -1, s2, -1); 
+  #ifdef _UNICODE
+  return ConvertCompareResult(res);
+  #else
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return ConvertCompareResult(res);
+  return MyStringCollate(UnicodeStringToMultiByte(s1), 
+        UnicodeStringToMultiByte(s2));
+  #endif
+}
+
+#ifndef _WIN32_WCE
+int MyStringCollate(const char *s1, const char *s2)
+{ 
+  return ConvertCompareResult(CompareStringA(
+    LOCALE_USER_DEFAULT, SORT_STRINGSORT, s1, -1, s2, -1)); 
+}
+
+int MyStringCollateNoCase(const char *s1, const char *s2)
+{ 
+  return ConvertCompareResult(CompareStringA(
+    LOCALE_USER_DEFAULT, NORM_IGNORECASE | SORT_STRINGSORT, s1, -1, s2, -1)); 
+}
+#endif
+
+int MyStringCollateNoCase(const wchar_t *s1, const wchar_t *s2)
+{ 
+  int res = CompareStringW(
+        LOCALE_USER_DEFAULT, NORM_IGNORECASE | SORT_STRINGSORT, s1, -1, s2, -1); 
+  #ifdef _UNICODE
+  return ConvertCompareResult(res);
+  #else
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return ConvertCompareResult(res);
+  return MyStringCollateNoCase(UnicodeStringToMultiByte(s1), 
+      UnicodeStringToMultiByte(s2));
+  #endif
+}
+*/
+
+#else
+
+wchar_t MyCharUpper(wchar_t c)
+{
+  return toupper(c);
+}
+
+/*
+int MyStringCollateNoCase(const wchar_t *s1, const wchar_t *s2)
+{ 
+  while (true)
+  {
+    wchar_t c1 = *s1++;
+    wchar_t c2 = *s2++;
+    wchar_t u1 = MyCharUpper(c1);
+    wchar_t u2 = MyCharUpper(c2);
+
+    if (u1 &lt; u2) return -1;
+    if (u1 &gt; u2) return 1;
+    if (u1 == 0) return 0;
+  }
+}
+*/
+
+#endif
+
+int MyStringCompare(const char *s1, const char *s2)
+{ 
+  while (true)
+  {
+    unsigned char c1 = (unsigned char)*s1++;
+    unsigned char c2 = (unsigned char)*s2++;
+    if (c1 &lt; c2) return -1;
+    if (c1 &gt; c2) return 1;
+    if (c1 == 0) return 0;
+  }
+}
+
+int MyStringCompare(const wchar_t *s1, const wchar_t *s2)
+{ 
+  while (true)
+  {
+    wchar_t c1 = *s1++;
+    wchar_t c2 = *s2++;
+    if (c1 &lt; c2) return -1;
+    if (c1 &gt; c2) return 1;
+    if (c1 == 0) return 0;
+  }
+}
+
+int MyStringCompareNoCase(const wchar_t *s1, const wchar_t *s2)
+{ 
+  while (true)
+  {
+    wchar_t c1 = *s1++;
+    wchar_t c2 = *s2++;
+    if (c1 != c2)
+    {
+      wchar_t u1 = MyCharUpper(c1);
+      wchar_t u2 = MyCharUpper(c2);
+      if (u1 &lt; u2) return -1;
+      if (u1 &gt; u2) return 1;
+    }
+    if (c1 == 0) return 0;
+  }
+}
+
+#ifdef _WIN32
+int MyStringCompareNoCase(const char *s1, const char *s2)
+{ 
+  return MyStringCompareNoCase(MultiByteToUnicodeString(s1), MultiByteToUnicodeString(s2));
+}
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,631 @@
+// Common/String.h
+
+#ifndef __COMMON_STRING_H
+#define __COMMON_STRING_H
+
+#include &lt;string.h&gt;
+// #include &lt;wchar.h&gt;
+
+#include &quot;Vector.h&quot;
+
+#ifdef _WIN32
+#include &quot;MyWindows.h&quot;
+#endif
+
+static const char *kTrimDefaultCharSet  = &quot; \n\t&quot;;
+
+template &lt;class T&gt;
+inline int MyStringLen(const T *s)
+{ 
+  int i;
+  for (i = 0; s[i] != '\0'; i++);
+  return i;
+}
+
+template &lt;class T&gt;
+inline T * MyStringCopy(T *dest, const T *src)
+{ 
+  T *destStart = dest;
+  while((*dest++ = *src++) != 0);
+  return destStart;
+}
+
+inline wchar_t* MyStringGetNextCharPointer(wchar_t *p)
+  { return (p + 1); }
+inline const wchar_t* MyStringGetNextCharPointer(const wchar_t *p)
+  { return (p + 1); }
+inline wchar_t* MyStringGetPrevCharPointer(const wchar_t *, wchar_t *p)
+  { return (p - 1); }
+inline const wchar_t* MyStringGetPrevCharPointer(const wchar_t *, const wchar_t *p)
+  { return (p - 1); }
+
+#ifdef _WIN32
+
+inline char* MyStringGetNextCharPointer(char *p)
+  { return CharNextA(p); }
+inline const char* MyStringGetNextCharPointer(const char *p)
+  { return CharNextA(p); }
+
+inline char* MyStringGetPrevCharPointer(char *base, char *p)
+  { return CharPrevA(base, p); }
+inline const char* MyStringGetPrevCharPointer(const char *base, const char *p)
+  { return CharPrevA(base, p); }
+
+inline char MyCharUpper(char c)
+  { return (char)(unsigned int)CharUpperA((LPSTR)(unsigned int)(unsigned char)c); }
+#ifdef _UNICODE
+inline wchar_t MyCharUpper(wchar_t c)
+  { return (wchar_t)CharUpperW((LPWSTR)c); }
+#else
+wchar_t MyCharUpper(wchar_t c);
+#endif
+
+inline char MyCharLower(char c)
+  { return (char)(unsigned int)CharLowerA((LPSTR)(unsigned int)(unsigned char)c); }
+#ifdef _UNICODE
+inline wchar_t MyCharLower(wchar_t c)
+  { return (wchar_t)CharLowerW((LPWSTR)c); }
+#else
+wchar_t MyCharLower(wchar_t c);
+#endif
+
+inline char * MyStringUpper(char *s) { return CharUpperA(s); }
+#ifdef _UNICODE
+inline wchar_t * MyStringUpper(wchar_t *s) { return CharUpperW(s); }
+#else
+wchar_t * MyStringUpper(wchar_t *s);
+#endif
+
+inline char * MyStringLower(char *s) { return CharLowerA(s); }
+#ifdef _UNICODE
+inline wchar_t * MyStringLower(wchar_t *s) { return CharLowerW(s); }
+#else
+wchar_t * MyStringLower(wchar_t *s);
+#endif
+
+#else // Standard-C
+wchar_t MyCharUpper(wchar_t c);
+#endif
+
+//////////////////////////////////////
+// Compare
+
+/*
+#ifndef _WIN32_WCE
+int MyStringCollate(const char *s1, const char *s2);
+int MyStringCollateNoCase(const char *s1, const char *s2);
+#endif
+int MyStringCollate(const wchar_t *s1, const wchar_t *s2);
+int MyStringCollateNoCase(const wchar_t *s1, const wchar_t *s2);
+*/
+
+int MyStringCompare(const char *s1, const char  *s2);
+int MyStringCompare(const wchar_t *s1, const wchar_t *s2);
+
+#ifdef _WIN32
+int MyStringCompareNoCase(const char *s1, const char  *s2);
+#endif
+
+int MyStringCompareNoCase(const wchar_t *s1, const wchar_t *s2);
+
+template &lt;class T&gt;
+class CStringBase
+{
+  void TrimLeftWithCharSet(const CStringBase &amp;charSet)
+  {
+    const T *p = _chars;
+    while (charSet.Find(*p) &gt;= 0 &amp;&amp; (*p != 0))
+      p = GetNextCharPointer(p);
+    Delete(0, (int)(p - _chars));
+  }
+  void TrimRightWithCharSet(const CStringBase &amp;charSet)
+  {
+    const T *p = _chars;
+    const T *pLast = NULL;
+    while (*p != 0)
+    {
+      if (charSet.Find(*p) &gt;= 0)
+      {
+        if (pLast == NULL)
+          pLast = p;
+      }
+      else
+        pLast = NULL;
+      p = GetNextCharPointer(p);
+    }
+    if(pLast != NULL)
+    {
+      int i = (int)(pLast - _chars);
+      Delete(i, _length - i);
+    }
+
+  }
+  void MoveItems(int destIndex, int srcIndex)
+  {
+    memmove(_chars + destIndex, _chars + srcIndex, 
+        sizeof(T) * (_length - srcIndex + 1));
+  }
+  
+  void InsertSpace(int &amp;index, int size)
+  {
+    CorrectIndex(index);
+    GrowLength(size);
+    MoveItems(index + size, index);
+  }
+
+  static T *GetNextCharPointer(T *p)
+    { return MyStringGetNextCharPointer(p); }
+  static const T *GetNextCharPointer(const T *p)
+    { return MyStringGetNextCharPointer(p); }
+  static T *GetPrevCharPointer(T *base, T *p)
+    { return MyStringGetPrevCharPointer(base, p); }
+  static const T *GetPrevCharPointer(const T *base, const T *p)
+    { return MyStringGetPrevCharPointer(base, p); }
+protected:
+  T *_chars;
+  int _length;
+	int _capacity;
+  
+  void SetCapacity(int newCapacity)
+  {
+    int realCapacity = newCapacity + 1;
+    if(realCapacity == _capacity)
+      return;
+    /*
+    const int kMaxStringSize = 0x20000000;
+    #ifndef _WIN32_WCE
+    if(newCapacity &gt; kMaxStringSize || newCapacity &lt; _length)
+      throw 1052337;
+    #endif
+    */
+    T *newBuffer = new T[realCapacity];
+    if(_capacity &gt; 0)
+    {
+      for (int i = 0; i &lt; (_length + 1); i++)
+        newBuffer[i] = _chars[i];
+      delete []_chars;
+      _chars = newBuffer;
+    }
+    else
+    {
+      _chars = newBuffer;
+      _chars[0] = 0;
+    }
+    _capacity = realCapacity;
+  }
+
+  void GrowLength(int n)
+  {
+    int freeSize = _capacity - _length - 1;
+    if (n &lt;= freeSize) 
+      return;
+    int delta;
+    if (_capacity &gt; 64)
+      delta = _capacity / 2;
+    else if (_capacity &gt; 8)
+      delta = 16;
+    else
+      delta = 4;
+    if (freeSize + delta &lt; n)
+      delta = n - freeSize;
+    SetCapacity(_capacity + delta);
+  }
+
+  void CorrectIndex(int &amp;index) const
+  {
+    if (index &gt; _length)
+      index = _length;
+  }
+
+public:
+  CStringBase(): _chars(0), _length(0), _capacity(0)
+    { SetCapacity(16 - 1); }
+  CStringBase(T c):  _chars(0), _length(0), _capacity(0)
+  {
+    SetCapacity(1);
+    _chars[0] = c;
+    _chars[1] = 0;
+    _length = 1;
+  }
+  CStringBase(const T *chars): _chars(0), _length(0), _capacity(0)
+  {
+    int length = MyStringLen(chars);
+    SetCapacity(length);
+    MyStringCopy(_chars, chars); // can be optimized by memove()
+    _length = length;
+  }
+  CStringBase(const CStringBase &amp;s):  _chars(0), _length(0), _capacity(0)
+  {
+    SetCapacity(s._length);
+    MyStringCopy(_chars, s._chars);
+    _length = s._length;
+  }
+  ~CStringBase() {  delete []_chars; }
+
+  operator const T*() const { return _chars;} 
+
+  // The minimum size of the character buffer in characters. 
+  // This value does not include space for a null terminator.
+  T* GetBuffer(int minBufLength)
+  {
+    if(minBufLength &gt;= _capacity)
+      SetCapacity(minBufLength + 1);
+    return _chars;
+  }
+  void ReleaseBuffer() { ReleaseBuffer(MyStringLen(_chars)); }
+  void ReleaseBuffer(int newLength)
+  {
+    /*
+    #ifndef _WIN32_WCE
+    if(newLength &gt;= _capacity)
+      throw 282217;
+    #endif
+    */
+    _chars[newLength] = 0;
+    _length = newLength;
+  }
+
+  CStringBase&amp; operator=(T c)
+  {
+    Empty();
+    SetCapacity(1);
+    _chars[0] = c;
+    _chars[1] = 0;
+    _length = 1;
+    return *this;
+  }
+  CStringBase&amp; operator=(const T *chars)
+  {
+    Empty();
+    int length = MyStringLen(chars);
+    SetCapacity(length);
+    MyStringCopy(_chars, chars);
+    _length = length; 
+    return *this;
+  }  
+  CStringBase&amp; operator=(const CStringBase&amp; s)
+  {
+    if(&amp;s == this)
+      return *this;
+    Empty();
+    SetCapacity(s._length);
+    MyStringCopy(_chars, s._chars);
+    _length = s._length;
+    return *this;
+  }
+  
+  CStringBase&amp; operator+=(T c)
+  {
+    GrowLength(1);
+    _chars[_length] = c;
+    _chars[++_length] = 0;
+    return *this;
+  }
+  CStringBase&amp; operator+=(const T *s)
+  {
+    int len = MyStringLen(s);
+    GrowLength(len);
+    MyStringCopy(_chars + _length, s);
+    _length += len;
+    return *this;
+  }
+  CStringBase&amp; operator+=(const CStringBase &amp;s)
+  {
+    GrowLength(s._length);
+    MyStringCopy(_chars + _length, s._chars);
+    _length += s._length;
+    return *this;
+  }
+  void Empty()
+  {
+    _length = 0;
+    _chars[0] = 0;
+  }
+  int Length() const { return _length; }
+  bool IsEmpty() const { return (_length == 0); }
+
+  CStringBase Mid(int startIndex) const
+    { return Mid(startIndex, _length - startIndex); }
+  CStringBase Mid(int startIndex, int count ) const
+  {
+    if (startIndex + count &gt; _length)
+      count = _length - startIndex;
+    
+    if (startIndex == 0 &amp;&amp; startIndex + count == _length)
+      return *this;
+    
+    CStringBase&lt;T&gt; result;
+    result.SetCapacity(count);
+    // MyStringNCopy(result._chars, _chars + startIndex, count);
+    for (int i = 0; i &lt; count; i++)
+      result._chars[i] = _chars[startIndex + i];
+    result._chars[count] = 0;
+    result._length = count;
+    return result;
+  }
+  CStringBase Left(int count) const
+    { return Mid(0, count); }
+  CStringBase Right(int count) const
+  {
+    if (count &gt; _length)
+      count = _length;
+    return Mid(_length - count, count);
+  }
+
+  void MakeUpper()
+    { MyStringUpper(_chars); }
+  void MakeLower()
+    { MyStringLower(_chars); }
+
+  int Compare(const CStringBase&amp; s) const
+    { return MyStringCompare(_chars, s._chars); }
+
+  int CompareNoCase(const CStringBase&amp; s) const
+    { return MyStringCompareNoCase(_chars, s._chars); }
+  /*
+  int Collate(const CStringBase&amp; s) const
+    { return MyStringCollate(_chars, s._chars); }
+  int CollateNoCase(const CStringBase&amp; s) const
+    { return MyStringCollateNoCase(_chars, s._chars); }
+  */
+
+  int Find(T c) const { return Find(c, 0); }
+  int Find(T c, int startIndex) const
+  {
+    T *p = _chars + startIndex;
+    while (true)
+    {
+      if (*p == c)
+        return (int)(p - _chars);
+      if (*p == 0)
+        return -1;
+      p = GetNextCharPointer(p);
+    }
+  }
+  int Find(const CStringBase &amp;s) const { return Find(s, 0); }
+  int Find(const CStringBase &amp;s, int startIndex) const
+  {
+    if (s.IsEmpty())
+      return startIndex;
+    for (; startIndex &lt; _length; startIndex++)
+    {
+      int j;
+      for (j = 0; j &lt; s._length &amp;&amp; startIndex + j &lt; _length; j++)
+        if (_chars[startIndex+j] != s._chars[j])
+          break;
+      if (j == s._length)
+        return startIndex;
+    }
+    return -1;
+  }
+  int ReverseFind(T c) const
+  {
+    if (_length == 0)
+      return -1;
+    T *p = _chars + _length - 1;
+    while (true)
+    {
+      if (*p == c)
+        return (int)(p - _chars);
+      if (p == _chars)
+        return -1;
+      p = GetPrevCharPointer(_chars, p);
+    }
+  }
+  int FindOneOf(const CStringBase &amp;s) const
+  {
+    for(int i = 0; i &lt; _length; i++)
+      if (s.Find(_chars[i]) &gt;= 0)
+        return i;
+      return -1;
+  }
+
+  void TrimLeft(T c)
+  {
+    const T *p = _chars;
+    while (c == *p)
+      p = GetNextCharPointer(p);
+    Delete(0, p - _chars);
+  }
+  private:
+  CStringBase GetTrimDefaultCharSet()
+  {
+    CStringBase&lt;T&gt; charSet;
+    for(int i = 0; i &lt; (int)(sizeof(kTrimDefaultCharSet) /
+      sizeof(kTrimDefaultCharSet[0])); i++)
+      charSet += (T)kTrimDefaultCharSet[i];
+    return charSet;
+  }
+  public:
+
+  void TrimLeft()
+  {
+    TrimLeftWithCharSet(GetTrimDefaultCharSet());
+  }
+  void TrimRight()
+  {
+    TrimRightWithCharSet(GetTrimDefaultCharSet());
+  }
+  void TrimRight(T c)
+  {
+    const T *p = _chars;
+    const T *pLast = NULL;
+    while (*p != 0)
+    {
+      if (*p == c)
+      {
+        if (pLast == NULL)
+          pLast = p;
+      }
+      else
+        pLast = NULL;
+      p = GetNextCharPointer(p);
+    }
+    if(pLast != NULL)
+    {
+      int i = pLast - _chars;
+      Delete(i, _length - i);
+    }
+  }
+  void Trim()
+  {
+    TrimRight();
+    TrimLeft();
+  }
+
+  int Insert(int index, T c)
+  {
+    InsertSpace(index, 1);
+    _chars[index] = c;
+    _length++;
+    return _length;
+  }
+  int Insert(int index, const CStringBase &amp;s)
+  {
+    CorrectIndex(index);
+    if (s.IsEmpty())
+      return _length;
+    int numInsertChars = s.Length();
+    InsertSpace(index, numInsertChars);
+    for(int i = 0; i &lt; numInsertChars; i++)
+      _chars[index + i] = s[i];
+    _length += numInsertChars;
+    return _length;
+  }
+
+  // !!!!!!!!!!!!!!! test it if newChar = '\0'
+  int Replace(T oldChar, T newChar)
+  {
+    if (oldChar == newChar)
+      return 0;
+    int number  = 0;
+    int pos  = 0;
+    while (pos &lt; Length())
+    {
+      pos = Find(oldChar, pos);
+      if (pos &lt; 0) 
+        break;
+      _chars[pos] = newChar;
+      pos++;
+      number++;
+    }
+    return number;
+  }
+  int Replace(const CStringBase &amp;oldString, const CStringBase &amp;newString)
+  {
+    if (oldString.IsEmpty())
+      return 0;
+    if (oldString == newString)
+      return 0;
+    int oldStringLength = oldString.Length();
+    int newStringLength = newString.Length();
+    int number  = 0;
+    int pos  = 0;
+    while (pos &lt; _length)
+    {
+      pos = Find(oldString, pos);
+      if (pos &lt; 0) 
+        break;
+      Delete(pos, oldStringLength);
+      Insert(pos, newString);
+      pos += newStringLength;
+      number++;
+    }
+    return number;
+  }
+  int Delete(int index, int count = 1 )
+  {
+    if (index + count &gt; _length)
+      count = _length - index;
+    if (count &gt; 0)
+    {
+      MoveItems(index, index + count);
+      _length -= count;
+    }
+    return _length;
+  }
+};
+
+template &lt;class T&gt;
+CStringBase&lt;T&gt; operator+(const CStringBase&lt;T&gt;&amp; s1, const CStringBase&lt;T&gt;&amp; s2)
+{
+  CStringBase&lt;T&gt; result(s1);
+  result += s2;
+  return result; 
+}
+
+template &lt;class T&gt;
+CStringBase&lt;T&gt; operator+(const CStringBase&lt;T&gt;&amp; s, T c)
+{
+  CStringBase&lt;T&gt; result(s);
+  result += c;
+  return result; 
+}
+
+template &lt;class T&gt;
+CStringBase&lt;T&gt; operator+(T c, const CStringBase&lt;T&gt;&amp; s)
+{
+  CStringBase&lt;T&gt; result(c);
+  result += s;
+  return result; 
+}
+
+template &lt;class T&gt;
+CStringBase&lt;T&gt; operator+(const CStringBase&lt;T&gt;&amp; s, const T * chars)
+{
+  CStringBase&lt;T&gt; result(s);
+  result += chars;
+  return result; 
+}
+
+template &lt;class T&gt;
+CStringBase&lt;T&gt; operator+(const T * chars, const CStringBase&lt;T&gt;&amp; s)
+{
+  CStringBase&lt;T&gt; result(chars);
+  result += s;
+  return result; 
+}
+
+template &lt;class T&gt;
+bool operator==(const CStringBase&lt;T&gt;&amp; s1, const CStringBase&lt;T&gt;&amp; s2)
+  { return (s1.Compare(s2) == 0); }
+
+template &lt;class T&gt;
+bool operator&lt;(const CStringBase&lt;T&gt;&amp; s1, const CStringBase&lt;T&gt;&amp; s2)
+  { return (s1.Compare(s2) &lt; 0); }
+
+template &lt;class T&gt;
+bool operator==(const T *s1, const CStringBase&lt;T&gt;&amp; s2)
+  { return (s2.Compare(s1) == 0); }
+
+template &lt;class T&gt;
+bool operator==(const CStringBase&lt;T&gt;&amp; s1, const T *s2)
+  { return (s1.Compare(s2) == 0); }
+
+template &lt;class T&gt;
+bool operator!=(const CStringBase&lt;T&gt;&amp; s1, const CStringBase&lt;T&gt;&amp; s2)
+  { return (s1.Compare(s2) != 0); }
+
+template &lt;class T&gt;
+bool operator!=(const T *s1, const CStringBase&lt;T&gt;&amp; s2)
+  { return (s2.Compare(s1) != 0); }
+
+template &lt;class T&gt;
+bool operator!=(const CStringBase&lt;T&gt;&amp; s1, const T *s2)
+  { return (s1.Compare(s2) != 0); }
+
+typedef CStringBase&lt;char&gt; AString;
+typedef CStringBase&lt;wchar_t&gt; UString;
+
+typedef CObjectVector&lt;AString&gt; AStringVector;
+typedef CObjectVector&lt;UString&gt; UStringVector;
+
+#ifdef _UNICODE
+  typedef UString CSysString;
+#else
+  typedef AString CSysString;
+#endif
+
+typedef CObjectVector&lt;CSysString&gt; CSysStringVector;
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/String.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,93 @@
+// Common/StringConvert.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;StringConvert.h&quot;
+
+#ifndef _WIN32
+#include &lt;stdlib.h&gt;
+#endif
+
+#ifdef _WIN32
+UString MultiByteToUnicodeString(const AString &amp;srcString, UINT codePage)
+{
+  UString resultString;
+  if(!srcString.IsEmpty())
+  {
+    int numChars = MultiByteToWideChar(codePage, 0, srcString, 
+      srcString.Length(), resultString.GetBuffer(srcString.Length()), 
+      srcString.Length() + 1);
+    #ifndef _WIN32_WCE
+    if(numChars == 0)
+      throw 282228;
+    #endif
+    resultString.ReleaseBuffer(numChars);
+  }
+  return resultString;
+}
+
+AString UnicodeStringToMultiByte(const UString &amp;srcString, UINT codePage)
+{
+  AString resultString;
+  if(!srcString.IsEmpty())
+  {
+    int numRequiredBytes = srcString.Length() * 2;
+    int numChars = WideCharToMultiByte(codePage, 0, srcString, 
+      srcString.Length(), resultString.GetBuffer(numRequiredBytes), 
+      numRequiredBytes + 1, NULL, NULL);
+    #ifndef _WIN32_WCE
+    if(numChars == 0)
+      throw 282229;
+    #endif
+    resultString.ReleaseBuffer(numChars);
+  }
+  return resultString;
+}
+
+#ifndef _WIN32_WCE
+AString SystemStringToOemString(const CSysString &amp;srcString)
+{
+  AString result;
+  CharToOem(srcString, result.GetBuffer(srcString.Length() * 2));
+  result.ReleaseBuffer();
+  return result;
+}
+#endif
+
+#else
+
+UString MultiByteToUnicodeString(const AString &amp;srcString, UINT codePage)
+{
+  UString resultString;
+  for (int i = 0; i &lt; srcString.Length(); i++)
+    resultString += wchar_t(srcString[i]);
+  /*
+  if(!srcString.IsEmpty())
+  {
+    int numChars = mbstowcs(resultString.GetBuffer(srcString.Length()), srcString, srcString.Length() + 1);
+    if (numChars &lt; 0) throw &quot;Your environment does not support UNICODE&quot;;
+    resultString.ReleaseBuffer(numChars);
+  }
+  */
+  return resultString;
+}
+
+AString UnicodeStringToMultiByte(const UString &amp;srcString, UINT codePage)
+{
+  AString resultString;
+  for (int i = 0; i &lt; srcString.Length(); i++)
+    resultString += char(srcString[i]);
+  /*
+  if(!srcString.IsEmpty())
+  {
+    int numRequiredBytes = srcString.Length() * 6 + 1;
+    int numChars = wcstombs(resultString.GetBuffer(numRequiredBytes), srcString, numRequiredBytes);
+    if (numChars &lt; 0) throw &quot;Your environment does not support UNICODE&quot;;
+    resultString.ReleaseBuffer(numChars);
+  }
+  */
+  return resultString;
+}
+
+#endif
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,71 @@
+// Common/StringConvert.h
+
+#ifndef __COMMON_STRINGCONVERT_H
+#define __COMMON_STRINGCONVERT_H
+
+#include &quot;MyWindows.h&quot;
+#include &quot;Common/String.h&quot;
+#include &quot;Types.h&quot;
+
+UString MultiByteToUnicodeString(const AString &amp;srcString, UINT codePage = CP_ACP);
+AString UnicodeStringToMultiByte(const UString &amp;srcString, UINT codePage = CP_ACP);
+
+inline const wchar_t* GetUnicodeString(const wchar_t* unicodeString)
+  { return unicodeString; }
+inline const UString&amp; GetUnicodeString(const UString &amp;unicodeString)
+  { return unicodeString; }
+inline UString GetUnicodeString(const AString &amp;ansiString)
+  { return MultiByteToUnicodeString(ansiString); }
+inline UString GetUnicodeString(const AString &amp;multiByteString, UINT codePage)
+  { return MultiByteToUnicodeString(multiByteString, codePage); }
+inline const wchar_t* GetUnicodeString(const wchar_t* unicodeString, UINT)
+  { return unicodeString; }
+inline const UString&amp; GetUnicodeString(const UString &amp;unicodeString, UINT)
+  { return unicodeString; }
+
+inline const char* GetAnsiString(const char* ansiString)
+  { return ansiString; }
+inline const AString&amp; GetAnsiString(const AString &amp;ansiString)
+  { return ansiString; }
+inline AString GetAnsiString(const UString &amp;unicodeString)
+  { return UnicodeStringToMultiByte(unicodeString); }
+
+inline const char* GetOemString(const char* oemString)
+  { return oemString; }
+inline const AString&amp; GetOemString(const AString &amp;oemString)
+  { return oemString; }
+inline AString GetOemString(const UString &amp;unicodeString)
+  { return UnicodeStringToMultiByte(unicodeString, CP_OEMCP); }
+
+
+#ifdef _UNICODE
+  inline const wchar_t* GetSystemString(const wchar_t* unicodeString)
+    { return unicodeString;}
+  inline const UString&amp; GetSystemString(const UString &amp;unicodeString)
+    { return unicodeString;}
+  inline const wchar_t* GetSystemString(const wchar_t* unicodeString, UINT codePage)
+    { return unicodeString;}
+  inline const UString&amp; GetSystemString(const UString &amp;unicodeString, UINT codePage)
+    { return unicodeString;}
+  inline UString GetSystemString(const AString &amp;multiByteString, UINT codePage)
+    { return MultiByteToUnicodeString(multiByteString, codePage);}
+  inline UString GetSystemString(const AString &amp;multiByteString)
+    { return MultiByteToUnicodeString(multiByteString);}
+#else
+  inline const char* GetSystemString(const char *ansiString)
+    { return ansiString; }
+  inline const AString&amp; GetSystemString(const AString &amp;multiByteString, UINT)
+    { return multiByteString; }
+  inline const char * GetSystemString(const char *multiByteString, UINT)
+    { return multiByteString; }
+  inline AString GetSystemString(const UString &amp;unicodeString)
+    { return UnicodeStringToMultiByte(unicodeString); }
+  inline AString GetSystemString(const UString &amp;unicodeString, UINT codePage)
+    { return UnicodeStringToMultiByte(unicodeString, codePage); }
+#endif
+
+#ifndef _WIN32_WCE
+AString SystemStringToOemString(const CSysString &amp;srcString);
+#endif
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringConvert.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,68 @@
+// Common/StringToInt.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;StringToInt.h&quot;
+
+UInt64 ConvertStringToUInt64(const char *s, const char **end)
+{
+  UInt64 result = 0;
+  while(true)
+  {
+    char c = *s;
+    if (c &lt; '0' || c &gt; '9')
+    {
+      if (end != NULL)
+        *end = s;
+      return result;
+    }
+    result *= 10;
+    result += (c - '0');
+    s++;
+  }
+}
+
+UInt64 ConvertOctStringToUInt64(const char *s, const char **end)
+{
+  UInt64 result = 0;
+  while(true)
+  {
+    char c = *s;
+    if (c &lt; '0' || c &gt; '7')
+    {
+      if (end != NULL)
+        *end = s;
+      return result;
+    }
+    result &lt;&lt;= 3;
+    result += (c - '0');
+    s++;
+  }
+}
+
+
+UInt64 ConvertStringToUInt64(const wchar_t *s, const wchar_t **end)
+{
+  UInt64 result = 0;
+  while(true)
+  {
+    wchar_t c = *s;
+    if (c &lt; '0' || c &gt; '9')
+    {
+      if (end != NULL)
+        *end = s;
+      return result;
+    }
+    result *= 10;
+    result += (c - '0');
+    s++;
+  }
+}
+
+
+Int64 ConvertStringToInt64(const char *s, const char **end)
+{
+  if (*s == '-')
+    return -(Int64)ConvertStringToUInt64(s + 1, end);
+  return ConvertStringToUInt64(s, end);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,17 @@
+// Common/StringToInt.h
+
+#ifndef __COMMON_STRINGTOINT_H
+#define __COMMON_STRINGTOINT_H
+
+#include &lt;string.h&gt;
+#include &quot;Types.h&quot;
+
+UInt64 ConvertStringToUInt64(const char *s, const char **end);
+UInt64 ConvertOctStringToUInt64(const char *s, const char **end);
+UInt64 ConvertStringToUInt64(const wchar_t *s, const wchar_t **end);
+
+Int64 ConvertStringToInt64(const char *s, const char **end);
+
+#endif
+
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/StringToInt.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Types.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Types.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Types.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,57 @@
+// Common/Types.h
+
+#ifndef __COMMON_TYPES_H
+#define __COMMON_TYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_INT16_DEFINED
+#define _7ZIP_INT16_DEFINED
+typedef short Int16;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_INT32_DEFINED
+#define _7ZIP_INT32_DEFINED
+typedef int Int32;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+typedef unsigned int UInt32;
+#endif 
+
+#ifdef _MSC_VER
+
+#ifndef _7ZIP_INT64_DEFINED
+#define _7ZIP_INT64_DEFINED
+typedef __int64 Int64;
+#endif 
+
+#ifndef _7ZIP_UINT64_DEFINED
+#define _7ZIP_UINT64_DEFINED
+typedef unsigned __int64 UInt64;
+#endif 
+
+#else
+
+#ifndef _7ZIP_INT64_DEFINED
+#define _7ZIP_INT64_DEFINED
+typedef long long int Int64;
+#endif 
+
+#ifndef _7ZIP_UINT64_DEFINED
+#define _7ZIP_UINT64_DEFINED
+typedef unsigned long long int UInt64;
+#endif 
+
+#endif
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Types.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,74 @@
+// Common/Vector.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &lt;string.h&gt;
+
+#include &quot;Vector.h&quot;
+
+CBaseRecordVector::~CBaseRecordVector()
+  { delete []((unsigned char *)_items); }
+void CBaseRecordVector::Clear() 
+  { DeleteFrom(0); }
+void CBaseRecordVector::DeleteBack() 
+  { Delete(_size - 1); }
+void CBaseRecordVector::DeleteFrom(int index)
+  { Delete(index, _size - index); }
+
+void CBaseRecordVector::ReserveOnePosition()
+{
+  if(_size != _capacity)
+    return;
+  int delta;
+  if (_capacity &gt; 64)
+    delta = _capacity / 2;
+  else if (_capacity &gt; 8)
+    delta = 8;
+  else
+    delta = 4;
+  Reserve(_capacity + delta);
+}
+
+void CBaseRecordVector::Reserve(int newCapacity)
+{
+  if(newCapacity &lt;= _capacity)
+    return;
+  /*
+  #ifndef _DEBUG
+  static const unsigned int kMaxVectorSize = 0xF0000000;
+  if(newCapacity &lt; _size || 
+      ((unsigned int )newCapacity * (unsigned int )_itemSize) &gt; kMaxVectorSize) 
+    throw 1052354;
+  #endif
+  */
+  unsigned char *p = new unsigned char[newCapacity * _itemSize];
+  int numRecordsToMove = _capacity;
+  memmove(p, _items, _itemSize * numRecordsToMove);
+  delete [](unsigned char *)_items;
+  _items = p;
+  _capacity = newCapacity;
+}
+
+void CBaseRecordVector::MoveItems(int destIndex, int srcIndex)
+{
+  memmove(((unsigned char *)_items) + destIndex * _itemSize, 
+    ((unsigned char  *)_items) + srcIndex * _itemSize, 
+    _itemSize * (_size - srcIndex));
+}
+
+void CBaseRecordVector::InsertOneItem(int index)
+{
+  ReserveOnePosition();
+  MoveItems(index + 1, index);
+  _size++;
+}
+
+void CBaseRecordVector::Delete(int index, int num)
+{
+  TestIndexAndCorrectNum(index, num);
+  if (num &gt; 0)
+  {
+    MoveItems(index, index + num);
+    _size -= num;
+  }
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,228 @@
+// Common/Vector.h
+
+#ifndef __COMMON_VECTOR_H
+#define __COMMON_VECTOR_H
+
+#include &quot;Defs.h&quot;
+
+class CBaseRecordVector
+{
+  void MoveItems(int destIndex, int srcIndex);
+protected:
+	int _capacity;
+  int _size;
+	void *_items;
+  size_t _itemSize;
+
+	void ReserveOnePosition();
+  void InsertOneItem(int index);
+  void TestIndexAndCorrectNum(int index, int &amp;num) const
+    { if (index + num &gt; _size) num = _size - index; } 
+public:
+  CBaseRecordVector(size_t itemSize):
+      _capacity(0), _size(0), _items(0), _itemSize(itemSize) {}
+	virtual ~CBaseRecordVector();
+  int Size() const { return _size; }
+	bool IsEmpty() const { return (_size == 0); }
+	void Reserve(int newCapacity);
+	virtual void Delete(int index, int num = 1);
+	void Clear();
+  void DeleteFrom(int index);
+  void DeleteBack();
+};
+
+template &lt;class T&gt;
+class CRecordVector: public CBaseRecordVector
+{
+public:
+  CRecordVector():CBaseRecordVector(sizeof(T)){};
+  CRecordVector(const CRecordVector &amp;v):
+    CBaseRecordVector(sizeof(T)) { *this = v;}
+	CRecordVector&amp; operator=(const CRecordVector &amp;v)
+  {
+    Clear();
+    return (*this += v);
+  }
+  CRecordVector&amp; operator+=(const CRecordVector &amp;v)
+  {
+    int size = v.Size();
+    Reserve(Size() + size);
+    for(int i = 0; i &lt; size; i++)
+      Add(v[i]);
+    return *this;
+  }
+	int Add(T item)
+  {
+    ReserveOnePosition();
+    ((T *)_items)[_size] = item;
+    return _size++;
+  }
+	void Insert(int index, T item)
+  {
+    InsertOneItem(index);
+    ((T *)_items)[index] = item;
+  }
+  // T* GetPointer() const { return (T*)_items; }
+  // operator const T *() const { return _items; };
+  const T&amp; operator[](int index) const { return ((T *)_items)[index]; }
+	T&amp; operator[](int index) { return ((T *)_items)[index]; }
+	const T&amp; Front() const { return operator[](0); }
+  T&amp; Front()   { return operator[](0); }
+	const T&amp; Back() const { return operator[](_size - 1); }
+  T&amp; Back()   { return operator[](_size - 1); }
+
+  void Swap(int i, int j)
+  {
+    T temp = operator[](i);
+    operator[](i) = operator[](j);
+    operator[](j) = temp;
+  }
+
+  int FindInSorted(const T&amp; item) const
+  {
+    int left = 0, right = Size(); 
+    while (left != right)
+    {
+      int mid = (left + right) / 2;
+      const T&amp; midValue = (*this)[mid];
+      if (item == midValue)
+        return mid;
+      if (item &lt; midValue)
+        right = mid;
+      else
+        left = mid + 1;
+    }
+    return -1;
+  }
+
+  void Sort(int left, int right)
+  { 
+    if (right - left &lt; 2)
+      return;
+    Swap(left, (left + right) / 2);
+    int last = left;
+    for (int i = left; i &lt; right; i++)
+      if (operator[](i) &lt; operator[](left))
+        Swap(++last, i);
+    Swap(left, last);
+    Sort(left, last);
+    Sort(last + 1, right);
+  }
+  void Sort() { Sort(0, Size());  }
+  void Sort(int left, int right, int (*compare)(const T*, const T*, void *), void *param)
+  { 
+    if (right - left &lt; 2)
+      return;
+    Swap(left, (left + right) / 2);
+    int last = left;
+    for (int i = left; i &lt; right; i++)
+      if (compare(&amp;operator[](i), &amp;operator[](left), param) &lt; 0)
+        Swap(++last, i);
+    Swap(left, last);
+    Sort(left, last, compare, param);
+    Sort(last + 1, right, compare, param);
+  }
+
+  void Sort(int (*compare)(const T*, const T*, void *), void *param) 
+  {  
+    Sort(0, Size(), compare, param);  
+  }
+};
+
+typedef CRecordVector&lt;int&gt; CIntVector;
+typedef CRecordVector&lt;unsigned int&gt; CUIntVector;
+typedef CRecordVector&lt;bool&gt; CBoolVector;
+typedef CRecordVector&lt;unsigned char&gt; CByteVector;
+typedef CRecordVector&lt;void *&gt; CPointerVector;
+
+template &lt;class T&gt;
+class CObjectVector: public CPointerVector
+{
+public:
+  CObjectVector(){};
+  ~CObjectVector() { Clear(); }
+  CObjectVector(const CObjectVector &amp;objectVector)
+    { *this = objectVector; }
+	CObjectVector&amp; operator=(const CObjectVector &amp;objectVector)
+  {
+    Clear();
+    return (*this += objectVector);
+  }
+	CObjectVector&amp; operator+=(const CObjectVector &amp;objectVector)
+  {
+    int size = objectVector.Size();
+    Reserve(Size() + size);
+    for(int i = 0; i &lt; size; i++)
+      Add(objectVector[i]);
+    return *this;
+  }
+	const T&amp; operator[](int index) const { return *((T *)CPointerVector::operator[](index)); }
+	T&amp; operator[](int index) { return *((T *)CPointerVector::operator[](index)); }
+	T&amp; Front() { return operator[](0); }
+	const T&amp; Front() const { return operator[](0); }
+	T&amp; Back() { return operator[](_size - 1); }
+	const T&amp; Back() const { return operator[](_size - 1); }
+	int Add(const T&amp; item)
+    { return CPointerVector::Add(new T(item)); }
+	void Insert(int index, const T&amp; item)
+    { CPointerVector::Insert(index, new T(item)); }
+	virtual void Delete(int index, int num = 1)
+  {
+    TestIndexAndCorrectNum(index, num);
+    for(int i = 0; i &lt; num; i++)
+      delete (T *)(((void **)_items)[index + i]);
+    CPointerVector::Delete(index, num);
+  }
+  int Find(const T&amp; item) const
+  {
+    for(int i = 0; i &lt; Size(); i++)
+      if (item == (*this)[i])
+        return i;
+      return -1;
+  }
+  int FindInSorted(const T&amp; item) const
+  {
+    int left = 0, right = Size(); 
+    while (left != right)
+    {
+      int mid = (left + right) / 2;
+      const T&amp; midValue = (*this)[mid];
+      if (item == midValue)
+        return mid;
+      if (item &lt; midValue)
+        right = mid;
+      else
+        left = mid + 1;
+    }
+    return -1;
+  }
+  int AddToSorted(const T&amp; item)
+  {
+    int left = 0, right = Size(); 
+    while (left != right)
+    {
+      int mid = (left + right) / 2;
+      const T&amp; midValue = (*this)[mid];
+      if (item == midValue)
+      {
+        right = mid + 1;
+        break;
+      }
+      if (item &lt; midValue)
+        right = mid;
+      else
+        left = mid + 1;
+    }
+    Insert(right, item);
+    return right;
+  }
+
+  void Sort(int (*compare)(void *const *, void *const *, void *), void *param) 
+    { CPointerVector::Sort(compare, param); }
+
+  static int CompareObjectItems(void *const *a1, void *const *a2, void *param)
+    { return MyCompare(*(*((const T **)a1)), *(*((const T **)a2))); }
+  void Sort() { CPointerVector::Sort(CompareObjectItems, 0); }
+};
+
+#endif 


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Common/Vector.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/Defs.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/Defs.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/Defs.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,18 @@
+// Windows/Defs.h
+
+#ifndef __WINDOWS_DEFS_H
+#define __WINDOWS_DEFS_H
+
+inline bool BOOLToBool(BOOL value)
+  { return (value != FALSE); }
+
+inline BOOL BoolToBOOL(bool value)
+  { return (value ? TRUE: FALSE); }
+
+inline VARIANT_BOOL BoolToVARIANT_BOOL(bool value)
+  { return (value ? VARIANT_TRUE: VARIANT_FALSE); }
+
+inline bool VARIANT_BOOLToBool(VARIANT_BOOL value)
+  { return (value != VARIANT_FALSE); }
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/Defs.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.cpp
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.cpp	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.cpp	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,245 @@
+// Windows/FileIO.cpp
+
+#include &quot;StdAfx.h&quot;
+
+#include &quot;FileIO.h&quot;
+#include &quot;Defs.h&quot;
+#ifndef _UNICODE
+#include &quot;../Common/StringConvert.h&quot;
+#endif
+
+#ifndef _UNICODE
+extern bool g_IsNT;
+#endif
+
+namespace NWindows {
+namespace NFile {
+namespace NIO {
+
+CFileBase::~CFileBase() { Close(); }
+
+bool CFileBase::Create(LPCTSTR fileName, DWORD desiredAccess,
+    DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+{
+  Close();
+  _handle = ::CreateFile(fileName, desiredAccess, shareMode, 
+      (LPSECURITY_ATTRIBUTES)NULL, creationDisposition, 
+      flagsAndAttributes, (HANDLE) NULL);
+  return (_fileIsOpen = (_handle != INVALID_HANDLE_VALUE));
+}
+
+#ifndef _UNICODE
+bool CFileBase::Create(LPCWSTR fileName, DWORD desiredAccess,
+    DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+{
+  if (g_IsNT)
+  {
+    Close();
+    _handle = ::CreateFileW(fileName, desiredAccess, shareMode, 
+      (LPSECURITY_ATTRIBUTES)NULL, creationDisposition, 
+      flagsAndAttributes, (HANDLE) NULL);
+    return (_fileIsOpen = (_handle != INVALID_HANDLE_VALUE));
+  }
+  return Create(UnicodeStringToMultiByte(fileName, ::AreFileApisANSI() ? CP_ACP : CP_OEMCP), 
+    desiredAccess, shareMode, creationDisposition, flagsAndAttributes);
+}
+#endif
+
+bool CFileBase::Close()
+{
+  if(!_fileIsOpen)
+    return true;
+  bool result = BOOLToBool(::CloseHandle(_handle));
+  _fileIsOpen = !result;
+  return result;
+}
+
+bool CFileBase::GetPosition(UInt64 &amp;position) const
+{
+  return Seek(0, FILE_CURRENT, position);
+}
+
+bool CFileBase::GetLength(UInt64 &amp;length) const
+{
+  DWORD sizeHigh;
+  DWORD sizeLow = ::GetFileSize(_handle, &amp;sizeHigh);
+  if(sizeLow == 0xFFFFFFFF)
+    if(::GetLastError() != NO_ERROR)
+      return false;
+  length = (((UInt64)sizeHigh) &lt;&lt; 32) + sizeLow;
+  return true;
+}
+
+bool CFileBase::Seek(Int64 distanceToMove, DWORD moveMethod, UInt64 &amp;newPosition) const
+{
+  LARGE_INTEGER value;
+  value.QuadPart = distanceToMove;
+  value.LowPart = ::SetFilePointer(_handle, value.LowPart, &amp;value.HighPart, moveMethod);
+  if (value.LowPart == 0xFFFFFFFF)
+    if(::GetLastError() != NO_ERROR) 
+      return false;
+  newPosition = value.QuadPart;
+  return true;
+}
+
+bool CFileBase::Seek(UInt64 position, UInt64 &amp;newPosition)
+{
+  return Seek(position, FILE_BEGIN, newPosition);
+}
+
+bool CFileBase::SeekToBegin()
+{
+  UInt64 newPosition;
+  return Seek(0, newPosition);
+}
+
+bool CFileBase::SeekToEnd(UInt64 &amp;newPosition)
+{
+  return Seek(0, FILE_END, newPosition);
+}
+
+bool CFileBase::GetFileInformation(CByHandleFileInfo &amp;fileInfo) const
+{
+  BY_HANDLE_FILE_INFORMATION winFileInfo;
+  if(!::GetFileInformationByHandle(_handle, &amp;winFileInfo))
+    return false;
+  fileInfo.Attributes = winFileInfo.dwFileAttributes;
+  fileInfo.CreationTime = winFileInfo.ftCreationTime;
+  fileInfo.LastAccessTime = winFileInfo.ftLastAccessTime;
+  fileInfo.LastWriteTime = winFileInfo.ftLastWriteTime;
+  fileInfo.VolumeSerialNumber = winFileInfo.dwFileAttributes; 
+  fileInfo.Size = (((UInt64)winFileInfo.nFileSizeHigh) &lt;&lt; 32) +  winFileInfo.nFileSizeLow;
+  fileInfo.NumberOfLinks = winFileInfo.nNumberOfLinks;
+  fileInfo.FileIndex = (((UInt64)winFileInfo.nFileIndexHigh) &lt;&lt; 32) + winFileInfo.nFileIndexLow;
+  return true;
+}
+
+/////////////////////////
+// CInFile
+
+bool CInFile::Open(LPCTSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+  { return Create(fileName, GENERIC_READ, shareMode, creationDisposition, flagsAndAttributes); }
+
+bool CInFile::Open(LPCTSTR fileName)
+  { return Open(fileName, FILE_SHARE_READ, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL); }
+
+#ifndef _UNICODE
+bool CInFile::Open(LPCWSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+  { return Create(fileName, GENERIC_READ, shareMode, creationDisposition, flagsAndAttributes); }
+
+bool CInFile::Open(LPCWSTR fileName)
+  { return Open(fileName, FILE_SHARE_READ, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL); }
+#endif
+
+// ReadFile and WriteFile functions in Windows have BUG:
+// If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1) 
+// from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES 
+// (Insufficient system resources exist to complete the requested service).
+
+static UInt32 kChunkSizeMax = (1 &lt;&lt; 24);
+
+bool CInFile::ReadPart(void *data, UInt32 size, UInt32 &amp;processedSize)
+{
+  if (size &gt; kChunkSizeMax)
+    size = kChunkSizeMax;
+  DWORD processedLoc = 0;
+  bool res = BOOLToBool(::ReadFile(_handle, data, size, &amp;processedLoc, NULL));
+  processedSize = (UInt32)processedLoc;
+  return res;
+}
+
+bool CInFile::Read(void *data, UInt32 size, UInt32 &amp;processedSize)
+{
+  processedSize = 0;
+  do
+  {
+    UInt32 processedLoc = 0;
+    bool res = ReadPart(data, size, processedLoc);
+    processedSize += processedLoc;
+    if (!res)
+      return false;
+    if (processedLoc == 0)
+      return true;
+    data = (void *)((unsigned char *)data + processedLoc);
+    size -= processedLoc;
+  }
+  while (size &gt; 0);
+  return true;
+}
+
+/////////////////////////
+// COutFile
+
+bool COutFile::Open(LPCTSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+  { return CFileBase::Create(fileName, GENERIC_WRITE, shareMode, creationDisposition, flagsAndAttributes); }
+
+static inline DWORD GetCreationDisposition(bool createAlways)
+  { return createAlways? CREATE_ALWAYS: CREATE_NEW; }
+
+bool COutFile::Open(LPCTSTR fileName, DWORD creationDisposition)
+  { return Open(fileName, FILE_SHARE_READ, creationDisposition, FILE_ATTRIBUTE_NORMAL); }
+
+bool COutFile::Create(LPCTSTR fileName, bool createAlways)
+  { return Open(fileName, GetCreationDisposition(createAlways)); }
+
+#ifndef _UNICODE
+
+bool COutFile::Open(LPCWSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+  { return CFileBase::Create(fileName, GENERIC_WRITE, shareMode,      creationDisposition, flagsAndAttributes); }
+
+bool COutFile::Open(LPCWSTR fileName, DWORD creationDisposition)
+  { return Open(fileName, FILE_SHARE_READ,  creationDisposition, FILE_ATTRIBUTE_NORMAL); }
+
+bool COutFile::Create(LPCWSTR fileName, bool createAlways)
+  { return Open(fileName, GetCreationDisposition(createAlways)); }
+
+#endif
+
+bool COutFile::SetTime(const FILETIME *creationTime, const FILETIME *lastAccessTime, const FILETIME *lastWriteTime)
+  { return BOOLToBool(::SetFileTime(_handle, creationTime, lastAccessTime, lastWriteTime)); }
+
+bool COutFile::SetLastWriteTime(const FILETIME *lastWriteTime)
+  {  return SetTime(NULL, NULL, lastWriteTime); }
+
+bool COutFile::WritePart(const void *data, UInt32 size, UInt32 &amp;processedSize)
+{
+  if (size &gt; kChunkSizeMax)
+    size = kChunkSizeMax;
+  DWORD processedLoc = 0;
+  bool res = BOOLToBool(::WriteFile(_handle, data, size, &amp;processedLoc, NULL));
+  processedSize = (UInt32)processedLoc;
+  return res;
+}
+
+bool COutFile::Write(const void *data, UInt32 size, UInt32 &amp;processedSize)
+{
+  processedSize = 0;
+  do
+  {
+    UInt32 processedLoc = 0;
+    bool res = WritePart(data, size, processedLoc);
+    processedSize += processedLoc;
+    if (!res)
+      return false;
+    if (processedLoc == 0)
+      return true;
+    data = (const void *)((const unsigned char *)data + processedLoc);
+    size -= processedLoc;
+  }
+  while (size &gt; 0);
+  return true;
+}
+
+bool COutFile::SetEndOfFile() { return BOOLToBool(::SetEndOfFile(_handle)); }
+
+bool COutFile::SetLength(UInt64 length)
+{
+  UInt64 newPosition;
+  if(!Seek(length, newPosition))
+    return false;
+  if(newPosition != length)
+    return false;
+  return SetEndOfFile();
+}
+
+}}}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,98 @@
+// Windows/FileIO.h
+
+#ifndef __WINDOWS_FILEIO_H
+#define __WINDOWS_FILEIO_H
+
+#include &quot;../Common/Types.h&quot;
+
+namespace NWindows {
+namespace NFile {
+namespace NIO {
+
+struct CByHandleFileInfo
+{ 
+  DWORD    Attributes; 
+  FILETIME CreationTime; 
+  FILETIME LastAccessTime; 
+  FILETIME LastWriteTime; 
+  DWORD    VolumeSerialNumber; 
+  UInt64   Size;
+  DWORD    NumberOfLinks; 
+  UInt64   FileIndex; 
+};
+
+class CFileBase
+{
+protected:
+  bool _fileIsOpen;
+  HANDLE _handle;
+  bool Create(LPCTSTR fileName, DWORD desiredAccess,
+      DWORD shareMode, DWORD creationDisposition,  DWORD flagsAndAttributes);
+  #ifndef _UNICODE
+  bool Create(LPCWSTR fileName, DWORD desiredAccess,
+      DWORD shareMode, DWORD creationDisposition,  DWORD flagsAndAttributes);
+  #endif
+
+public:
+  CFileBase(): _fileIsOpen(false){};
+  virtual ~CFileBase();
+
+  virtual bool Close();
+
+  bool GetPosition(UInt64 &amp;position) const;
+  bool GetLength(UInt64 &amp;length) const;
+
+  bool Seek(Int64 distanceToMove, DWORD moveMethod, UInt64 &amp;newPosition) const;
+  bool Seek(UInt64 position, UInt64 &amp;newPosition); 
+  bool SeekToBegin(); 
+  bool SeekToEnd(UInt64 &amp;newPosition); 
+  
+  bool GetFileInformation(CByHandleFileInfo &amp;fileInfo) const;
+};
+
+class CInFile: public CFileBase
+{
+public:
+  bool Open(LPCTSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes);
+  bool Open(LPCTSTR fileName);
+  #ifndef _UNICODE
+  bool Open(LPCWSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes);
+  bool Open(LPCWSTR fileName);
+  #endif
+  bool ReadPart(void *data, UInt32 size, UInt32 &amp;processedSize);
+  bool Read(void *data, UInt32 size, UInt32 &amp;processedSize);
+};
+
+class COutFile: public CFileBase
+{
+  // DWORD m_CreationDisposition;
+public:
+  // COutFile(): m_CreationDisposition(CREATE_NEW){};
+  bool Open(LPCTSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes);
+  bool Open(LPCTSTR fileName, DWORD creationDisposition);
+  bool Create(LPCTSTR fileName, bool createAlways);
+
+  #ifndef _UNICODE
+  bool Open(LPCWSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes);
+  bool Open(LPCWSTR fileName, DWORD creationDisposition);
+  bool Create(LPCWSTR fileName, bool createAlways);
+  #endif
+
+  /*
+  void SetOpenCreationDisposition(DWORD creationDisposition)
+    { m_CreationDisposition = creationDisposition; }
+  void SetOpenCreationDispositionCreateAlways()
+    { m_CreationDisposition = CREATE_ALWAYS; }
+  */
+
+  bool SetTime(const FILETIME *creationTime, const FILETIME *lastAccessTime, const FILETIME *lastWriteTime);
+  bool SetLastWriteTime(const FILETIME *lastWriteTime);
+  bool WritePart(const void *data, UInt32 size, UInt32 &amp;processedSize);
+  bool Write(const void *data, UInt32 size, UInt32 &amp;processedSize);
+  bool SetEndOfFile();
+  bool SetLength(UInt64 length);
+};
+
+}}}
+
+#endif


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/FileIO.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/StdAfx.h
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/StdAfx.h	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/StdAfx.h	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,9 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include &quot;../Common/MyWindows.h&quot;
+#include &quot;../Common/NewHandler.h&quot;
+
+#endif 


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/C/Windows/StdAfx.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CPL.html
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CPL.html	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CPL.html	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,224 @@
+&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
+&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Common Public License - v 1.0&lt;/TITLE&gt;
+&lt;META http-equiv=Content-Type content=&quot;text/html; charset=ISO-8859-1&quot;&gt;
+&lt;BODY vLink=#800000 bgColor=#ffffff&gt;
+&lt;P align=center&gt;&lt;B&gt;Common Public License - v 1.0&lt;/B&gt; 
+&lt;P&gt;&lt;B&gt;&lt;/B&gt;&lt;FONT size=3&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=3&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;THE ACCOMPANYING PROGRAM IS PROVIDED UNDER 
+THE TERMS OF THIS COMMON PUBLIC LICENSE (&quot;AGREEMENT&quot;). ANY USE, REPRODUCTION OR 
+DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS 
+AGREEMENT.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;B&gt;1. DEFINITIONS&lt;/B&gt;&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&quot;Contribution&quot; means:&lt;/FONT&gt; 
+&lt;UL&gt;&lt;FONT size=2&gt;a) in the case of the initial Contributor, the initial code 
+  and documentation distributed under this Agreement, and&lt;BR clear=left&gt;b) in 
+  the case of each subsequent Contributor:&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;i) changes to the Program, and&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;ii) additions to the Program;&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;where such changes and/or additions to the Program originate 
+  from and are distributed by that particular Contributor. &lt;/FONT&gt;&lt;FONT size=2&gt;A 
+  Contribution 'originates' from a Contributor if it was added to the Program by 
+  such Contributor itself or anyone acting on such Contributor's behalf. 
+  &lt;/FONT&gt;&lt;FONT size=2&gt;Contributions do not include additions to the Program 
+  which: (i) are separate modules of software distributed in conjunction with 
+  the Program under their own license agreement, and (ii) are not derivative 
+  works of the Program. &lt;/FONT&gt;&lt;/UL&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&quot;Contributor&quot; means any person or entity that distributes the 
+Program.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&quot;Licensed Patents &quot; mean patent claims licensable by a 
+Contributor which are necessarily infringed by the use or sale of its 
+Contribution alone or when combined with the Program. &lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;&quot;Program&quot; means the Contributions 
+distributed in accordance with this Agreement.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&quot;Recipient&quot; means anyone who receives the Program under this 
+Agreement, including all Contributors.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;B&gt;&lt;/B&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;B&gt;2. GRANT OF RIGHTS&lt;/B&gt;&lt;/FONT&gt; 
+&lt;UL&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;a) &lt;/FONT&gt;&lt;FONT size=2&gt;Subject to the 
+  terms of this Agreement, each Contributor hereby grants&lt;/FONT&gt;&lt;FONT size=2&gt; 
+  Recipient a non-exclusive, worldwide, royalty-free copyright license 
+  to&lt;/FONT&gt;&lt;FONT color=#ff0000 size=2&gt; &lt;/FONT&gt;&lt;FONT size=2&gt;reproduce, prepare 
+  derivative works of, publicly display, publicly perform, distribute and 
+  sublicense the Contribution of such Contributor, if any, and such derivative 
+  works, in source code and object code form.&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;b) Subject to the terms of this 
+  Agreement, each Contributor hereby grants &lt;/FONT&gt;&lt;FONT size=2&gt;Recipient a 
+  non-exclusive, worldwide,&lt;/FONT&gt;&lt;FONT color=#008000 size=2&gt; &lt;/FONT&gt;&lt;FONT 
+  size=2&gt;royalty-free patent license under Licensed Patents to make, use, sell, 
+  offer to sell, import and otherwise transfer the Contribution of such 
+  Contributor, if any, in source code and object code form. This patent license 
+  shall apply to the combination of the Contribution and the Program if, at the 
+  time the Contribution is added by the Contributor, such addition of the 
+  Contribution causes such combination to be covered by the Licensed Patents. 
+  The patent license shall not apply to any other combinations which include the 
+  Contribution. No hardware per se is licensed hereunder. &lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;c) Recipient understands that although each Contributor 
+  grants the licenses to its Contributions set forth herein, no assurances are 
+  provided by any Contributor that the Program does not infringe the patent or 
+  other intellectual property rights of any other entity. Each Contributor 
+  disclaims any liability to Recipient for claims brought by any other entity 
+  based on infringement of intellectual property rights or otherwise. As a 
+  condition to exercising the rights and licenses granted hereunder, each 
+  Recipient hereby assumes sole responsibility to secure any other intellectual 
+  property rights needed, if any. For example, if a third party patent license 
+  is required to allow Recipient to distribute the Program, it is Recipient's 
+  responsibility to acquire that license before distributing the 
+Program.&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;d) Each Contributor represents that to its knowledge it has 
+  sufficient copyright rights in its Contribution, if any, to grant the 
+  copyright license set forth in this Agreement. &lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;/UL&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;B&gt;3. REQUIREMENTS&lt;/B&gt;&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;B&gt;&lt;/B&gt;A Contributor may choose to distribute the Program in 
+object code form under its own license agreement, provided that:&lt;/FONT&gt; 
+&lt;UL&gt;&lt;FONT size=2&gt;a) it complies with the terms and conditions of this 
+  Agreement; and&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;b) its license agreement:&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;i) effectively disclaims&lt;/FONT&gt;&lt;FONT size=2&gt; on behalf of all 
+  Contributors all warranties and conditions, express and implied, including 
+  warranties or conditions of title and non-infringement, and implied warranties 
+  or conditions of merchantability and fitness for a particular purpose; 
+&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;ii) effectively excludes on behalf of all Contributors all 
+  liability for damages, including direct, indirect, special, incidental and 
+  consequential damages, such as lost profits; &lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;iii)&lt;/FONT&gt;&lt;FONT size=2&gt; states that any provisions which 
+  differ from this Agreement are offered by that Contributor alone and not by 
+  any other party; and&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;iv) states that source code for the Program is available from 
+  such Contributor, and informs licensees how to obtain it in a reasonable 
+  manner on or through a medium customarily used for software 
+  exchange.&lt;/FONT&gt;&lt;FONT color=#0000ff size=2&gt; &lt;/FONT&gt;&lt;FONT color=#ff0000 
+  size=2&gt;&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT color=#ff0000 size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;/UL&gt;
+&lt;P&gt;&lt;FONT size=2&gt;When the Program is made available in source code form:&lt;/FONT&gt; 
+&lt;UL&gt;&lt;FONT size=2&gt;a) it must be made available under this Agreement; and 
+&lt;/FONT&gt;&lt;/UL&gt;
+&lt;UL&gt;&lt;FONT size=2&gt;b) a copy of this Agreement must be included with each copy 
+  of the Program. &lt;/FONT&gt;&lt;/UL&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT color=#0000ff size=2&gt;&lt;STRIKE&gt;&lt;/STRIKE&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT color=#0000ff size=2&gt;&lt;STRIKE&gt;&lt;/STRIKE&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;Contributors 
+may not remove or alter any copyright notices contained within the Program. 
+&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;Each Contributor must identify itself as the originator of its 
+Contribution, if any, in a manner that reasonably allows subsequent Recipients 
+to identify the originator of the Contribution. &lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;B&gt;4. COMMERCIAL DISTRIBUTION&lt;/B&gt;&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;Commercial distributors of software may accept certain 
+responsibilities with respect to end users, business partners and the like. 
+While this license is intended to facilitate the commercial use of the Program, 
+the Contributor who includes the Program in a commercial product offering should 
+do so in a manner which does not create potential liability for other 
+Contributors. Therefore, if a Contributor includes the Program in a commercial 
+product offering, such Contributor (&quot;Commercial Contributor&quot;) hereby agrees to 
+defend and indemnify every other Contributor (&quot;Indemnified Contributor&quot;) against 
+any losses, damages and costs (collectively &quot;Losses&quot;) arising from claims, 
+lawsuits and other legal actions brought by a third party against the 
+Indemnified Contributor to the extent caused by the acts or omissions of such 
+Commercial Contributor in connection with its distribution of the Program in a 
+commercial product offering. The obligations in this section do not apply to any 
+claims or Losses relating to any actual or alleged intellectual property 
+infringement. In order to qualify, an Indemnified Contributor must: a) promptly 
+notify the Commercial Contributor in writing of such claim, and b) allow the 
+Commercial Contributor to control, and cooperate with the Commercial Contributor 
+in, the defense and any related settlement negotiations. The Indemnified 
+Contributor may participate in any such claim at its own expense.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;For example, a Contributor might include the Program in a 
+commercial product offering, Product X. That Contributor is then a Commercial 
+Contributor. If that Commercial Contributor then makes performance claims, or 
+offers warranties related to Product X, those performance claims and warranties 
+are such Commercial Contributor's responsibility alone. Under this section, the 
+Commercial Contributor would have to defend claims against the other 
+Contributors related to those performance claims and warranties, and if a court 
+requires any other Contributor to pay any damages as a result, the Commercial 
+Contributor must pay those damages.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT color=#0000ff size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT color=#0000ff size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;&lt;B&gt;5. NO WARRANTY&lt;/B&gt;&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS 
+PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
+EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR 
+CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A 
+PARTICULAR PURPOSE. Each Recipient is&lt;/FONT&gt;&lt;FONT size=2&gt; solely responsible for 
+determining the appropriateness of using and distributing &lt;/FONT&gt;&lt;FONT 
+size=2&gt;the Program&lt;/FONT&gt;&lt;FONT size=2&gt; and assumes all risks associated with its 
+exercise of rights under this Agreement&lt;/FONT&gt;&lt;FONT size=2&gt;, including but not 
+limited to the risks and costs of program errors, compliance with applicable 
+laws, damage to or loss of data, &lt;/FONT&gt;&lt;FONT size=2&gt;programs or equipment, and 
+unavailability or interruption of operations&lt;/FONT&gt;&lt;FONT size=2&gt;. &lt;/FONT&gt;&lt;FONT 
+size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;&lt;B&gt;6. DISCLAIMER OF LIABILITY&lt;/B&gt;&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;EXCEPT AS EXPRESSLY SET FORTH IN THIS 
+AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+&lt;/FONT&gt;&lt;FONT size=2&gt;(INCLUDING WITHOUT LIMITATION LOST PROFITS),&lt;/FONT&gt;&lt;FONT 
+size=2&gt; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
+OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS 
+GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;B&gt;7. GENERAL&lt;/B&gt;&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;If any provision of this Agreement is 
+invalid or unenforceable under applicable law, it shall not affect the validity 
+or enforceability of the remainder of the terms of this Agreement, and without 
+further action by the parties hereto, such provision shall be reformed to the 
+minimum extent necessary to make such provision valid and enforceable.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;If Recipient institutes patent litigation against a Contributor 
+with respect to a patent applicable to software (including a cross-claim or 
+counterclaim in a lawsuit), then any patent licenses granted by that Contributor 
+to such Recipient under this Agreement shall terminate as of the date such 
+litigation is filed. In addition, if Recipient institutes patent litigation 
+against any entity (including a cross-claim or counterclaim in a lawsuit) 
+alleging that the Program itself (excluding combinations of the Program with 
+other software or hardware) infringes such Recipient's patent(s), then such 
+Recipient's rights granted under Section 2(b) shall terminate as of the date 
+such litigation is filed. &lt;/FONT&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;All Recipient's rights under this Agreement shall terminate if 
+it fails to comply with any of the material terms or conditions of this 
+Agreement and does not cure such failure in a reasonable period of time after 
+becoming aware of such noncompliance. If all Recipient's rights under this 
+Agreement terminate, Recipient agrees to cease use and distribution of the 
+Program as soon as reasonably practicable. However, Recipient's obligations 
+under this Agreement and any licenses granted by Recipient relating to the 
+Program shall continue and survive. &lt;/FONT&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;Everyone is permitted to copy and distribute 
+copies of this Agreement, but in order to avoid inconsistency the Agreement is 
+copyrighted and may only be modified in the following manner. The Agreement 
+Steward reserves the right to &lt;/FONT&gt;&lt;FONT size=2&gt;publish new versions 
+(including revisions) of this Agreement from time to &lt;/FONT&gt;&lt;FONT size=2&gt;time. 
+No one other than the Agreement Steward has the right to modify this Agreement. 
+IBM is the initial Agreement Steward. IBM may assign the responsibility to serve 
+as the Agreement Steward to a suitable separate entity. &lt;/FONT&gt;&lt;FONT size=2&gt;Each 
+new version of the Agreement will be given a distinguishing version number. The 
+Program (including Contributions) may always be distributed subject to the 
+version of the Agreement under which it was received. In addition, after a new 
+version of the Agreement is published, Contributor may elect to distribute the 
+Program (including its Contributions) under the new &lt;/FONT&gt;&lt;FONT size=2&gt;version. 
+&lt;/FONT&gt;&lt;FONT size=2&gt;Except as expressly stated in Sections 2(a) and 2(b) above, 
+Recipient receives no rights or licenses to the intellectual property of any 
+Contributor under this Agreement, whether expressly, &lt;/FONT&gt;&lt;FONT size=2&gt;by 
+implication, estoppel or otherwise&lt;/FONT&gt;&lt;FONT size=2&gt;.&lt;/FONT&gt;&lt;FONT size=2&gt; All 
+rights in the Program not expressly granted under this Agreement are 
+reserved.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;This Agreement is governed by the laws of the State of New York 
+and the intellectual property laws of the United States of America. No party to 
+this Agreement will bring a legal action under this Agreement more than one year 
+after the cause of action arose. Each party waives its rights to a jury trial in 
+any resulting litigation.&lt;/FONT&gt; 
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;
+&lt;P&gt;&lt;FONT size=2&gt;&lt;/FONT&gt;&lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CPL.html
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CRC.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CRC.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CRC.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,55 @@
+// Common/CRC.cs
+
+namespace SevenZip
+{
+	class CRC
+	{
+		public static readonly uint[] Table;
+
+		static CRC()
+		{
+			Table = new uint[256];
+			const uint kPoly = 0xEDB88320;
+			for (uint i = 0; i &lt; 256; i++)
+			{
+				uint r = i;
+				for (int j = 0; j &lt; 8; j++)
+					if ((r &amp; 1) != 0)
+						r = (r &gt;&gt; 1) ^ kPoly;
+					else
+						r &gt;&gt;= 1;
+				Table[i] = r;
+			}
+		}
+
+		uint _value = 0xFFFFFFFF;
+
+		public void Init() { _value = 0xFFFFFFFF; }
+
+		public void UpdateByte(byte b)
+		{
+			_value = Table[(((byte)(_value)) ^ b)] ^ (_value &gt;&gt; 8);
+		}
+
+		public void Update(byte[] data, uint offset, uint size)
+		{
+			for (uint i = 0; i &lt; size; i++)
+				_value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value &gt;&gt; 8);
+		}
+
+		public uint GetDigest() { return _value ^ 0xFFFFFFFF; }
+
+		static uint CalculateDigest(byte[] data, uint offset, uint size)
+		{
+			CRC crc = new CRC();
+			// crc.Init();
+			crc.Update(data, offset, size);
+			return crc.GetDigest();
+		}
+
+		static bool VerifyDigest(uint digest, byte[] data, uint offset, uint size)
+		{
+			return (CalculateDigest(data, offset, size) == digest);
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CRC.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CommandLineParser.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CommandLineParser.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CommandLineParser.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,274 @@
+// CommandLineParser.cs
+
+using System;
+using System.Collections;
+
+namespace SevenZip.CommandLineParser
+{
+	public enum SwitchType
+	{
+		Simple,
+		PostMinus,
+		LimitedPostString,
+		UnLimitedPostString,
+		PostChar
+	}
+
+	public class SwitchForm
+	{
+		public string IDString;
+		public SwitchType Type;
+		public bool Multi;
+		public int MinLen;
+		public int MaxLen;
+		public string PostCharSet;
+
+		public SwitchForm(string idString, SwitchType type, bool multi,
+			int minLen, int maxLen, string postCharSet)
+		{
+			IDString = idString;
+			Type = type;
+			Multi = multi;
+			MinLen = minLen;
+			MaxLen = maxLen;
+			PostCharSet = postCharSet;
+		}
+		public SwitchForm(string idString, SwitchType type, bool multi, int minLen):
+			this(idString, type, multi, minLen, 0, &quot;&quot;)
+		{
+		}
+		public SwitchForm(string idString, SwitchType type, bool multi):
+			this(idString, type, multi, 0)
+		{
+		}
+	}
+
+	public class SwitchResult
+	{
+		public bool ThereIs;
+		public bool WithMinus;
+		public ArrayList PostStrings = new ArrayList();
+		public int PostCharIndex;
+		public SwitchResult()
+		{
+			ThereIs = false;
+		}
+	}
+
+	public class Parser
+	{
+		public ArrayList NonSwitchStrings = new ArrayList();
+		SwitchResult[] _switches;
+
+		public Parser(int numSwitches)
+		{
+			_switches = new SwitchResult[numSwitches];
+			for (int i = 0; i &lt; numSwitches; i++)
+				_switches[i] = new SwitchResult();
+		}
+
+		bool ParseString(string srcString, SwitchForm[] switchForms)
+		{
+			int len = srcString.Length;
+			if (len == 0)
+				return false;
+			int pos = 0;
+			if (!IsItSwitchChar(srcString[pos]))
+				return false;
+			while (pos &lt; len)
+			{
+				if (IsItSwitchChar(srcString[pos]))
+					pos++;
+				const int kNoLen = -1;
+				int matchedSwitchIndex = 0;
+				int maxLen = kNoLen;
+				for (int switchIndex = 0; switchIndex &lt; _switches.Length; switchIndex++)
+				{
+					int switchLen = switchForms[switchIndex].IDString.Length;
+					if (switchLen &lt;= maxLen || pos + switchLen &gt; len)
+						continue;
+					if (String.Compare(switchForms[switchIndex].IDString, 0,
+							srcString, pos, switchLen, true) == 0)
+					{
+						matchedSwitchIndex = switchIndex;
+						maxLen = switchLen;
+					}
+				}
+				if (maxLen == kNoLen)
+					throw new Exception(&quot;maxLen == kNoLen&quot;);
+				SwitchResult matchedSwitch = _switches[matchedSwitchIndex];
+				SwitchForm switchForm = switchForms[matchedSwitchIndex];
+				if ((!switchForm.Multi) &amp;&amp; matchedSwitch.ThereIs)
+					throw new Exception(&quot;switch must be single&quot;);
+				matchedSwitch.ThereIs = true;
+				pos += maxLen;
+				int tailSize = len - pos;
+				SwitchType type = switchForm.Type;
+				switch (type)
+				{
+					case SwitchType.PostMinus:
+						{
+							if (tailSize == 0)
+								matchedSwitch.WithMinus = false;
+							else
+							{
+								matchedSwitch.WithMinus = (srcString[pos] == kSwitchMinus);
+								if (matchedSwitch.WithMinus)
+									pos++;
+							}
+							break;
+						}
+					case SwitchType.PostChar:
+						{
+							if (tailSize &lt; switchForm.MinLen)
+								throw new Exception(&quot;switch is not full&quot;);
+							string charSet = switchForm.PostCharSet;
+							const int kEmptyCharValue = -1;
+							if (tailSize == 0)
+								matchedSwitch.PostCharIndex = kEmptyCharValue;
+							else
+							{
+								int index = charSet.IndexOf(srcString[pos]);
+								if (index &lt; 0)
+									matchedSwitch.PostCharIndex = kEmptyCharValue;
+								else
+								{
+									matchedSwitch.PostCharIndex = index;
+									pos++;
+								}
+							}
+							break;
+						}
+					case SwitchType.LimitedPostString:
+					case SwitchType.UnLimitedPostString:
+						{
+							int minLen = switchForm.MinLen;
+							if (tailSize &lt; minLen)
+								throw new Exception(&quot;switch is not full&quot;);
+							if (type == SwitchType.UnLimitedPostString)
+							{
+								matchedSwitch.PostStrings.Add(srcString.Substring(pos));
+								return true;
+							}
+							String stringSwitch = srcString.Substring(pos, minLen);
+							pos += minLen;
+							for (int i = minLen; i &lt; switchForm.MaxLen &amp;&amp; pos &lt; len; i++, pos++)
+							{
+								char c = srcString[pos];
+								if (IsItSwitchChar(c))
+									break;
+								stringSwitch += c;
+							}
+							matchedSwitch.PostStrings.Add(stringSwitch);
+							break;
+						}
+				}
+			}
+			return true;
+
+		}
+
+		public void ParseStrings(SwitchForm[] switchForms, string[] commandStrings)
+		{
+			int numCommandStrings = commandStrings.Length;
+			bool stopSwitch = false;
+			for (int i = 0; i &lt; numCommandStrings; i++)
+			{
+				string s = commandStrings[i];
+				if (stopSwitch)
+					NonSwitchStrings.Add(s);
+				else
+					if (s == kStopSwitchParsing)
+					stopSwitch = true;
+				else
+					if (!ParseString(s, switchForms))
+					NonSwitchStrings.Add(s);
+			}
+		}
+
+		public SwitchResult this[int index] { get { return _switches[index]; } }
+
+		public static int ParseCommand(CommandForm[] commandForms, string commandString,
+			out string postString)
+		{
+			for (int i = 0; i &lt; commandForms.Length; i++)
+			{
+				string id = commandForms[i].IDString;
+				if (commandForms[i].PostStringMode)
+				{
+					if (commandString.IndexOf(id) == 0)
+					{
+						postString = commandString.Substring(id.Length);
+						return i;
+					}
+				}
+				else
+					if (commandString == id)
+				{
+					postString = &quot;&quot;;
+					return i;
+				}
+			}
+			postString = &quot;&quot;;
+			return -1;
+		}
+
+		static bool ParseSubCharsCommand(int numForms, CommandSubCharsSet[] forms,
+			string commandString, ArrayList indices)
+		{
+			indices.Clear();
+			int numUsedChars = 0;
+			for (int i = 0; i &lt; numForms; i++)
+			{
+				CommandSubCharsSet charsSet = forms[i];
+				int currentIndex = -1;
+				int len = charsSet.Chars.Length;
+				for (int j = 0; j &lt; len; j++)
+				{
+					char c = charsSet.Chars[j];
+					int newIndex = commandString.IndexOf(c);
+					if (newIndex &gt;= 0)
+					{
+						if (currentIndex &gt;= 0)
+							return false;
+						if (commandString.IndexOf(c, newIndex + 1) &gt;= 0)
+							return false;
+						currentIndex = j;
+						numUsedChars++;
+					}
+				}
+				if (currentIndex == -1 &amp;&amp; !charsSet.EmptyAllowed)
+					return false;
+				indices.Add(currentIndex);
+			}
+			return (numUsedChars == commandString.Length);
+		}
+		const char kSwitchID1 = '-';
+		const char kSwitchID2 = '/';
+
+		const char kSwitchMinus = '-';
+		const string kStopSwitchParsing = &quot;--&quot;;
+
+		static bool IsItSwitchChar(char c)
+		{
+			return (c == kSwitchID1 || c == kSwitchID2);
+		}
+	}
+
+	public class CommandForm
+	{
+		public string IDString = &quot;&quot;;
+		public bool PostStringMode = false;
+		public CommandForm(string idString, bool postStringMode)
+		{
+			IDString = idString;
+			PostStringMode = postStringMode;
+		}
+	}
+
+	class CommandSubCharsSet
+	{
+		public string Chars = &quot;&quot;;
+		public bool EmptyAllowed = false;
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/CommandLineParser.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/InBuffer.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/InBuffer.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/InBuffer.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,72 @@
+// InBuffer.cs
+
+namespace SevenZip.Buffer
+{
+	public class InBuffer
+	{
+		byte[] m_Buffer;
+		uint m_Pos;
+		uint m_Limit;
+		uint m_BufferSize;
+		System.IO.Stream m_Stream;
+		bool m_StreamWasExhausted;
+		ulong m_ProcessedSize;
+
+		public InBuffer(uint bufferSize)
+		{
+			m_Buffer = new byte[bufferSize];
+			m_BufferSize = bufferSize;
+		}
+
+		public void Init(System.IO.Stream stream)
+		{
+			m_Stream = stream;
+			m_ProcessedSize = 0;
+			m_Limit = 0;
+			m_Pos = 0;
+			m_StreamWasExhausted = false;
+		}
+
+		public bool ReadBlock()
+		{
+			if (m_StreamWasExhausted)
+				return false;
+			m_ProcessedSize += m_Pos;
+			int aNumProcessedBytes = m_Stream.Read(m_Buffer, 0, (int)m_BufferSize);
+			m_Pos = 0;
+			m_Limit = (uint)aNumProcessedBytes;
+			m_StreamWasExhausted = (aNumProcessedBytes == 0);
+			return (!m_StreamWasExhausted);
+		}
+
+
+		public void ReleaseStream()
+		{
+			// m_Stream.Close(); 
+			m_Stream = null;
+		}
+
+		public bool ReadByte(byte b) // check it
+		{
+			if (m_Pos &gt;= m_Limit)
+				if (!ReadBlock())
+					return false;
+			b = m_Buffer[m_Pos++];
+			return true;
+		}
+
+		public byte ReadByte()
+		{
+			// return (byte)m_Stream.ReadByte();
+			if (m_Pos &gt;= m_Limit)
+				if (!ReadBlock())
+					return 0xFF;
+			return m_Buffer[m_Pos++];
+		}
+
+		public ulong GetProcessedSize()
+		{
+			return m_ProcessedSize + m_Pos;
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/InBuffer.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/OutBuffer.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/OutBuffer.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/OutBuffer.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,47 @@
+// OutBuffer.cs
+
+namespace SevenZip.Buffer
+{
+	public class OutBuffer
+	{
+		byte[] m_Buffer;
+		uint m_Pos;
+		uint m_BufferSize;
+		System.IO.Stream m_Stream;
+		ulong m_ProcessedSize;
+
+		public OutBuffer(uint bufferSize)
+		{
+			m_Buffer = new byte[bufferSize];
+			m_BufferSize = bufferSize;
+		}
+
+		public void SetStream(System.IO.Stream stream) { m_Stream = stream; }
+		public void FlushStream() { m_Stream.Flush(); }
+		public void CloseStream() { m_Stream.Close(); }
+		public void ReleaseStream() { m_Stream = null; }
+
+		public void Init()
+		{
+			m_ProcessedSize = 0;
+			m_Pos = 0;
+		}
+
+		public void WriteByte(byte b)
+		{
+			m_Buffer[m_Pos++] = b;
+			if (m_Pos &gt;= m_BufferSize)
+				FlushData();
+		}
+
+		public void FlushData()
+		{
+			if (m_Pos == 0)
+				return;
+			m_Stream.Write(m_Buffer, 0, (int)m_Pos);
+			m_Pos = 0;
+		}
+
+		public ulong GetProcessedSize() { return m_ProcessedSize + m_Pos; }
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Common/OutBuffer.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/IMatchFinder.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/IMatchFinder.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/IMatchFinder.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,24 @@
+// IMatchFinder.cs
+
+using System;
+
+namespace SevenZip.Compression.LZ
+{
+	interface IInWindowStream
+	{
+		void SetStream(System.IO.Stream inStream);
+		void Init();
+		void ReleaseStream();
+		Byte GetIndexByte(Int32 index);
+		UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit);
+		UInt32 GetNumAvailableBytes();
+	}
+
+	interface IMatchFinder : IInWindowStream
+	{
+		void Create(UInt32 historySize, UInt32 keepAddBufferBefore,
+				UInt32 matchMaxLen, UInt32 keepAddBufferAfter);
+		UInt32 GetMatches(UInt32[] distances);
+		void Skip(UInt32 num);
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/IMatchFinder.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzBinTree.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzBinTree.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzBinTree.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,367 @@
+// LzBinTree.cs
+
+using System;
+
+namespace SevenZip.Compression.LZ
+{
+	public class BinTree : InWindow, IMatchFinder
+	{
+		UInt32 _cyclicBufferPos;
+		UInt32 _cyclicBufferSize = 0;
+		UInt32 _matchMaxLen;
+
+		UInt32[] _son;
+		UInt32[] _hash;
+
+		UInt32 _cutValue = 0xFF;
+		UInt32 _hashMask;
+		UInt32 _hashSizeSum = 0;
+
+		bool HASH_ARRAY = true;
+
+		const UInt32 kHash2Size = 1 &lt;&lt; 10;
+		const UInt32 kHash3Size = 1 &lt;&lt; 16;
+		const UInt32 kBT2HashSize = 1 &lt;&lt; 16;
+		const UInt32 kStartMaxLen = 1;
+		const UInt32 kHash3Offset = kHash2Size;
+		const UInt32 kEmptyHashValue = 0;
+		const UInt32 kMaxValForNormalize = ((UInt32)1 &lt;&lt; 31) - 1;
+	
+		UInt32 kNumHashDirectBytes = 0;
+		UInt32 kMinMatchCheck = 4;
+		UInt32 kFixHashSize = kHash2Size + kHash3Size;
+		
+		public void SetType(int numHashBytes)
+		{
+			HASH_ARRAY = (numHashBytes &gt; 2);
+			if (HASH_ARRAY)
+			{
+				kNumHashDirectBytes = 0;
+				kMinMatchCheck = 4;
+				kFixHashSize = kHash2Size + kHash3Size;
+			}
+			else
+			{
+				kNumHashDirectBytes = 2;
+				kMinMatchCheck = 2 + 1;
+				kFixHashSize = 0;
+			}
+		}
+
+		public new void SetStream(System.IO.Stream stream) { base.SetStream(stream); }
+		public new void ReleaseStream() { base.ReleaseStream(); }
+		
+		public new void Init()
+		{
+			base.Init();
+			for (UInt32 i = 0; i &lt; _hashSizeSum; i++)
+				_hash[i] = kEmptyHashValue;
+			_cyclicBufferPos = 0;
+			ReduceOffsets(-1);
+		}
+
+		public new void MovePos()
+		{
+			if (++_cyclicBufferPos &gt;= _cyclicBufferSize)
+				_cyclicBufferPos = 0;
+			base.MovePos();
+			if (_pos == kMaxValForNormalize)
+				Normalize();
+		}
+
+		public new Byte GetIndexByte(Int32 index) { return base.GetIndexByte(index); }
+
+		public new UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit)
+		{ return base.GetMatchLen(index, distance, limit); }
+
+		public new UInt32 GetNumAvailableBytes() { return base.GetNumAvailableBytes(); }
+
+		public void Create(UInt32 historySize, UInt32 keepAddBufferBefore,
+				UInt32 matchMaxLen, UInt32 keepAddBufferAfter)
+		{
+			if (historySize &gt; kMaxValForNormalize - 256)
+				throw new Exception();
+			_cutValue = 16 + (matchMaxLen &gt;&gt; 1);
+				
+			UInt32 windowReservSize = (historySize + keepAddBufferBefore +
+					matchMaxLen + keepAddBufferAfter) / 2 + 256;
+
+			base.Create(historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, windowReservSize);
+
+			_matchMaxLen = matchMaxLen;
+
+			UInt32 cyclicBufferSize = historySize + 1;
+			if (_cyclicBufferSize != cyclicBufferSize)
+				_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
+
+			UInt32 hs = kBT2HashSize;
+
+			if (HASH_ARRAY)
+			{
+				hs = historySize - 1;
+				hs |= (hs &gt;&gt; 1);
+				hs |= (hs &gt;&gt; 2);
+				hs |= (hs &gt;&gt; 4);
+				hs |= (hs &gt;&gt; 8);
+				hs &gt;&gt;= 1;
+				hs |= 0xFFFF;
+				if (hs &gt; (1 &lt;&lt; 24))
+					hs &gt;&gt;= 1;
+				_hashMask = hs;
+				hs++;
+				hs += kFixHashSize;
+			}
+			if (hs != _hashSizeSum)
+				_hash = new UInt32[_hashSizeSum = hs];
+		}
+
+		public UInt32 GetMatches(UInt32[] distances)
+		{
+			UInt32 lenLimit;
+			if (_pos + _matchMaxLen &lt;= _streamPos)
+				lenLimit = _matchMaxLen;
+			else
+			{
+				lenLimit = _streamPos - _pos;
+				if (lenLimit &lt; kMinMatchCheck)
+				{
+					MovePos();
+					return 0;
+				}
+			}
+
+			UInt32 offset = 0;
+			UInt32 matchMinPos = (_pos &gt; _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
+			UInt32 cur = _bufferOffset + _pos;
+			UInt32 maxLen = kStartMaxLen; // to avoid items for len &lt; hashSize;
+			UInt32 hashValue, hash2Value = 0, hash3Value = 0;
+
+			if (HASH_ARRAY)
+			{
+				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];
+				hash2Value = temp &amp; (kHash2Size - 1);
+				temp ^= ((UInt32)(_bufferBase[cur + 2]) &lt;&lt; 8);
+				hash3Value = temp &amp; (kHash3Size - 1);
+				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] &lt;&lt; 5)) &amp; _hashMask;
+			}
+			else
+				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) &lt;&lt; 8);
+
+			UInt32 curMatch = _hash[kFixHashSize + hashValue];
+			if (HASH_ARRAY)
+			{
+				UInt32 curMatch2 = _hash[hash2Value];
+				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];
+				_hash[hash2Value] = _pos;
+				_hash[kHash3Offset + hash3Value] = _pos;
+				if (curMatch2 &gt; matchMinPos)
+					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])
+					{
+						distances[offset++] = maxLen = 2;
+						distances[offset++] = _pos - curMatch2 - 1;
+					}
+				if (curMatch3 &gt; matchMinPos)
+					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])
+					{
+						if (curMatch3 == curMatch2)
+							offset -= 2;
+						distances[offset++] = maxLen = 3;
+						distances[offset++] = _pos - curMatch3 - 1;
+						curMatch2 = curMatch3;
+					}
+				if (offset != 0 &amp;&amp; curMatch2 == curMatch)
+				{
+					offset -= 2;
+					maxLen = kStartMaxLen;
+				}
+			}
+
+			_hash[kFixHashSize + hashValue] = _pos;
+
+			UInt32 ptr0 = (_cyclicBufferPos &lt;&lt; 1) + 1;
+			UInt32 ptr1 = (_cyclicBufferPos &lt;&lt; 1);
+
+			UInt32 len0, len1;
+			len0 = len1 = kNumHashDirectBytes;
+			
+			if (kNumHashDirectBytes != 0)
+			{
+				if (curMatch &gt; matchMinPos)
+				{
+					if (_bufferBase[_bufferOffset + curMatch + kNumHashDirectBytes] !=
+							_bufferBase[cur + kNumHashDirectBytes])
+					{
+						distances[offset++] = maxLen = kNumHashDirectBytes;
+						distances[offset++] = _pos - curMatch - 1;
+					}
+				}
+			}
+			
+			UInt32 count = _cutValue;
+			
+			while(true)
+			{
+				if(curMatch &lt;= matchMinPos || count-- == 0)
+				{
+					_son[ptr0] = _son[ptr1] = kEmptyHashValue;
+					break;
+				}
+				UInt32 delta = _pos - curMatch;
+				UInt32 cyclicPos = ((delta &lt;= _cyclicBufferPos) ?
+							(_cyclicBufferPos - delta) :
+							(_cyclicBufferPos - delta + _cyclicBufferSize)) &lt;&lt; 1;
+
+				UInt32 pby1 = _bufferOffset + curMatch;
+				UInt32 len = Math.Min(len0, len1);
+				if (_bufferBase[pby1 + len] == _bufferBase[cur + len])
+				{
+					while(++len != lenLimit)
+						if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
+							break;
+					if (maxLen &lt; len)
+					{
+						distances[offset++] = maxLen = len;
+						distances[offset++] = delta - 1;
+						if (len == lenLimit)
+						{
+							_son[ptr1] = _son[cyclicPos];
+							_son[ptr0] = _son[cyclicPos + 1];
+							break;
+						}
+					}
+				}
+				if (_bufferBase[pby1 + len] &lt; _bufferBase[cur + len])
+				{
+					_son[ptr1] = curMatch;
+					ptr1 = cyclicPos + 1;
+					curMatch = _son[ptr1];
+					len1 = len;
+				}
+				else
+				{
+					_son[ptr0] = curMatch;
+					ptr0 = cyclicPos;
+					curMatch = _son[ptr0];
+					len0 = len;
+				}
+			}
+			MovePos();
+			return offset;
+		}
+
+		public void Skip(UInt32 num)
+		{
+			do
+			{
+				UInt32 lenLimit;
+				if (_pos + _matchMaxLen &lt;= _streamPos)
+					lenLimit = _matchMaxLen;
+				else
+				{
+					lenLimit = _streamPos - _pos;
+					if (lenLimit &lt; kMinMatchCheck)
+					{
+						MovePos();
+						continue;
+					}
+				}
+
+				UInt32 matchMinPos = (_pos &gt; _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
+				UInt32 cur = _bufferOffset + _pos;
+
+				UInt32 hashValue;
+
+				if (HASH_ARRAY)
+				{
+					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];
+					UInt32 hash2Value = temp &amp; (kHash2Size - 1);
+					_hash[hash2Value] = _pos;
+					temp ^= ((UInt32)(_bufferBase[cur + 2]) &lt;&lt; 8);
+					UInt32 hash3Value = temp &amp; (kHash3Size - 1);
+					_hash[kHash3Offset + hash3Value] = _pos;
+					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] &lt;&lt; 5)) &amp; _hashMask;
+				}
+				else
+					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) &lt;&lt; 8);
+
+				UInt32 curMatch = _hash[kFixHashSize + hashValue];
+				_hash[kFixHashSize + hashValue] = _pos;
+
+				UInt32 ptr0 = (_cyclicBufferPos &lt;&lt; 1) + 1;
+				UInt32 ptr1 = (_cyclicBufferPos &lt;&lt; 1);
+
+				UInt32 len0, len1;
+				len0 = len1 = kNumHashDirectBytes;
+
+				UInt32 count = _cutValue;
+				while (true)
+				{
+					if (curMatch &lt;= matchMinPos || count-- == 0)
+					{
+						_son[ptr0] = _son[ptr1] = kEmptyHashValue;
+						break;
+					}
+
+					UInt32 delta = _pos - curMatch;
+					UInt32 cyclicPos = ((delta &lt;= _cyclicBufferPos) ?
+								(_cyclicBufferPos - delta) :
+								(_cyclicBufferPos - delta + _cyclicBufferSize)) &lt;&lt; 1;
+
+					UInt32 pby1 = _bufferOffset + curMatch;
+					UInt32 len = Math.Min(len0, len1);
+					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])
+					{
+						while (++len != lenLimit)
+							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
+								break;
+						if (len == lenLimit)
+						{
+							_son[ptr1] = _son[cyclicPos];
+							_son[ptr0] = _son[cyclicPos + 1];
+							break;
+						}
+					}
+					if (_bufferBase[pby1 + len] &lt; _bufferBase[cur + len])
+					{
+						_son[ptr1] = curMatch;
+						ptr1 = cyclicPos + 1;
+						curMatch = _son[ptr1];
+						len1 = len;
+					}
+					else
+					{
+						_son[ptr0] = curMatch;
+						ptr0 = cyclicPos;
+						curMatch = _son[ptr0];
+						len0 = len;
+					}
+				}
+				MovePos();
+			}
+			while (--num != 0);
+		}
+
+		void NormalizeLinks(UInt32[] items, UInt32 numItems, UInt32 subValue)
+		{
+			for (UInt32 i = 0; i &lt; numItems; i++)
+			{
+				UInt32 value = items[i];
+				if (value &lt;= subValue)
+					value = kEmptyHashValue;
+				else
+					value -= subValue;
+				items[i] = value;
+			}
+		}
+
+		void Normalize()
+		{
+			UInt32 subValue = _pos - _cyclicBufferSize;
+			NormalizeLinks(_son, _cyclicBufferSize * 2, subValue);
+			NormalizeLinks(_hash, _hashSizeSum, subValue);
+			ReduceOffsets((Int32)subValue);
+		}
+
+		public void SetCutValue(UInt32 cutValue) { _cutValue = cutValue; }
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzBinTree.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzInWindow.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzInWindow.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzInWindow.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,132 @@
+// LzInWindow.cs
+
+using System;
+
+namespace SevenZip.Compression.LZ
+{
+	public class InWindow
+	{
+		public Byte[] _bufferBase = null; // pointer to buffer with data
+		System.IO.Stream _stream;
+		UInt32 _posLimit; // offset (from _buffer) of first byte when new block reading must be done
+		bool _streamEndWasReached; // if (true) then _streamPos shows real end of stream
+
+		UInt32 _pointerToLastSafePosition;
+
+		public UInt32 _bufferOffset;
+
+		public UInt32 _blockSize; // Size of Allocated memory block
+		public UInt32 _pos; // offset (from _buffer) of curent byte
+		UInt32 _keepSizeBefore; // how many BYTEs must be kept in buffer before _pos
+		UInt32 _keepSizeAfter; // how many BYTEs must be kept buffer after _pos
+		public UInt32 _streamPos; // offset (from _buffer) of first not read byte from Stream
+
+		public void MoveBlock()
+		{
+			UInt32 offset = (UInt32)(_bufferOffset) + _pos - _keepSizeBefore;
+			// we need one additional byte, since MovePos moves on 1 byte.
+			if (offset &gt; 0)
+				offset--;
+			
+			UInt32 numBytes = (UInt32)(_bufferOffset) + _streamPos - offset;
+
+			// check negative offset ????
+			for (UInt32 i = 0; i &lt; numBytes; i++)
+				_bufferBase[i] = _bufferBase[offset + i];
+			_bufferOffset -= offset;
+		}
+
+		public virtual void ReadBlock()
+		{
+			if (_streamEndWasReached)
+				return;
+			while (true)
+			{
+				int size = (int)((0 - _bufferOffset) + _blockSize - _streamPos);
+				if (size == 0)
+					return;
+				int numReadBytes = _stream.Read(_bufferBase, (int)(_bufferOffset + _streamPos), size);
+				if (numReadBytes == 0)
+				{
+					_posLimit = _streamPos;
+					UInt32 pointerToPostion = _bufferOffset + _posLimit;
+					if (pointerToPostion &gt; _pointerToLastSafePosition)
+						_posLimit = (UInt32)(_pointerToLastSafePosition - _bufferOffset);
+
+					_streamEndWasReached = true;
+					return;
+				}
+				_streamPos += (UInt32)numReadBytes;
+				if (_streamPos &gt;= _pos + _keepSizeAfter)
+					_posLimit = _streamPos - _keepSizeAfter;
+			}
+		}
+
+		void Free() { _bufferBase = null; }
+
+		public void Create(UInt32 keepSizeBefore, UInt32 keepSizeAfter, UInt32 keepSizeReserv)
+		{
+			_keepSizeBefore = keepSizeBefore;
+			_keepSizeAfter = keepSizeAfter;
+			UInt32 blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
+			if (_bufferBase == null || _blockSize != blockSize)
+			{
+				Free();
+				_blockSize = blockSize;
+				_bufferBase = new Byte[_blockSize];
+			}
+			_pointerToLastSafePosition = _blockSize - keepSizeAfter;
+		}
+
+		public void SetStream(System.IO.Stream stream) { _stream = stream; }
+		public void ReleaseStream() { _stream = null; }
+
+		public void Init()
+		{
+			_bufferOffset = 0;
+			_pos = 0;
+			_streamPos = 0;
+			_streamEndWasReached = false;
+			ReadBlock();
+		}
+
+		public void MovePos()
+		{
+			_pos++;
+			if (_pos &gt; _posLimit)
+			{
+				UInt32 pointerToPostion = _bufferOffset + _pos;
+				if (pointerToPostion &gt; _pointerToLastSafePosition)
+					MoveBlock();
+				ReadBlock();
+			}
+		}
+
+		public Byte GetIndexByte(Int32 index) { return _bufferBase[_bufferOffset + _pos + index]; }
+
+		// index + limit have not to exceed _keepSizeAfter;
+		public UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit)
+		{
+			if (_streamEndWasReached)
+				if ((_pos + index) + limit &gt; _streamPos)
+					limit = _streamPos - (UInt32)(_pos + index);
+			distance++;
+			// Byte *pby = _buffer + (size_t)_pos + index;
+			UInt32 pby = _bufferOffset + _pos + (UInt32)index;
+
+			UInt32 i;
+			for (i = 0; i &lt; limit &amp;&amp; _bufferBase[pby + i] == _bufferBase[pby + i - distance]; i++);
+			return i;
+		}
+
+		public UInt32 GetNumAvailableBytes() { return _streamPos - _pos; }
+
+		public void ReduceOffsets(Int32 subValue)
+		{
+			_bufferOffset += (UInt32)subValue;
+			_posLimit -= (UInt32)subValue;
+			_pos -= (UInt32)subValue;
+			_streamPos -= (UInt32)subValue;
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzInWindow.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzOutWindow.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzOutWindow.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzOutWindow.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,85 @@
+// LzOutWindow.cs
+
+namespace SevenZip.Compression.LZ
+{
+	public class OutWindow
+	{
+		byte[] _buffer = null;
+		uint _pos;
+		uint _windowSize = 0;
+		uint _streamPos;
+		System.IO.Stream _stream;
+
+		public void Create(uint windowSize)
+		{
+			if (_windowSize != windowSize)
+			{
+				// System.GC.Collect();
+				_buffer = new byte[windowSize];
+			}
+			_windowSize = windowSize;
+			_pos = 0;
+			_streamPos = 0;
+		}
+
+		public void Init(System.IO.Stream stream, bool solid)
+		{
+			ReleaseStream();
+			_stream = stream;
+			if (!solid)
+			{
+				_streamPos = 0;
+				_pos = 0;
+			}
+		}
+
+		public void Init(System.IO.Stream stream) { Init(stream, false); }
+
+		public void ReleaseStream()
+		{
+			Flush();
+			_stream = null;
+		}
+
+		public void Flush()
+		{
+			uint size = _pos - _streamPos;
+			if (size == 0)
+				return;
+			_stream.Write(_buffer, (int)_streamPos, (int)size);
+			if (_pos &gt;= _windowSize)
+				_pos = 0;
+			_streamPos = _pos;
+		}
+
+		public void CopyBlock(uint distance, uint len)
+		{
+			uint pos = _pos - distance - 1;
+			if (pos &gt;= _windowSize)
+				pos += _windowSize;
+			for (; len &gt; 0; len--)
+			{
+				if (pos &gt;= _windowSize)
+					pos = 0;
+				_buffer[_pos++] = _buffer[pos++];
+				if (_pos &gt;= _windowSize)
+					Flush();
+			}
+		}
+
+		public void PutByte(byte b)
+		{
+			_buffer[_pos++] = b;
+			if (_pos &gt;= _windowSize)
+				Flush();
+		}
+
+		public byte GetByte(uint distance)
+		{
+			uint pos = _pos - distance - 1;
+			if (pos &gt;= _windowSize)
+				pos += _windowSize;
+			return _buffer[pos];
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZ/LzOutWindow.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaBase.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaBase.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaBase.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,76 @@
+// LzmaBase.cs
+
+namespace SevenZip.Compression.LZMA
+{
+	internal abstract class Base
+	{
+		public const uint kNumRepDistances = 4;
+		public const uint kNumStates = 12;
+
+		// static byte []kLiteralNextStates  = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
+		// static byte []kMatchNextStates    = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
+		// static byte []kRepNextStates      = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
+		// static byte []kShortRepNextStates = {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
+
+		public struct State
+		{
+			public uint Index;
+			public void Init() { Index = 0; }
+			public void UpdateChar()
+			{
+				if (Index &lt; 4) Index = 0;
+				else if (Index &lt; 10) Index -= 3;
+				else Index -= 6;
+			}
+			public void UpdateMatch() { Index = (uint)(Index &lt; 7 ? 7 : 10); }
+			public void UpdateRep() { Index = (uint)(Index &lt; 7 ? 8 : 11); }
+			public void UpdateShortRep() { Index = (uint)(Index &lt; 7 ? 9 : 11); }
+			public bool IsCharState() { return Index &lt; 7; }
+		}
+
+		public const int kNumPosSlotBits = 6;
+		public const int kDicLogSizeMin = 0;
+		// public const int kDicLogSizeMax = 30;
+		// public const uint kDistTableSizeMax = kDicLogSizeMax * 2;
+
+		public const int kNumLenToPosStatesBits = 2; // it's for speed optimization
+		public const uint kNumLenToPosStates = 1 &lt;&lt; kNumLenToPosStatesBits;
+
+		public const uint kMatchMinLen = 2;
+
+		public static uint GetLenToPosState(uint len)
+		{
+			len -= kMatchMinLen;
+			if (len &lt; kNumLenToPosStates)
+				return len;
+			return (uint)(kNumLenToPosStates - 1);
+		}
+
+		public const int kNumAlignBits = 4;
+		public const uint kAlignTableSize = 1 &lt;&lt; kNumAlignBits;
+		public const uint kAlignMask = (kAlignTableSize - 1);
+
+		public const uint kStartPosModelIndex = 4;
+		public const uint kEndPosModelIndex = 14;
+		public const uint kNumPosModels = kEndPosModelIndex - kStartPosModelIndex;
+
+		public const uint kNumFullDistances = 1 &lt;&lt; ((int)kEndPosModelIndex / 2);
+
+		public const uint kNumLitPosStatesBitsEncodingMax = 4;
+		public const uint kNumLitContextBitsMax = 8;
+
+		public const int kNumPosStatesBitsMax = 4;
+		public const uint kNumPosStatesMax = (1 &lt;&lt; kNumPosStatesBitsMax);
+		public const int kNumPosStatesBitsEncodingMax = 4;
+		public const uint kNumPosStatesEncodingMax = (1 &lt;&lt; kNumPosStatesBitsEncodingMax);
+
+		public const int kNumLowLenBits = 3;
+		public const int kNumMidLenBits = 3;
+		public const int kNumHighLenBits = 8;
+		public const uint kNumLowLenSymbols = 1 &lt;&lt; kNumLowLenBits;
+		public const uint kNumMidLenSymbols = 1 &lt;&lt; kNumMidLenBits;
+		public const uint kNumLenSymbols = kNumLowLenSymbols + kNumMidLenSymbols +
+				(1 &lt;&lt; kNumHighLenBits);
+		public const uint kMatchMaxLen = kMatchMinLen + kNumLenSymbols - 1;
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaBase.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaDecoder.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaDecoder.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaDecoder.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,391 @@
+// LzmaDecoder.cs
+
+using System;
+
+namespace SevenZip.Compression.LZMA
+{
+	using RangeCoder;
+
+	public class Decoder : ICoder, ISetDecoderProperties // ,System.IO.Stream
+	{
+		class LenDecoder
+		{
+			BitDecoder m_Choice = new BitDecoder();
+			BitDecoder m_Choice2 = new BitDecoder();
+			BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
+			BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
+			BitTreeDecoder m_HighCoder = new BitTreeDecoder(Base.kNumHighLenBits);
+			uint m_NumPosStates = 0;
+
+			public void Create(uint numPosStates)
+			{
+				for (uint posState = m_NumPosStates; posState &lt; numPosStates; posState++)
+				{
+					m_LowCoder[posState] = new BitTreeDecoder(Base.kNumLowLenBits);
+					m_MidCoder[posState] = new BitTreeDecoder(Base.kNumMidLenBits);
+				}
+				m_NumPosStates = numPosStates;
+			}
+
+			public void Init()
+			{
+				m_Choice.Init();
+				for (uint posState = 0; posState &lt; m_NumPosStates; posState++)
+				{
+					m_LowCoder[posState].Init();
+					m_MidCoder[posState].Init();
+				}
+				m_Choice2.Init();
+				m_HighCoder.Init();
+			}
+
+			public uint Decode(RangeCoder.Decoder rangeDecoder, uint posState)
+			{
+				if (m_Choice.Decode(rangeDecoder) == 0)
+					return m_LowCoder[posState].Decode(rangeDecoder);
+				else
+				{
+					uint symbol = Base.kNumLowLenSymbols;
+					if (m_Choice2.Decode(rangeDecoder) == 0)
+						symbol += m_MidCoder[posState].Decode(rangeDecoder);
+					else
+					{
+						symbol += Base.kNumMidLenSymbols;
+						symbol += m_HighCoder.Decode(rangeDecoder);
+					}
+					return symbol;
+				}
+			}
+		}
+
+		class LiteralDecoder
+		{
+			struct Decoder2
+			{
+				BitDecoder[] m_Decoders;
+				public void Create() { m_Decoders = new BitDecoder[0x300]; }
+				public void Init() { for (int i = 0; i &lt; 0x300; i++) m_Decoders[i].Init(); }
+
+				public byte DecodeNormal(RangeCoder.Decoder rangeDecoder)
+				{
+					uint symbol = 1;
+					do
+						symbol = (symbol &lt;&lt; 1) | m_Decoders[symbol].Decode(rangeDecoder);
+					while (symbol &lt; 0x100);
+					return (byte)symbol;
+				}
+
+				public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, byte matchByte)
+				{
+					uint symbol = 1;
+					do
+					{
+						uint matchBit = (uint)(matchByte &gt;&gt; 7) &amp; 1;
+						matchByte &lt;&lt;= 1;
+						uint bit = m_Decoders[((1 + matchBit) &lt;&lt; 8) + symbol].Decode(rangeDecoder);
+						symbol = (symbol &lt;&lt; 1) | bit;
+						if (matchBit != bit)
+						{
+							while (symbol &lt; 0x100)
+								symbol = (symbol &lt;&lt; 1) | m_Decoders[symbol].Decode(rangeDecoder);
+							break;
+						}
+					}
+					while (symbol &lt; 0x100);
+					return (byte)symbol;
+				}
+			}
+
+			Decoder2[] m_Coders;
+			int m_NumPrevBits;
+			int m_NumPosBits;
+			uint m_PosMask;
+
+			public void Create(int numPosBits, int numPrevBits)
+			{
+				if (m_Coders != null &amp;&amp; m_NumPrevBits == numPrevBits &amp;&amp;
+					m_NumPosBits == numPosBits)
+					return;
+				m_NumPosBits = numPosBits;
+				m_PosMask = ((uint)1 &lt;&lt; numPosBits) - 1;
+				m_NumPrevBits = numPrevBits;
+				uint numStates = (uint)1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);
+				m_Coders = new Decoder2[numStates];
+				for (uint i = 0; i &lt; numStates; i++)
+					m_Coders[i].Create();
+			}
+
+			public void Init()
+			{
+				uint numStates = (uint)1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);
+				for (uint i = 0; i &lt; numStates; i++)
+					m_Coders[i].Init();
+			}
+
+			uint GetState(uint pos, byte prevByte)
+			{ return ((pos &amp; m_PosMask) &lt;&lt; m_NumPrevBits) + (uint)(prevByte &gt;&gt; (8 - m_NumPrevBits)); }
+
+			public byte DecodeNormal(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte)
+			{ return m_Coders[GetState(pos, prevByte)].DecodeNormal(rangeDecoder); }
+
+			public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte, byte matchByte)
+			{ return m_Coders[GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte); }
+		};
+
+		LZ.OutWindow m_OutWindow = new LZ.OutWindow();
+		RangeCoder.Decoder m_RangeDecoder = new RangeCoder.Decoder();
+
+		BitDecoder[] m_IsMatchDecoders = new BitDecoder[Base.kNumStates &lt;&lt; Base.kNumPosStatesBitsMax];
+		BitDecoder[] m_IsRepDecoders = new BitDecoder[Base.kNumStates];
+		BitDecoder[] m_IsRepG0Decoders = new BitDecoder[Base.kNumStates];
+		BitDecoder[] m_IsRepG1Decoders = new BitDecoder[Base.kNumStates];
+		BitDecoder[] m_IsRepG2Decoders = new BitDecoder[Base.kNumStates];
+		BitDecoder[] m_IsRep0LongDecoders = new BitDecoder[Base.kNumStates &lt;&lt; Base.kNumPosStatesBitsMax];
+
+		BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[Base.kNumLenToPosStates];
+		BitDecoder[] m_PosDecoders = new BitDecoder[Base.kNumFullDistances - Base.kEndPosModelIndex];
+
+		BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(Base.kNumAlignBits);
+
+		LenDecoder m_LenDecoder = new LenDecoder();
+		LenDecoder m_RepLenDecoder = new LenDecoder();
+
+		LiteralDecoder m_LiteralDecoder = new LiteralDecoder();
+
+		uint m_DictionarySize;
+		uint m_DictionarySizeCheck;
+
+		uint m_PosStateMask;
+
+		public Decoder()
+		{
+			m_DictionarySize = 0xFFFFFFFF;
+			for (int i = 0; i &lt; Base.kNumLenToPosStates; i++)
+				m_PosSlotDecoder[i] = new BitTreeDecoder(Base.kNumPosSlotBits);
+		}
+
+		void SetDictionarySize(uint dictionarySize)
+		{
+			if (m_DictionarySize != dictionarySize)
+			{
+				m_DictionarySize = dictionarySize;
+				m_DictionarySizeCheck = Math.Max(m_DictionarySize, 1);
+				uint blockSize = Math.Max(m_DictionarySizeCheck, (1 &lt;&lt; 12));
+				m_OutWindow.Create(blockSize);
+			}
+		}
+
+		void SetLiteralProperties(int lp, int lc)
+		{
+			if (lp &gt; 8)
+				throw new InvalidParamException();
+			if (lc &gt; 8)
+				throw new InvalidParamException();
+			m_LiteralDecoder.Create(lp, lc);
+		}
+
+		void SetPosBitsProperties(int pb)
+		{
+			if (pb &gt; Base.kNumPosStatesBitsMax)
+				throw new InvalidParamException();
+			uint numPosStates = (uint)1 &lt;&lt; pb;
+			m_LenDecoder.Create(numPosStates);
+			m_RepLenDecoder.Create(numPosStates);
+			m_PosStateMask = numPosStates - 1;
+		}
+
+		void Init(System.IO.Stream inStream, System.IO.Stream outStream)
+		{
+			m_RangeDecoder.Init(inStream);
+			m_OutWindow.Init(outStream);
+
+			uint i;
+			for (i = 0; i &lt; Base.kNumStates; i++)
+			{
+				for (uint j = 0; j &lt;= m_PosStateMask; j++)
+				{
+					uint index = (i &lt;&lt; Base.kNumPosStatesBitsMax) + j;
+					m_IsMatchDecoders[index].Init();
+					m_IsRep0LongDecoders[index].Init();
+				}
+				m_IsRepDecoders[i].Init();
+				m_IsRepG0Decoders[i].Init();
+				m_IsRepG1Decoders[i].Init();
+				m_IsRepG2Decoders[i].Init();
+			}
+
+			m_LiteralDecoder.Init();
+			for (i = 0; i &lt; Base.kNumLenToPosStates; i++)
+				m_PosSlotDecoder[i].Init();
+			// m_PosSpecDecoder.Init();
+			for (i = 0; i &lt; Base.kNumFullDistances - Base.kEndPosModelIndex; i++)
+				m_PosDecoders[i].Init();
+
+			m_LenDecoder.Init();
+			m_RepLenDecoder.Init();
+			m_PosAlignDecoder.Init();
+		}
+
+		public void Code(System.IO.Stream inStream, System.IO.Stream outStream,
+			Int64 inSize, Int64 outSize, ICodeProgress progress)
+		{
+			Init(inStream, outStream);
+
+			Base.State state = new Base.State();
+			state.Init();
+			uint rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0;
+
+			UInt64 nowPos64 = 0;
+			UInt64 outSize64 = (UInt64)outSize;
+			if (nowPos64 &lt; outSize64)
+			{
+				if (m_IsMatchDecoders[state.Index &lt;&lt; Base.kNumPosStatesBitsMax].Decode(m_RangeDecoder) != 0)
+					throw new DataErrorException();
+				state.UpdateChar();
+				byte b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, 0, 0);
+				m_OutWindow.PutByte(b);
+				nowPos64++;
+			}
+			while (nowPos64 &lt; outSize64)
+			{
+				// UInt64 next = Math.Min(nowPos64 + (1 &lt;&lt; 18), outSize64);
+					// while(nowPos64 &lt; next)
+				{
+					uint posState = (uint)nowPos64 &amp; m_PosStateMask;
+					if (m_IsMatchDecoders[(state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)
+					{
+						byte b;
+						byte prevByte = m_OutWindow.GetByte(0);
+						if (!state.IsCharState())
+							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder,
+								(uint)nowPos64, prevByte, m_OutWindow.GetByte(rep0));
+						else
+							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, (uint)nowPos64, prevByte);
+						m_OutWindow.PutByte(b);
+						state.UpdateChar();
+						nowPos64++;
+					}
+					else
+					{
+						uint len;
+						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)
+						{
+							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)
+							{
+								if (m_IsRep0LongDecoders[(state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)
+								{
+									state.UpdateShortRep();
+									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));
+									nowPos64++;
+									continue;
+								}
+							}
+							else
+							{
+								UInt32 distance;
+								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)
+								{
+									distance = rep1;
+								}
+								else
+								{
+									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)
+										distance = rep2;
+									else
+									{
+										distance = rep3;
+										rep3 = rep2;
+									}
+									rep2 = rep1;
+								}
+								rep1 = rep0;
+								rep0 = distance;
+							}
+							len = m_RepLenDecoder.Decode(m_RangeDecoder, posState) + Base.kMatchMinLen;
+							state.UpdateRep();
+						}
+						else
+						{
+							rep3 = rep2;
+							rep2 = rep1;
+							rep1 = rep0;
+							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder, posState);
+							state.UpdateMatch();
+							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);
+							if (posSlot &gt;= Base.kStartPosModelIndex)
+							{
+								int numDirectBits = (int)((posSlot &gt;&gt; 1) - 1);
+								rep0 = ((2 | (posSlot &amp; 1)) &lt;&lt; numDirectBits);
+								if (posSlot &lt; Base.kEndPosModelIndex)
+									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders,
+											rep0 - posSlot - 1, m_RangeDecoder, numDirectBits);
+								else
+								{
+									rep0 += (m_RangeDecoder.DecodeDirectBits(
+										numDirectBits - Base.kNumAlignBits) &lt;&lt; Base.kNumAlignBits);
+									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);
+								}
+							}
+							else
+								rep0 = posSlot;
+						}
+						if (rep0 &gt;= nowPos64 || rep0 &gt;= m_DictionarySizeCheck)
+						{
+							if (rep0 == 0xFFFFFFFF)
+								break;
+							throw new DataErrorException();
+						}
+						m_OutWindow.CopyBlock(rep0, len);
+						nowPos64 += len;
+					}
+				}
+			}
+			m_OutWindow.Flush();
+			m_OutWindow.ReleaseStream();
+			m_RangeDecoder.ReleaseStream();
+		}
+
+		public void SetDecoderProperties(byte[] properties)
+		{
+			if (properties.Length &lt; 5)
+				throw new InvalidParamException();
+			int lc = properties[0] % 9;
+			int remainder = properties[0] / 9;
+			int lp = remainder % 5;
+			int pb = remainder / 5;
+			if (pb &gt; Base.kNumPosStatesBitsMax)
+				throw new InvalidParamException();
+			UInt32 dictionarySize = 0;
+			for (int i = 0; i &lt; 4; i++)
+				dictionarySize += ((UInt32)(properties[1 + i])) &lt;&lt; (i * 8);
+			SetDictionarySize(dictionarySize);
+			SetLiteralProperties(lp, lc);
+			SetPosBitsProperties(pb);
+		}
+
+		/*
+		public override bool CanRead { get { return true; }}
+		public override bool CanWrite { get { return true; }}
+		public override bool CanSeek { get { return true; }}
+		public override long Length { get { return 0; }}
+		public override long Position
+		{
+			get { return 0;	}
+			set { }
+		}
+		public override void Flush() { }
+		public override int Read(byte[] buffer, int offset, int count) 
+		{
+			return 0;
+		}
+		public override void Write(byte[] buffer, int offset, int count)
+		{
+		}
+		public override long Seek(long offset, System.IO.SeekOrigin origin)
+		{
+			return 0;
+		}
+		public override void SetLength(long value) {}
+		*/
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaDecoder.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaEncoder.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaEncoder.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaEncoder.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,1471 @@
+// LzmaEncoder.cs
+
+using System;
+
+namespace SevenZip.Compression.LZMA
+{
+	using RangeCoder;
+
+	public class Encoder : ICoder, ISetCoderProperties, IWriteCoderProperties
+	{
+		enum EMatchFinderType
+		{
+			BT2,
+			BT4,
+		};
+
+		const UInt32 kIfinityPrice = 0xFFFFFFF;
+
+		static Byte[] g_FastPos = new Byte[1 &lt;&lt; 11];
+
+		static Encoder()
+		{
+			const Byte kFastSlots = 22;
+			int c = 2;
+			g_FastPos[0] = 0;
+			g_FastPos[1] = 1;
+			for (Byte slotFast = 2; slotFast &lt; kFastSlots; slotFast++)
+			{
+				UInt32 k = ((UInt32)1 &lt;&lt; ((slotFast &gt;&gt; 1) - 1));
+				for (UInt32 j = 0; j &lt; k; j++, c++)
+					g_FastPos[c] = slotFast;
+			}
+		}
+
+		static UInt32 GetPosSlot(UInt32 pos)
+		{
+			if (pos &lt; (1 &lt;&lt; 11))
+				return g_FastPos[pos];
+			if (pos &lt; (1 &lt;&lt; 21))
+				return (UInt32)(g_FastPos[pos &gt;&gt; 10] + 20);
+			return (UInt32)(g_FastPos[pos &gt;&gt; 20] + 40);
+		}
+
+		static UInt32 GetPosSlot2(UInt32 pos)
+		{
+			if (pos &lt; (1 &lt;&lt; 17))
+				return (UInt32)(g_FastPos[pos &gt;&gt; 6] + 12);
+			if (pos &lt; (1 &lt;&lt; 27))
+				return (UInt32)(g_FastPos[pos &gt;&gt; 16] + 32);
+			return (UInt32)(g_FastPos[pos &gt;&gt; 26] + 52);
+		}
+
+		Base.State _state = new Base.State();
+		Byte _previousByte;
+		UInt32[] _repDistances = new UInt32[Base.kNumRepDistances];
+
+		void BaseInit()
+		{
+			_state.Init();
+			_previousByte = 0;
+			for (UInt32 i = 0; i &lt; Base.kNumRepDistances; i++)
+				_repDistances[i] = 0;
+		}
+
+		const int kDefaultDictionaryLogSize = 22;
+		const UInt32 kNumFastBytesDefault = 0x20;
+
+		class LiteralEncoder
+		{
+			public struct Encoder2
+			{
+				BitEncoder[] m_Encoders;
+
+				public void Create() { m_Encoders = new BitEncoder[0x300]; }
+
+				public void Init() { for (int i = 0; i &lt; 0x300; i++) m_Encoders[i].Init(); }
+
+				public void Encode(RangeCoder.Encoder rangeEncoder, byte symbol)
+				{
+					uint context = 1;
+					for (int i = 7; i &gt;= 0; i--)
+					{
+						uint bit = (uint)((symbol &gt;&gt; i) &amp; 1);
+						m_Encoders[context].Encode(rangeEncoder, bit);
+						context = (context &lt;&lt; 1) | bit;
+					}
+				}
+
+				public void EncodeMatched(RangeCoder.Encoder rangeEncoder, byte matchByte, byte symbol)
+				{
+					uint context = 1;
+					bool same = true;
+					for (int i = 7; i &gt;= 0; i--)
+					{
+						uint bit = (uint)((symbol &gt;&gt; i) &amp; 1);
+						uint state = context;
+						if (same)
+						{
+							uint matchBit = (uint)((matchByte &gt;&gt; i) &amp; 1);
+							state += ((1 + matchBit) &lt;&lt; 8);
+							same = (matchBit == bit);
+						}
+						m_Encoders[state].Encode(rangeEncoder, bit);
+						context = (context &lt;&lt; 1) | bit;
+					}
+				}
+
+				public uint GetPrice(bool matchMode, byte matchByte, byte symbol)
+				{
+					uint price = 0;
+					uint context = 1;
+					int i = 7;
+					if (matchMode)
+					{
+						for (; i &gt;= 0; i--)
+						{
+							uint matchBit = (uint)(matchByte &gt;&gt; i) &amp; 1;
+							uint bit = (uint)(symbol &gt;&gt; i) &amp; 1;
+							price += m_Encoders[((1 + matchBit) &lt;&lt; 8) + context].GetPrice(bit);
+							context = (context &lt;&lt; 1) | bit;
+							if (matchBit != bit)
+							{
+								i--;
+								break;
+							}
+						}
+					}
+					for (; i &gt;= 0; i--)
+					{
+						uint bit = (uint)(symbol &gt;&gt; i) &amp; 1;
+						price += m_Encoders[context].GetPrice(bit);
+						context = (context &lt;&lt; 1) | bit;
+					}
+					return price;
+				}
+			}
+
+			Encoder2[] m_Coders;
+			int m_NumPrevBits;
+			int m_NumPosBits;
+			uint m_PosMask;
+
+			public void Create(int numPosBits, int numPrevBits)
+			{
+				if (m_Coders != null &amp;&amp; m_NumPrevBits == numPrevBits &amp;&amp; m_NumPosBits == numPosBits)
+					return;
+				m_NumPosBits = numPosBits;
+				m_PosMask = ((uint)1 &lt;&lt; numPosBits) - 1;
+				m_NumPrevBits = numPrevBits;
+				uint numStates = (uint)1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);
+				m_Coders = new Encoder2[numStates];
+				for (uint i = 0; i &lt; numStates; i++)
+					m_Coders[i].Create();
+			}
+
+			public void Init()
+			{
+				uint numStates = (uint)1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);
+				for (uint i = 0; i &lt; numStates; i++)
+					m_Coders[i].Init();
+			}
+
+			public Encoder2 GetSubCoder(UInt32 pos, Byte prevByte)
+			{ return m_Coders[((pos &amp; m_PosMask) &lt;&lt; m_NumPrevBits) + (uint)(prevByte &gt;&gt; (8 - m_NumPrevBits))]; }
+		}
+
+		class LenEncoder
+		{
+			RangeCoder.BitEncoder _choice = new RangeCoder.BitEncoder();
+			RangeCoder.BitEncoder _choice2 = new RangeCoder.BitEncoder();
+			RangeCoder.BitTreeEncoder[] _lowCoder = new RangeCoder.BitTreeEncoder[Base.kNumPosStatesEncodingMax];
+			RangeCoder.BitTreeEncoder[] _midCoder = new RangeCoder.BitTreeEncoder[Base.kNumPosStatesEncodingMax];
+			RangeCoder.BitTreeEncoder _highCoder = new RangeCoder.BitTreeEncoder(Base.kNumHighLenBits);
+
+			public LenEncoder()
+			{
+				for (UInt32 posState = 0; posState &lt; Base.kNumPosStatesEncodingMax; posState++)
+				{
+					_lowCoder[posState] = new RangeCoder.BitTreeEncoder(Base.kNumLowLenBits);
+					_midCoder[posState] = new RangeCoder.BitTreeEncoder(Base.kNumMidLenBits);
+				}
+			}
+
+			public void Init(UInt32 numPosStates)
+			{
+				_choice.Init();
+				_choice2.Init();
+				for (UInt32 posState = 0; posState &lt; numPosStates; posState++)
+				{
+					_lowCoder[posState].Init();
+					_midCoder[posState].Init();
+				}
+				_highCoder.Init();
+			}
+
+			public void Encode(RangeCoder.Encoder rangeEncoder, UInt32 symbol, UInt32 posState)
+			{
+				if (symbol &lt; Base.kNumLowLenSymbols)
+				{
+					_choice.Encode(rangeEncoder, 0);
+					_lowCoder[posState].Encode(rangeEncoder, symbol);
+				}
+				else
+				{
+					symbol -= Base.kNumLowLenSymbols;
+					_choice.Encode(rangeEncoder, 1);
+					if (symbol &lt; Base.kNumMidLenSymbols)
+					{
+						_choice2.Encode(rangeEncoder, 0);
+						_midCoder[posState].Encode(rangeEncoder, symbol);
+					}
+					else
+					{
+						_choice2.Encode(rangeEncoder, 1);
+						_highCoder.Encode(rangeEncoder, symbol - Base.kNumMidLenSymbols);
+					}
+				}
+			}
+
+			public void SetPrices(UInt32 posState, UInt32 numSymbols, UInt32[] prices, UInt32 st)
+			{
+				UInt32 a0 = _choice.GetPrice0();
+				UInt32 a1 = _choice.GetPrice1();
+				UInt32 b0 = a1 + _choice2.GetPrice0();
+				UInt32 b1 = a1 + _choice2.GetPrice1();
+				UInt32 i = 0;
+				for (i = 0; i &lt; Base.kNumLowLenSymbols; i++)
+				{
+					if (i &gt;= numSymbols)
+						return;
+					prices[st + i] = a0 + _lowCoder[posState].GetPrice(i);
+				}
+				for (; i &lt; Base.kNumLowLenSymbols + Base.kNumMidLenSymbols; i++)
+				{
+					if (i &gt;= numSymbols)
+						return;
+					prices[st + i] = b0 + _midCoder[posState].GetPrice(i - Base.kNumLowLenSymbols);
+				}
+				for (; i &lt; numSymbols; i++)
+					prices[st + i] = b1 + _highCoder.GetPrice(i - Base.kNumLowLenSymbols - Base.kNumMidLenSymbols);
+			}
+		};
+
+		const UInt32 kNumLenSpecSymbols = Base.kNumLowLenSymbols + Base.kNumMidLenSymbols;
+
+		class LenPriceTableEncoder : LenEncoder
+		{
+			UInt32[] _prices = new UInt32[Base.kNumLenSymbols &lt;&lt; Base.kNumPosStatesBitsEncodingMax];
+			UInt32 _tableSize;
+			UInt32[] _counters = new UInt32[Base.kNumPosStatesEncodingMax];
+
+			public void SetTableSize(UInt32 tableSize) { _tableSize = tableSize; }
+
+			public UInt32 GetPrice(UInt32 symbol, UInt32 posState)
+			{
+				return _prices[posState * Base.kNumLenSymbols + symbol];
+			}
+
+			void UpdateTable(UInt32 posState)
+			{
+				SetPrices(posState, _tableSize, _prices, posState * Base.kNumLenSymbols);
+				_counters[posState] = _tableSize;
+			}
+
+			public void UpdateTables(UInt32 numPosStates)
+			{
+				for (UInt32 posState = 0; posState &lt; numPosStates; posState++)
+					UpdateTable(posState);
+			}
+
+			public new void Encode(RangeCoder.Encoder rangeEncoder, UInt32 symbol, UInt32 posState)
+			{
+				base.Encode(rangeEncoder, symbol, posState);
+				if (--_counters[posState] == 0)
+					UpdateTable(posState);
+			}
+		}
+
+		const UInt32 kNumOpts = 1 &lt;&lt; 12;
+		class Optimal
+		{
+			public Base.State State;
+
+			public bool Prev1IsChar;
+			public bool Prev2;
+
+			public UInt32 PosPrev2;
+			public UInt32 BackPrev2;
+
+			public UInt32 Price;
+			public UInt32 PosPrev;
+			public UInt32 BackPrev;
+
+			public UInt32 Backs0;
+			public UInt32 Backs1;
+			public UInt32 Backs2;
+			public UInt32 Backs3;
+
+			public void MakeAsChar() { BackPrev = 0xFFFFFFFF; Prev1IsChar = false; }
+			public void MakeAsShortRep() { BackPrev = 0; ; Prev1IsChar = false; }
+			public bool IsShortRep() { return (BackPrev == 0); }
+		};
+		Optimal[] _optimum = new Optimal[kNumOpts];
+		LZ.IMatchFinder _matchFinder = null;
+		RangeCoder.Encoder _rangeEncoder = new RangeCoder.Encoder();
+
+		RangeCoder.BitEncoder[] _isMatch = new RangeCoder.BitEncoder[Base.kNumStates &lt;&lt; Base.kNumPosStatesBitsMax];
+		RangeCoder.BitEncoder[] _isRep = new RangeCoder.BitEncoder[Base.kNumStates];
+		RangeCoder.BitEncoder[] _isRepG0 = new RangeCoder.BitEncoder[Base.kNumStates];
+		RangeCoder.BitEncoder[] _isRepG1 = new RangeCoder.BitEncoder[Base.kNumStates];
+		RangeCoder.BitEncoder[] _isRepG2 = new RangeCoder.BitEncoder[Base.kNumStates];
+		RangeCoder.BitEncoder[] _isRep0Long = new RangeCoder.BitEncoder[Base.kNumStates &lt;&lt; Base.kNumPosStatesBitsMax];
+
+		RangeCoder.BitTreeEncoder[] _posSlotEncoder = new RangeCoder.BitTreeEncoder[Base.kNumLenToPosStates];
+		
+		RangeCoder.BitEncoder[] _posEncoders = new RangeCoder.BitEncoder[Base.kNumFullDistances - Base.kEndPosModelIndex];
+		RangeCoder.BitTreeEncoder _posAlignEncoder = new RangeCoder.BitTreeEncoder(Base.kNumAlignBits);
+
+		LenPriceTableEncoder _lenEncoder = new LenPriceTableEncoder();
+		LenPriceTableEncoder _repMatchLenEncoder = new LenPriceTableEncoder();
+
+		LiteralEncoder _literalEncoder = new LiteralEncoder();
+
+		UInt32[] _matchDistances = new UInt32[Base.kMatchMaxLen * 2 + 2];
+		
+		UInt32 _numFastBytes = kNumFastBytesDefault;
+		UInt32 _longestMatchLength;
+		UInt32 _numDistancePairs;
+
+		UInt32 _additionalOffset;
+
+		UInt32 _optimumEndIndex;
+		UInt32 _optimumCurrentIndex;
+
+		bool _longestMatchWasFound;
+
+		UInt32[] _posSlotPrices = new UInt32[1 &lt;&lt; (Base.kNumPosSlotBits + Base.kNumLenToPosStatesBits)];
+		UInt32[] _distancesPrices = new UInt32[Base.kNumFullDistances &lt;&lt; Base.kNumLenToPosStatesBits];
+		UInt32[] _alignPrices = new UInt32[Base.kAlignTableSize];
+		UInt32 _alignPriceCount;
+
+		UInt32 _distTableSize = (kDefaultDictionaryLogSize * 2);
+
+		int _posStateBits = 2;
+		UInt32 _posStateMask = (4 - 1);
+		int _numLiteralPosStateBits = 0;
+		int _numLiteralContextBits = 3;
+
+		UInt32 _dictionarySize = (1 &lt;&lt; kDefaultDictionaryLogSize);
+		UInt32 _dictionarySizePrev = 0xFFFFFFFF;
+		UInt32 _numFastBytesPrev = 0xFFFFFFFF;
+
+		Int64 nowPos64;
+		bool _finished;
+		System.IO.Stream _inStream;
+
+		EMatchFinderType _matchFinderType = EMatchFinderType.BT4;
+		bool _writeEndMark = false;
+		
+		bool _needReleaseMFStream;
+
+		void Create()
+		{
+			if (_matchFinder == null)
+			{
+				LZ.BinTree bt = new LZ.BinTree();
+				int numHashBytes = 4;
+				if (_matchFinderType == EMatchFinderType.BT2)
+					numHashBytes = 2;
+				bt.SetType(numHashBytes);
+				_matchFinder = bt;
+			}
+			_literalEncoder.Create(_numLiteralPosStateBits, _numLiteralContextBits);
+
+			if (_dictionarySize == _dictionarySizePrev &amp;&amp; _numFastBytesPrev == _numFastBytes)
+				return;
+			_matchFinder.Create(_dictionarySize, kNumOpts, _numFastBytes, Base.kMatchMaxLen + 1);
+			_dictionarySizePrev = _dictionarySize;
+			_numFastBytesPrev = _numFastBytes;
+		}
+
+		public Encoder()
+		{
+			for (int i = 0; i &lt; kNumOpts; i++)
+				_optimum[i] = new Optimal();
+			for (int i = 0; i &lt; Base.kNumLenToPosStates; i++)
+				_posSlotEncoder[i] = new RangeCoder.BitTreeEncoder(Base.kNumPosSlotBits);
+		}
+
+		void SetWriteEndMarkerMode(bool writeEndMarker)
+		{
+			_writeEndMark = writeEndMarker;
+		}
+
+		void Init()
+		{
+			BaseInit();
+			_rangeEncoder.Init();
+
+			uint i;
+			for (i = 0; i &lt; Base.kNumStates; i++)
+			{
+				for (uint j = 0; j &lt;= _posStateMask; j++)
+				{
+					uint complexState = (i &lt;&lt; Base.kNumPosStatesBitsMax) + j;
+					_isMatch[complexState].Init();
+					_isRep0Long[complexState].Init();
+				}
+				_isRep[i].Init();
+				_isRepG0[i].Init();
+				_isRepG1[i].Init();
+				_isRepG2[i].Init();
+			}
+			_literalEncoder.Init();
+			for (i = 0; i &lt; Base.kNumLenToPosStates; i++)
+				_posSlotEncoder[i].Init();
+			for (i = 0; i &lt; Base.kNumFullDistances - Base.kEndPosModelIndex; i++)
+				_posEncoders[i].Init();
+
+			_lenEncoder.Init((UInt32)1 &lt;&lt; _posStateBits);
+			_repMatchLenEncoder.Init((UInt32)1 &lt;&lt; _posStateBits);
+
+			_posAlignEncoder.Init();
+
+			_longestMatchWasFound = false;
+			_optimumEndIndex = 0;
+			_optimumCurrentIndex = 0;
+			_additionalOffset = 0;
+		}
+
+		void ReadMatchDistances(out UInt32 lenRes, out UInt32 numDistancePairs)
+		{
+			lenRes = 0;
+			numDistancePairs = _matchFinder.GetMatches(_matchDistances);
+			if (numDistancePairs &gt; 0)
+			{
+				lenRes = _matchDistances[numDistancePairs - 2];
+				if (lenRes == _numFastBytes)
+					lenRes += _matchFinder.GetMatchLen((int)lenRes - 1, _matchDistances[numDistancePairs - 1],
+						Base.kMatchMaxLen - lenRes);
+			}
+			_additionalOffset++;
+		}
+
+
+		void MovePos(UInt32 num)
+		{
+			if (num &gt; 0)
+			{
+				_matchFinder.Skip(num);
+				_additionalOffset += num;
+			}
+		}
+
+		UInt32 GetRepLen1Price(Base.State state, UInt32 posState)
+		{
+			return _isRepG0[state.Index].GetPrice0() +
+					_isRep0Long[(state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].GetPrice0();
+		}
+
+		UInt32 GetPureRepPrice(UInt32 repIndex, Base.State state, UInt32 posState)
+		{
+			UInt32 price;
+			if (repIndex == 0)
+			{
+				price = _isRepG0[state.Index].GetPrice0();
+				price += _isRep0Long[(state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].GetPrice1();
+			}
+			else
+			{
+				price = _isRepG0[state.Index].GetPrice1();
+				if (repIndex == 1)
+					price += _isRepG1[state.Index].GetPrice0();
+				else
+				{
+					price += _isRepG1[state.Index].GetPrice1();
+					price += _isRepG2[state.Index].GetPrice(repIndex - 2);
+				}
+			}
+			return price;
+		}
+
+		UInt32 GetRepPrice(UInt32 repIndex, UInt32 len, Base.State state, UInt32 posState)
+		{
+			UInt32 price = _repMatchLenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
+			return price + GetPureRepPrice(repIndex, state, posState);
+		}
+	
+		UInt32 GetPosLenPrice(UInt32 pos, UInt32 len, UInt32 posState)
+		{
+			UInt32 price;
+			UInt32 lenToPosState = Base.GetLenToPosState(len);
+			if (pos &lt; Base.kNumFullDistances)
+				price = _distancesPrices[(lenToPosState * Base.kNumFullDistances) + pos];
+			else
+				price = _posSlotPrices[(lenToPosState &lt;&lt; Base.kNumPosSlotBits) + GetPosSlot2(pos)] +
+					_alignPrices[pos &amp; Base.kAlignMask];
+			return price + _lenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
+		}
+
+		UInt32 Backward(out UInt32 backRes, UInt32 cur)
+		{
+			_optimumEndIndex = cur;
+			UInt32 posMem = _optimum[cur].PosPrev;
+			UInt32 backMem = _optimum[cur].BackPrev;
+			do
+			{
+				if (_optimum[cur].Prev1IsChar)
+				{
+					_optimum[posMem].MakeAsChar();
+					_optimum[posMem].PosPrev = posMem - 1;
+					if (_optimum[cur].Prev2)
+					{
+						_optimum[posMem - 1].Prev1IsChar = false;
+						_optimum[posMem - 1].PosPrev = _optimum[cur].PosPrev2;
+						_optimum[posMem - 1].BackPrev = _optimum[cur].BackPrev2;
+					}
+				}
+				UInt32 posPrev = posMem;
+				UInt32 backCur = backMem;
+
+				backMem = _optimum[posPrev].BackPrev;
+				posMem = _optimum[posPrev].PosPrev;
+
+				_optimum[posPrev].BackPrev = backCur;
+				_optimum[posPrev].PosPrev = cur;
+				cur = posPrev;
+			}
+			while (cur &gt; 0);
+			backRes = _optimum[0].BackPrev;
+			_optimumCurrentIndex = _optimum[0].PosPrev;
+			return _optimumCurrentIndex;
+		}
+
+		UInt32[] reps = new UInt32[Base.kNumRepDistances];
+		UInt32[] repLens = new UInt32[Base.kNumRepDistances];
+
+
+		UInt32 GetOptimum(UInt32 position, out UInt32 backRes)
+		{
+			if (_optimumEndIndex != _optimumCurrentIndex)
+			{
+				UInt32 lenRes = _optimum[_optimumCurrentIndex].PosPrev - _optimumCurrentIndex;
+				backRes = _optimum[_optimumCurrentIndex].BackPrev;
+				_optimumCurrentIndex = _optimum[_optimumCurrentIndex].PosPrev;
+				return lenRes;
+			}
+			_optimumCurrentIndex = _optimumEndIndex = 0;
+
+			UInt32 lenMain, numDistancePairs;
+			if (!_longestMatchWasFound)
+			{
+				ReadMatchDistances(out lenMain, out numDistancePairs);
+			}
+			else
+			{
+				lenMain = _longestMatchLength;
+				numDistancePairs = _numDistancePairs;
+				_longestMatchWasFound = false;
+			}
+
+			UInt32 numAvailableBytes = _matchFinder.GetNumAvailableBytes() + 1;
+			if (numAvailableBytes &lt; 2)
+			{
+				backRes = 0xFFFFFFFF;
+				return 1;
+			}
+			if (numAvailableBytes &gt; Base.kMatchMaxLen)
+				numAvailableBytes = Base.kMatchMaxLen;
+
+			UInt32 repMaxIndex = 0;
+			UInt32 i;			
+			for (i = 0; i &lt; Base.kNumRepDistances; i++)
+			{
+				reps[i] = _repDistances[i];
+				repLens[i] = _matchFinder.GetMatchLen(0 - 1, reps[i], Base.kMatchMaxLen);
+				if (repLens[i] &gt; repLens[repMaxIndex])
+					repMaxIndex = i;
+			}
+			if (repLens[repMaxIndex] &gt;= _numFastBytes)
+			{
+				backRes = repMaxIndex;
+				UInt32 lenRes = repLens[repMaxIndex];
+				MovePos(lenRes - 1);
+				return lenRes;
+			}
+
+			if (lenMain &gt;= _numFastBytes)
+			{
+				backRes = _matchDistances[numDistancePairs - 1] + Base.kNumRepDistances;
+				MovePos(lenMain - 1);
+				return lenMain;
+			}
+			
+			Byte currentByte = _matchFinder.GetIndexByte(0 - 1);
+			Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - 1));
+
+			if (lenMain &lt; 2 &amp;&amp; currentByte != matchByte &amp;&amp; repLens[repMaxIndex] &lt; 2)
+			{
+				backRes = (UInt32)0xFFFFFFFF;
+				return 1;
+			}
+
+			_optimum[0].State = _state;
+
+			UInt32 posState = (position &amp; _posStateMask);
+
+			_optimum[1].Price = _isMatch[(_state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].GetPrice0() +
+					_literalEncoder.GetSubCoder(position, _previousByte).GetPrice(!_state.IsCharState(), matchByte, currentByte);
+			_optimum[1].MakeAsChar();
+
+			UInt32 matchPrice = _isMatch[(_state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].GetPrice1();
+			UInt32 repMatchPrice = matchPrice + _isRep[_state.Index].GetPrice1();
+
+			if (matchByte == currentByte)
+			{
+				UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(_state, posState);
+				if (shortRepPrice &lt; _optimum[1].Price)
+				{
+					_optimum[1].Price = shortRepPrice;
+					_optimum[1].MakeAsShortRep();
+				}
+			}
+
+			UInt32 lenEnd = ((lenMain &gt;= repLens[repMaxIndex]) ? lenMain : repLens[repMaxIndex]);
+
+			if(lenEnd &lt; 2)
+			{
+				backRes = _optimum[1].BackPrev;
+				return 1;
+			}
+			
+			_optimum[1].PosPrev = 0;
+
+			_optimum[0].Backs0 = reps[0];
+			_optimum[0].Backs1 = reps[1];
+			_optimum[0].Backs2 = reps[2];
+			_optimum[0].Backs3 = reps[3];
+
+			UInt32 len = lenEnd;
+			do
+				_optimum[len--].Price = kIfinityPrice;
+			while (len &gt;= 2);
+
+			for (i = 0; i &lt; Base.kNumRepDistances; i++)
+			{
+				UInt32 repLen = repLens[i];
+				if (repLen &lt; 2)
+					continue;
+				UInt32 price = repMatchPrice + GetPureRepPrice(i, _state, posState);
+				do
+				{
+					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2, posState);
+					Optimal optimum = _optimum[repLen];
+					if (curAndLenPrice &lt; optimum.Price)
+					{
+						optimum.Price = curAndLenPrice;
+						optimum.PosPrev = 0;
+						optimum.BackPrev = i;
+						optimum.Prev1IsChar = false;
+					}
+				}
+				while (--repLen &gt;= 2);
+			}
+
+			UInt32 normalMatchPrice = matchPrice + _isRep[_state.Index].GetPrice0();
+			
+			len = ((repLens[0] &gt;= 2) ? repLens[0] + 1 : 2);
+			if (len &lt;= lenMain)
+			{
+				UInt32 offs = 0;
+				while (len &gt; _matchDistances[offs])
+					offs += 2;
+				for (; ; len++)
+				{
+					UInt32 distance = _matchDistances[offs + 1];
+					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance, len, posState);
+					Optimal optimum = _optimum[len];
+					if (curAndLenPrice &lt; optimum.Price)
+					{
+						optimum.Price = curAndLenPrice;
+						optimum.PosPrev = 0;
+						optimum.BackPrev = distance + Base.kNumRepDistances;
+						optimum.Prev1IsChar = false;
+					}
+					if (len == _matchDistances[offs])
+					{
+						offs += 2;
+						if (offs == numDistancePairs)
+							break;
+					}
+				}
+			}
+
+			UInt32 cur = 0;
+
+			while (true)
+			{
+				cur++;
+				if (cur == lenEnd)
+					return Backward(out backRes, cur);
+				UInt32 newLen;
+				ReadMatchDistances(out newLen, out numDistancePairs);
+				if (newLen &gt;= _numFastBytes)
+				{
+					_numDistancePairs = numDistancePairs;
+					_longestMatchLength = newLen;
+					_longestMatchWasFound = true;
+					return Backward(out backRes, cur);
+				}
+				position++;
+				UInt32 posPrev = _optimum[cur].PosPrev;
+				Base.State state;
+				if (_optimum[cur].Prev1IsChar)
+				{
+					posPrev--;
+					if (_optimum[cur].Prev2)
+					{
+						state = _optimum[_optimum[cur].PosPrev2].State;
+						if (_optimum[cur].BackPrev2 &lt; Base.kNumRepDistances)
+							state.UpdateRep();
+						else
+							state.UpdateMatch();
+					}
+					else
+						state = _optimum[posPrev].State;
+					state.UpdateChar();
+				}
+				else
+					state = _optimum[posPrev].State;
+				if (posPrev == cur - 1)
+				{
+					if (_optimum[cur].IsShortRep())
+						state.UpdateShortRep();
+					else
+						state.UpdateChar();
+				}
+				else
+				{
+					UInt32 pos;
+					if (_optimum[cur].Prev1IsChar &amp;&amp; _optimum[cur].Prev2)
+					{
+						posPrev = _optimum[cur].PosPrev2;
+						pos = _optimum[cur].BackPrev2;
+						state.UpdateRep();
+					}
+					else
+					{
+						pos = _optimum[cur].BackPrev;
+						if (pos &lt; Base.kNumRepDistances)
+							state.UpdateRep();
+						else
+							state.UpdateMatch();
+					}
+					Optimal opt = _optimum[posPrev];
+					if (pos &lt; Base.kNumRepDistances)
+					{
+						if (pos == 0)
+						{
+							reps[0] = opt.Backs0;
+							reps[1] = opt.Backs1;
+							reps[2] = opt.Backs2;
+							reps[3] = opt.Backs3;
+						}
+						else if (pos == 1)
+						{
+							reps[0] = opt.Backs1;
+							reps[1] = opt.Backs0;
+							reps[2] = opt.Backs2;
+							reps[3] = opt.Backs3;
+						}
+						else if (pos == 2)
+						{
+							reps[0] = opt.Backs2;
+							reps[1] = opt.Backs0;
+							reps[2] = opt.Backs1;
+							reps[3] = opt.Backs3;
+						}
+						else
+						{
+							reps[0] = opt.Backs3;
+							reps[1] = opt.Backs0;
+							reps[2] = opt.Backs1;
+							reps[3] = opt.Backs2;
+						}
+					}
+					else
+					{
+						reps[0] = (pos - Base.kNumRepDistances);
+						reps[1] = opt.Backs0;
+						reps[2] = opt.Backs1;
+						reps[3] = opt.Backs2;
+					}
+				}
+				_optimum[cur].State = state;
+				_optimum[cur].Backs0 = reps[0];
+				_optimum[cur].Backs1 = reps[1];
+				_optimum[cur].Backs2 = reps[2];
+				_optimum[cur].Backs3 = reps[3];
+				UInt32 curPrice = _optimum[cur].Price;
+
+				currentByte = _matchFinder.GetIndexByte(0 - 1);
+				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));
+
+				posState = (position &amp; _posStateMask);
+
+				UInt32 curAnd1Price = curPrice +
+					_isMatch[(state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].GetPrice0() +
+					_literalEncoder.GetSubCoder(position, _matchFinder.GetIndexByte(0 - 2)).
+					GetPrice(!state.IsCharState(), matchByte, currentByte);
+
+				Optimal nextOptimum = _optimum[cur + 1];
+
+				bool nextIsChar = false;
+				if (curAnd1Price &lt; nextOptimum.Price)
+				{
+					nextOptimum.Price = curAnd1Price;
+					nextOptimum.PosPrev = cur;
+					nextOptimum.MakeAsChar();
+					nextIsChar = true;
+				}
+
+				matchPrice = curPrice + _isMatch[(state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].GetPrice1();
+				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();
+
+				if (matchByte == currentByte &amp;&amp;
+					!(nextOptimum.PosPrev &lt; cur &amp;&amp; nextOptimum.BackPrev == 0))
+				{
+					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);
+					if (shortRepPrice &lt;= nextOptimum.Price)
+					{
+						nextOptimum.Price = shortRepPrice;
+						nextOptimum.PosPrev = cur;
+						nextOptimum.MakeAsShortRep();
+						nextIsChar = true;
+					}
+				}
+
+				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;
+				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur, numAvailableBytesFull);
+				numAvailableBytes = numAvailableBytesFull;
+
+				if (numAvailableBytes &lt; 2)
+					continue;
+				if (numAvailableBytes &gt; _numFastBytes)
+					numAvailableBytes = _numFastBytes;
+				if (!nextIsChar &amp;&amp; matchByte != currentByte)
+				{
+					// try Literal + rep0
+					UInt32 t = Math.Min(numAvailableBytesFull - 1, _numFastBytes);
+					UInt32 lenTest2 = _matchFinder.GetMatchLen(0, reps[0], t);
+					if (lenTest2 &gt;= 2)
+					{
+						Base.State state2 = state;
+						state2.UpdateChar();
+						UInt32 posStateNext = (position + 1) &amp; _posStateMask;
+						UInt32 nextRepMatchPrice = curAnd1Price +
+							_isMatch[(state2.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +
+							_isRep[state2.Index].GetPrice1();
+						{
+							UInt32 offset = cur + 1 + lenTest2;
+							while (lenEnd &lt; offset)
+								_optimum[++lenEnd].Price = kIfinityPrice;
+							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(
+								0, lenTest2, state2, posStateNext);
+							Optimal optimum = _optimum[offset];
+							if (curAndLenPrice &lt; optimum.Price)
+							{
+								optimum.Price = curAndLenPrice;
+								optimum.PosPrev = cur + 1;
+								optimum.BackPrev = 0;
+								optimum.Prev1IsChar = true;
+								optimum.Prev2 = false;
+							}
+						}
+					}
+				}
+
+				UInt32 startLen = 2; // speed optimization 
+
+				for (UInt32 repIndex = 0; repIndex &lt; Base.kNumRepDistances; repIndex++)
+				{
+					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1, reps[repIndex], numAvailableBytes);
+					if (lenTest &lt; 2)
+						continue;
+					UInt32 lenTestTemp = lenTest;
+					do
+					{
+						while (lenEnd &lt; cur + lenTest)
+							_optimum[++lenEnd].Price = kIfinityPrice;
+						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState);
+						Optimal optimum = _optimum[cur + lenTest];
+						if (curAndLenPrice &lt; optimum.Price)
+						{
+							optimum.Price = curAndLenPrice;
+							optimum.PosPrev = cur;
+							optimum.BackPrev = repIndex;
+							optimum.Prev1IsChar = false;
+						}
+					}
+					while(--lenTest &gt;= 2);
+					lenTest = lenTestTemp;
+
+					if (repIndex == 0)
+						startLen = lenTest + 1;
+
+					// if (_maxMode)
+					if (lenTest &lt; numAvailableBytesFull)
+					{
+						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
+						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest, reps[repIndex], t);
+						if (lenTest2 &gt;= 2)
+						{
+							Base.State state2 = state;
+							state2.UpdateRep();
+							UInt32 posStateNext = (position + lenTest) &amp; _posStateMask;
+							UInt32 curAndLenCharPrice = 
+									repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState) + 
+									_isMatch[(state2.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +
+									_literalEncoder.GetSubCoder(position + lenTest, 
+									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true,
+									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))), 
+									_matchFinder.GetIndexByte((Int32)lenTest - 1));
+							state2.UpdateChar();
+							posStateNext = (position + lenTest + 1) &amp; _posStateMask;
+							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();
+							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();
+							
+							// for(; lenTest2 &gt;= 2; lenTest2--)
+							{
+								UInt32 offset = lenTest + 1 + lenTest2;
+								while(lenEnd &lt; cur + offset)
+									_optimum[++lenEnd].Price = kIfinityPrice;
+								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
+								Optimal optimum = _optimum[cur + offset];
+								if (curAndLenPrice &lt; optimum.Price) 
+								{
+									optimum.Price = curAndLenPrice;
+									optimum.PosPrev = cur + lenTest + 1;
+									optimum.BackPrev = 0;
+									optimum.Prev1IsChar = true;
+									optimum.Prev2 = true;
+									optimum.PosPrev2 = cur;
+									optimum.BackPrev2 = repIndex;
+								}
+							}
+						}
+					}
+				}
+
+				if (newLen &gt; numAvailableBytes)
+				{
+					newLen = numAvailableBytes;
+					for (numDistancePairs = 0; newLen &gt; _matchDistances[numDistancePairs]; numDistancePairs += 2) ;
+					_matchDistances[numDistancePairs] = newLen;
+					numDistancePairs += 2;
+				}
+				if (newLen &gt;= startLen)
+				{
+					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();
+					while (lenEnd &lt; cur + newLen)
+						_optimum[++lenEnd].Price = kIfinityPrice;
+
+					UInt32 offs = 0;
+					while (startLen &gt; _matchDistances[offs])
+						offs += 2;
+
+					for (UInt32 lenTest = startLen; ; lenTest++)
+					{
+						UInt32 curBack = _matchDistances[offs + 1];
+						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack, lenTest, posState);
+						Optimal optimum = _optimum[cur + lenTest];
+						if (curAndLenPrice &lt; optimum.Price)
+						{
+							optimum.Price = curAndLenPrice;
+							optimum.PosPrev = cur;
+							optimum.BackPrev = curBack + Base.kNumRepDistances;
+							optimum.Prev1IsChar = false;
+						}
+
+						if (lenTest == _matchDistances[offs])
+						{
+							if (lenTest &lt; numAvailableBytesFull)
+							{
+								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
+								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest, curBack, t);
+								if (lenTest2 &gt;= 2)
+								{
+									Base.State state2 = state;
+									state2.UpdateMatch();
+									UInt32 posStateNext = (position + lenTest) &amp; _posStateMask;
+									UInt32 curAndLenCharPrice = curAndLenPrice +
+										_isMatch[(state2.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +
+										_literalEncoder.GetSubCoder(position + lenTest,
+										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).
+										GetPrice(true,
+										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1),
+										_matchFinder.GetIndexByte((Int32)lenTest - 1));
+									state2.UpdateChar();
+									posStateNext = (position + lenTest + 1) &amp; _posStateMask;
+									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();
+									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();
+
+									UInt32 offset = lenTest + 1 + lenTest2;
+									while (lenEnd &lt; cur + offset)
+										_optimum[++lenEnd].Price = kIfinityPrice;
+									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
+									optimum = _optimum[cur + offset];
+									if (curAndLenPrice &lt; optimum.Price)
+									{
+										optimum.Price = curAndLenPrice;
+										optimum.PosPrev = cur + lenTest + 1;
+										optimum.BackPrev = 0;
+										optimum.Prev1IsChar = true;
+										optimum.Prev2 = true;
+										optimum.PosPrev2 = cur;
+										optimum.BackPrev2 = curBack + Base.kNumRepDistances;
+									}
+								}
+							}
+							offs += 2;
+							if (offs == numDistancePairs)
+								break;
+						}
+					}
+				}
+			}
+		}
+
+		bool ChangePair(UInt32 smallDist, UInt32 bigDist)
+		{
+			const int kDif = 7;
+			return (smallDist &lt; ((UInt32)(1) &lt;&lt; (32 - kDif)) &amp;&amp; bigDist &gt;= (smallDist &lt;&lt; kDif));
+		}
+
+		void WriteEndMarker(UInt32 posState)
+		{
+			if (!_writeEndMark)
+				return;
+
+			_isMatch[(_state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].Encode(_rangeEncoder, 1);
+			_isRep[_state.Index].Encode(_rangeEncoder, 0);
+			_state.UpdateMatch();
+			UInt32 len = Base.kMatchMinLen;
+			_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
+			UInt32 posSlot = (1 &lt;&lt; Base.kNumPosSlotBits) - 1;
+			UInt32 lenToPosState = Base.GetLenToPosState(len);
+			_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);
+			int footerBits = 30;
+			UInt32 posReduced = (((UInt32)1) &lt;&lt; footerBits) - 1;
+			_rangeEncoder.EncodeDirectBits(posReduced &gt;&gt; Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
+			_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced &amp; Base.kAlignMask);
+		}
+
+		void Flush(UInt32 nowPos)
+		{
+			ReleaseMFStream();
+			WriteEndMarker(nowPos &amp; _posStateMask);
+			_rangeEncoder.FlushData();
+			_rangeEncoder.FlushStream();
+		}
+
+		public void CodeOneBlock(out Int64 inSize, out Int64 outSize, out bool finished)
+		{
+			inSize = 0;
+			outSize = 0;
+			finished = true;
+
+			if (_inStream != null)
+			{
+				_matchFinder.SetStream(_inStream);
+				_matchFinder.Init();
+				_needReleaseMFStream = true;
+				_inStream = null;
+			}
+
+			if (_finished)
+				return;
+			_finished = true;
+
+
+			Int64 progressPosValuePrev = nowPos64;
+			if (nowPos64 == 0)
+			{
+				if (_matchFinder.GetNumAvailableBytes() == 0)
+				{
+					Flush((UInt32)nowPos64);
+					return;
+				}
+				UInt32 len, numDistancePairs; // it's not used
+				ReadMatchDistances(out len, out numDistancePairs);
+				UInt32 posState = (UInt32)(nowPos64) &amp; _posStateMask;
+				_isMatch[(_state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState].Encode(_rangeEncoder, 0);
+				_state.UpdateChar();
+				Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));
+				_literalEncoder.GetSubCoder((UInt32)(nowPos64), _previousByte).Encode(_rangeEncoder, curByte);
+				_previousByte = curByte;
+				_additionalOffset--;
+				nowPos64++;
+			}
+			if (_matchFinder.GetNumAvailableBytes() == 0)
+			{
+				Flush((UInt32)nowPos64);
+				return;
+			}
+			while (true)
+			{
+				UInt32 pos;
+				UInt32 len = GetOptimum((UInt32)nowPos64, out pos);
+				
+				UInt32 posState = ((UInt32)nowPos64) &amp; _posStateMask;
+				UInt32 complexState = (_state.Index &lt;&lt; Base.kNumPosStatesBitsMax) + posState;
+				if (len == 1 &amp;&amp; pos == 0xFFFFFFFF)
+				{
+					_isMatch[complexState].Encode(_rangeEncoder, 0);
+					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));
+					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64, _previousByte);
+					if (!_state.IsCharState())
+					{
+						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));
+						subCoder.EncodeMatched(_rangeEncoder, matchByte, curByte);
+					}
+					else
+						subCoder.Encode(_rangeEncoder, curByte);
+					_previousByte = curByte;
+					_state.UpdateChar();
+				}
+				else
+				{
+					_isMatch[complexState].Encode(_rangeEncoder, 1);
+					if (pos &lt; Base.kNumRepDistances)
+					{
+						_isRep[_state.Index].Encode(_rangeEncoder, 1);
+						if (pos == 0)
+						{
+							_isRepG0[_state.Index].Encode(_rangeEncoder, 0);
+							if (len == 1)
+								_isRep0Long[complexState].Encode(_rangeEncoder, 0);
+							else
+								_isRep0Long[complexState].Encode(_rangeEncoder, 1);
+						}
+						else
+						{
+							_isRepG0[_state.Index].Encode(_rangeEncoder, 1);
+							if (pos == 1)
+								_isRepG1[_state.Index].Encode(_rangeEncoder, 0);
+							else
+							{
+								_isRepG1[_state.Index].Encode(_rangeEncoder, 1);
+								_isRepG2[_state.Index].Encode(_rangeEncoder, pos - 2);
+							}
+						}
+						if (len == 1)
+							_state.UpdateShortRep();
+						else
+						{
+							_repMatchLenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
+							_state.UpdateRep();
+						}
+						UInt32 distance = _repDistances[pos];
+						if (pos != 0)
+						{
+							for (UInt32 i = pos; i &gt;= 1; i--)
+								_repDistances[i] = _repDistances[i - 1];
+							_repDistances[0] = distance;
+						}
+					}
+					else
+					{
+						_isRep[_state.Index].Encode(_rangeEncoder, 0);
+						_state.UpdateMatch();
+						_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
+						pos -= Base.kNumRepDistances;
+						UInt32 posSlot = GetPosSlot(pos);
+						UInt32 lenToPosState = Base.GetLenToPosState(len);
+						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);
+
+						if (posSlot &gt;= Base.kStartPosModelIndex)
+						{
+							int footerBits = (int)((posSlot &gt;&gt; 1) - 1);
+							UInt32 baseVal = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+							UInt32 posReduced = pos - baseVal;
+
+							if (posSlot &lt; Base.kEndPosModelIndex)
+								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders,
+										baseVal - posSlot - 1, _rangeEncoder, footerBits, posReduced);
+							else
+							{
+								_rangeEncoder.EncodeDirectBits(posReduced &gt;&gt; Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
+								_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced &amp; Base.kAlignMask);
+								_alignPriceCount++;
+							}
+						}
+						UInt32 distance = pos;
+						for (UInt32 i = Base.kNumRepDistances - 1; i &gt;= 1; i--)
+							_repDistances[i] = _repDistances[i - 1];
+						_repDistances[0] = distance;
+						_matchPriceCount++;
+					}
+					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));
+				}
+				_additionalOffset -= len;
+				nowPos64 += len;
+				if (_additionalOffset == 0)
+				{
+					// if (!_fastMode)
+					if (_matchPriceCount &gt;= (1 &lt;&lt; 7))
+						FillDistancesPrices();
+					if (_alignPriceCount &gt;= Base.kAlignTableSize)
+						FillAlignPrices();
+					inSize = nowPos64;
+					outSize = _rangeEncoder.GetProcessedSizeAdd();
+					if (_matchFinder.GetNumAvailableBytes() == 0)
+					{
+						Flush((UInt32)nowPos64);
+						return;
+					}
+
+					if (nowPos64 - progressPosValuePrev &gt;= (1 &lt;&lt; 12))
+					{
+						_finished = false;
+						finished = false;
+						return;
+					}
+				}
+			}
+		}
+
+		void ReleaseMFStream()
+		{
+			if (_matchFinder != null &amp;&amp; _needReleaseMFStream)
+			{
+				_matchFinder.ReleaseStream();
+				_needReleaseMFStream = false;
+			}
+		}
+
+		void SetOutStream(System.IO.Stream outStream) { _rangeEncoder.SetStream(outStream); }
+		void ReleaseOutStream() { _rangeEncoder.ReleaseStream(); }
+
+		void ReleaseStreams()
+		{
+			ReleaseMFStream();
+			ReleaseOutStream();
+		}
+
+		void SetStreams(System.IO.Stream inStream, System.IO.Stream outStream,
+				Int64 inSize, Int64 outSize)
+		{
+			_inStream = inStream;
+			_finished = false;
+			Create();
+			SetOutStream(outStream);
+			Init();
+
+			// if (!_fastMode)
+			{
+				FillDistancesPrices();
+				FillAlignPrices();
+			}
+
+			_lenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
+			_lenEncoder.UpdateTables((UInt32)1 &lt;&lt; _posStateBits);
+			_repMatchLenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
+			_repMatchLenEncoder.UpdateTables((UInt32)1 &lt;&lt; _posStateBits);
+
+			nowPos64 = 0;
+		}
+
+
+		public void Code(System.IO.Stream inStream, System.IO.Stream outStream,
+			Int64 inSize, Int64 outSize, ICodeProgress progress)
+		{
+			_needReleaseMFStream = false;
+			try
+			{
+				SetStreams(inStream, outStream, inSize, outSize);
+				while (true)
+				{
+					Int64 processedInSize;
+					Int64 processedOutSize;
+					bool finished;
+					CodeOneBlock(out processedInSize, out processedOutSize, out finished);
+					if (finished)
+						return;
+					if (progress != null)
+					{
+						progress.SetProgress(processedInSize, processedOutSize);
+					}
+				}
+			}
+			finally
+			{
+				ReleaseStreams();
+			}
+		}
+
+		const int kPropSize = 5;
+		Byte[] properties = new Byte[kPropSize];
+
+		public void WriteCoderProperties(System.IO.Stream outStream)
+		{
+			properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
+			for (int i = 0; i &lt; 4; i++)
+				properties[1 + i] = (Byte)(_dictionarySize &gt;&gt; (8 * i));
+			outStream.Write(properties, 0, kPropSize);
+		}
+		
+		UInt32[] tempPrices = new UInt32[Base.kNumFullDistances];
+		UInt32 _matchPriceCount;
+
+		void FillDistancesPrices()
+		{
+			for (UInt32 i = Base.kStartPosModelIndex; i &lt; Base.kNumFullDistances; i++)
+			{ 
+				UInt32 posSlot = GetPosSlot(i);
+				int footerBits = (int)((posSlot &gt;&gt; 1) - 1);
+				UInt32 baseVal = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+				tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders, 
+					baseVal - posSlot - 1, footerBits, i - baseVal);
+			}
+
+			for (UInt32 lenToPosState = 0; lenToPosState &lt; Base.kNumLenToPosStates; lenToPosState++)
+			{
+				UInt32 posSlot;
+				RangeCoder.BitTreeEncoder encoder = _posSlotEncoder[lenToPosState];
+			
+				UInt32 st = (lenToPosState &lt;&lt; Base.kNumPosSlotBits);
+				for (posSlot = 0; posSlot &lt; _distTableSize; posSlot++)
+					_posSlotPrices[st + posSlot] = encoder.GetPrice(posSlot);
+				for (posSlot = Base.kEndPosModelIndex; posSlot &lt; _distTableSize; posSlot++)
+					_posSlotPrices[st + posSlot] += ((((posSlot &gt;&gt; 1) - 1) - Base.kNumAlignBits) &lt;&lt; RangeCoder.BitEncoder.kNumBitPriceShiftBits);
+
+				UInt32 st2 = lenToPosState * Base.kNumFullDistances;
+				UInt32 i;
+				for (i = 0; i &lt; Base.kStartPosModelIndex; i++)
+					_distancesPrices[st2 + i] = _posSlotPrices[st + i];
+				for (; i &lt; Base.kNumFullDistances; i++)
+					_distancesPrices[st2 + i] = _posSlotPrices[st + GetPosSlot(i)] + tempPrices[i];
+			}
+			_matchPriceCount = 0;
+		}
+
+		void FillAlignPrices()
+		{
+			for (UInt32 i = 0; i &lt; Base.kAlignTableSize; i++)
+				_alignPrices[i] = _posAlignEncoder.ReverseGetPrice(i);
+			_alignPriceCount = 0;
+		}
+
+
+		static string[] kMatchFinderIDs = 
+		{
+			&quot;BT2&quot;,
+			&quot;BT4&quot;,
+		};
+
+		static int FindMatchFinder(string s)
+		{
+			for (int m = 0; m &lt; kMatchFinderIDs.Length; m++)
+				if (s == kMatchFinderIDs[m])
+					return m;
+			return -1;
+		}
+	
+		public void SetCoderProperties(CoderPropID[] propIDs, object[] properties)
+		{
+			for (UInt32 i = 0; i &lt; properties.Length; i++)
+			{
+				object prop = properties[i];
+				switch (propIDs[i])
+				{
+					case CoderPropID.NumFastBytes:
+					{
+						if (!(prop is Int32))
+							throw new InvalidParamException();
+						Int32 numFastBytes = (Int32)prop;
+						if (numFastBytes &lt; 5 || numFastBytes &gt; Base.kMatchMaxLen)
+							throw new InvalidParamException();
+						_numFastBytes = (UInt32)numFastBytes;
+						break;
+					}
+					case CoderPropID.Algorithm:
+					{
+						/*
+						if (!(prop is Int32))
+							throw new InvalidParamException();
+						Int32 maximize = (Int32)prop;
+						_fastMode = (maximize == 0);
+						_maxMode = (maximize &gt;= 2);
+						*/
+						break;
+					}
+					case CoderPropID.MatchFinder:
+					{
+						if (!(prop is String))
+							throw new InvalidParamException();
+						EMatchFinderType matchFinderIndexPrev = _matchFinderType;
+						int m = FindMatchFinder(((string)prop).ToUpper());
+						if (m &lt; 0)
+							throw new InvalidParamException();
+						_matchFinderType = (EMatchFinderType)m;
+						if (_matchFinder != null &amp;&amp; matchFinderIndexPrev != _matchFinderType)
+							{
+							_dictionarySizePrev = 0xFFFFFFFF;
+							_matchFinder = null;
+							}
+						break;
+					}
+					case CoderPropID.DictionarySize:
+					{
+						const int kDicLogSizeMaxCompress = 30;
+						if (!(prop is Int32))
+							throw new InvalidParamException(); ;
+						Int32 dictionarySize = (Int32)prop;
+						if (dictionarySize &lt; (UInt32)(1 &lt;&lt; Base.kDicLogSizeMin) ||
+							dictionarySize &gt; (UInt32)(1 &lt;&lt; kDicLogSizeMaxCompress))
+							throw new InvalidParamException();
+						_dictionarySize = (UInt32)dictionarySize;
+						int dicLogSize;
+						for (dicLogSize = 0; dicLogSize &lt; (UInt32)kDicLogSizeMaxCompress; dicLogSize++)
+							if (dictionarySize &lt;= ((UInt32)(1) &lt;&lt; dicLogSize))
+								break;
+						_distTableSize = (UInt32)dicLogSize * 2;
+						break;
+					}
+					case CoderPropID.PosStateBits:
+					{
+						if (!(prop is Int32))
+							throw new InvalidParamException();
+						Int32 v = (Int32)prop;
+						if (v &lt; 0 || v &gt; (UInt32)Base.kNumPosStatesBitsEncodingMax)
+							throw new InvalidParamException();
+						_posStateBits = (int)v;
+						_posStateMask = (((UInt32)1) &lt;&lt; (int)_posStateBits) - 1;
+						break;
+					}
+					case CoderPropID.LitPosBits:
+					{
+						if (!(prop is Int32))
+							throw new InvalidParamException();
+						Int32 v = (Int32)prop;
+						if (v &lt; 0 || v &gt; (UInt32)Base.kNumLitPosStatesBitsEncodingMax)
+							throw new InvalidParamException();
+						_numLiteralPosStateBits = (int)v;
+						break;
+					}
+					case CoderPropID.LitContextBits:
+					{
+						if (!(prop is Int32))
+							throw new InvalidParamException();
+						Int32 v = (Int32)prop;
+						if (v &lt; 0 || v &gt; (UInt32)Base.kNumLitContextBitsMax)
+							throw new InvalidParamException(); ;
+						_numLiteralContextBits = (int)v;
+						break;
+					}
+					case CoderPropID.EndMarker:
+					{
+						if (!(prop is Boolean))
+							throw new InvalidParamException();
+						SetWriteEndMarkerMode((Boolean)prop);
+						break;
+					}
+					default:
+						throw new InvalidParamException();
+				}
+			}
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LZMA/LzmaEncoder.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,281 @@
+using System;
+using System.IO;
+namespace SevenZip
+{
+	using CommandLineParser;
+	class LzmaAlone
+	{
+		enum Key
+		{
+			Help1 = 0,
+			Help2,
+			Mode,
+			Dictionary,
+			FastBytes,
+			LitContext,
+			LitPos,
+			PosBits,
+			MatchFinder,
+			EOS,
+			StdIn,
+			StdOut
+		};
+
+		static void PrintHelp()
+		{
+			System.Console.WriteLine(&quot;\nUsage:  LZMA &lt;e|d&gt; [&lt;switches&gt;...] inputFile outputFile\n&quot; +
+				&quot;  e: encode file\n&quot; +
+				&quot;  d: decode file\n&quot; +
+				&quot;  b: Benchmark\n&quot; +
+				&quot;&lt;Switches&gt;\n&quot; +
+				// &quot;  -a{N}:  set compression mode - [0, 1], default: 1 (max)\n&quot; +
+				&quot;  -d{N}:  set dictionary - [0, 29], default: 23 (8MB)\n&quot; +
+				&quot;  -fb{N}: set number of fast bytes - [5, 273], default: 128\n&quot; +
+				&quot;  -lc{N}: set number of literal context bits - [0, 8], default: 3\n&quot; +
+				&quot;  -lp{N}: set number of literal pos bits - [0, 4], default: 0\n&quot; +
+				&quot;  -pb{N}: set number of pos bits - [0, 4], default: 2\n&quot; +
+				&quot;  -mf{MF_ID}: set Match Finder: [bt2, bt4], default: bt4\n&quot; +
+				&quot;  -eos:   write End Of Stream marker\n&quot;
+				// + &quot;  -si:    read data from stdin\n&quot;
+				// + &quot;  -so:    write data to stdout\n&quot;
+				);
+		}
+
+		static bool GetNumber(string s, out Int32 v)
+		{
+			v = 0;
+			for (int i = 0; i &lt; s.Length; i++)
+			{
+				char c = s[i];
+				if (c &lt; '0' || c &gt; '9')
+					return false;
+				v *= 10;
+				v += (Int32)(c - '0');
+			}
+			return true;
+		}
+
+		static int IncorrectCommand()
+		{
+			throw (new Exception(&quot;Command line error&quot;));
+			// System.Console.WriteLine(&quot;\nCommand line error\n&quot;);
+			// return 1;
+		}
+		static int Main2(string[] args)
+		{
+			System.Console.WriteLine(&quot;\nLZMA# 4.42 Copyright (c) 1999-2006 Igor Pavlov  2006-05-15\n&quot;);
+
+			if (args.Length == 0)
+			{
+				PrintHelp();
+				return 0;
+			}
+
+			SwitchForm[] kSwitchForms = new SwitchForm[12];
+			int sw = 0;
+			kSwitchForms[sw++] = new SwitchForm(&quot;?&quot;, SwitchType.Simple, false);
+			kSwitchForms[sw++] = new SwitchForm(&quot;H&quot;, SwitchType.Simple, false);
+			kSwitchForms[sw++] = new SwitchForm(&quot;A&quot;, SwitchType.UnLimitedPostString, false, 1);
+			kSwitchForms[sw++] = new SwitchForm(&quot;D&quot;, SwitchType.UnLimitedPostString, false, 1);
+			kSwitchForms[sw++] = new SwitchForm(&quot;FB&quot;, SwitchType.UnLimitedPostString, false, 1);
+			kSwitchForms[sw++] = new SwitchForm(&quot;LC&quot;, SwitchType.UnLimitedPostString, false, 1);
+			kSwitchForms[sw++] = new SwitchForm(&quot;LP&quot;, SwitchType.UnLimitedPostString, false, 1);
+			kSwitchForms[sw++] = new SwitchForm(&quot;PB&quot;, SwitchType.UnLimitedPostString, false, 1);
+			kSwitchForms[sw++] = new SwitchForm(&quot;MF&quot;, SwitchType.UnLimitedPostString, false, 1);
+			kSwitchForms[sw++] = new SwitchForm(&quot;EOS&quot;, SwitchType.Simple, false);
+			kSwitchForms[sw++] = new SwitchForm(&quot;SI&quot;, SwitchType.Simple, false);
+			kSwitchForms[sw++] = new SwitchForm(&quot;SO&quot;, SwitchType.Simple, false);
+
+
+			Parser parser = new Parser(sw);
+			try
+			{
+				parser.ParseStrings(kSwitchForms, args);
+			}
+			catch
+			{
+				return IncorrectCommand();
+			}
+
+			if (parser[(int)Key.Help1].ThereIs || parser[(int)Key.Help2].ThereIs)
+			{
+				PrintHelp();
+				return 0;
+			}
+
+			System.Collections.ArrayList nonSwitchStrings = parser.NonSwitchStrings;
+
+			int paramIndex = 0;
+			if (paramIndex &gt;= nonSwitchStrings.Count)
+				return IncorrectCommand();
+			string command = (string)nonSwitchStrings[paramIndex++];
+			command = command.ToLower();
+
+			bool dictionaryIsDefined = false;
+			Int32 dictionary = 1 &lt;&lt; 21;
+			if (parser[(int)Key.Dictionary].ThereIs)
+			{
+				Int32 dicLog;
+				if (!GetNumber((string)parser[(int)Key.Dictionary].PostStrings[0], out dicLog))
+					IncorrectCommand();
+				dictionary = (Int32)1 &lt;&lt; dicLog;
+				dictionaryIsDefined = true;
+			}
+			string mf = &quot;bt4&quot;;
+			if (parser[(int)Key.MatchFinder].ThereIs)
+				mf = (string)parser[(int)Key.MatchFinder].PostStrings[0];
+			mf = mf.ToLower();
+
+			if (command == &quot;b&quot;)
+			{
+				const Int32 kNumDefaultItereations = 10;
+				Int32 numIterations = kNumDefaultItereations;
+				if (paramIndex &lt; nonSwitchStrings.Count)
+					if (!GetNumber((string)nonSwitchStrings[paramIndex++], out numIterations))
+						numIterations = kNumDefaultItereations;
+				return LzmaBench.LzmaBenchmark(numIterations, (UInt32)dictionary);
+			}
+
+			bool encodeMode = false;
+			if (command == &quot;e&quot;)
+				encodeMode = true;
+			else if (command == &quot;d&quot;)
+				encodeMode = false;
+			else
+				IncorrectCommand();
+
+			bool stdInMode = parser[(int)Key.StdIn].ThereIs;
+			bool stdOutMode = parser[(int)Key.StdOut].ThereIs;
+
+			FileStream inStream = null;
+			if (stdInMode)
+			{
+				throw (new Exception(&quot;Not implemeted&quot;));
+			}
+			else
+			{
+				if (paramIndex &gt;= nonSwitchStrings.Count)
+					IncorrectCommand();
+				string inputName = (string)nonSwitchStrings[paramIndex++];
+				inStream = new FileStream(inputName, FileMode.Open, FileAccess.Read);
+			}
+
+			FileStream outStream = null;
+			if (stdOutMode)
+			{
+				throw (new Exception(&quot;Not implemeted&quot;));
+			}
+			else
+			{
+				if (paramIndex &gt;= nonSwitchStrings.Count)
+					IncorrectCommand();
+				string outputName = (string)nonSwitchStrings[paramIndex++];
+				outStream = new FileStream(outputName, FileMode.Create, FileAccess.Write);
+			}
+
+			if (encodeMode)
+			{
+				if (!dictionaryIsDefined)
+					dictionary = 1 &lt;&lt; 23;
+
+				Int32 posStateBits = 2;
+				Int32 litContextBits = 3; // for normal files
+				// UInt32 litContextBits = 0; // for 32-bit data
+				Int32 litPosBits = 0;
+				// UInt32 litPosBits = 2; // for 32-bit data
+				Int32 algorithm = 2;
+				Int32 numFastBytes = 128;
+
+				bool eos = parser[(int)Key.EOS].ThereIs || stdInMode;
+
+				if (parser[(int)Key.Mode].ThereIs)
+					if (!GetNumber((string)parser[(int)Key.Mode].PostStrings[0], out algorithm))
+						IncorrectCommand();
+
+				if (parser[(int)Key.FastBytes].ThereIs)
+					if (!GetNumber((string)parser[(int)Key.FastBytes].PostStrings[0], out numFastBytes))
+						IncorrectCommand();
+				if (parser[(int)Key.LitContext].ThereIs)
+					if (!GetNumber((string)parser[(int)Key.LitContext].PostStrings[0], out litContextBits))
+						IncorrectCommand();
+				if (parser[(int)Key.LitPos].ThereIs)
+					if (!GetNumber((string)parser[(int)Key.LitPos].PostStrings[0], out litPosBits))
+						IncorrectCommand();
+				if (parser[(int)Key.PosBits].ThereIs)
+					if (!GetNumber((string)parser[(int)Key.PosBits].PostStrings[0], out posStateBits))
+						IncorrectCommand();
+
+				CoderPropID[] propIDs = 
+				{
+					CoderPropID.DictionarySize,
+					CoderPropID.PosStateBits,
+					CoderPropID.LitContextBits,
+					CoderPropID.LitPosBits,
+					CoderPropID.Algorithm,
+					CoderPropID.NumFastBytes,
+					CoderPropID.MatchFinder,
+					CoderPropID.EndMarker
+				};
+				object[] properties = 
+				{
+					(Int32)(dictionary),
+					(Int32)(posStateBits),
+					(Int32)(litContextBits),
+					(Int32)(litPosBits),
+					(Int32)(algorithm),
+					(Int32)(numFastBytes),
+					mf,
+					eos
+				};
+
+				Compression.LZMA.Encoder encoder = new Compression.LZMA.Encoder();
+				encoder.SetCoderProperties(propIDs, properties);
+				encoder.WriteCoderProperties(outStream);
+				Int64 fileSize;
+				if (eos || stdInMode)
+					fileSize = -1;
+				else
+					fileSize = inStream.Length;
+				for (int i = 0; i &lt; 8; i++)
+					outStream.WriteByte((Byte)(fileSize &gt;&gt; (8 * i)));
+				encoder.Code(inStream, outStream, -1, -1, null);
+			}
+			else if (command == &quot;d&quot;)
+			{
+				byte[] properties = new byte[5];
+				if (inStream.Read(properties, 0, 5) != 5)
+					throw (new Exception(&quot;input .lzma is too short&quot;));
+				Compression.LZMA.Decoder decoder = new Compression.LZMA.Decoder();
+				decoder.SetDecoderProperties(properties);
+				long outSize = 0;
+				for (int i = 0; i &lt; 8; i++)
+				{
+					int v = inStream.ReadByte();
+					if (v &lt; 0)
+						throw (new Exception(&quot;Can't Read 1&quot;));
+					outSize |= ((long)(byte)v) &lt;&lt; (8 * i);
+				}
+				long compressedSize = inStream.Length - inStream.Position;
+				decoder.Code(inStream, outStream, compressedSize, outSize, null);
+			}
+			else
+				throw (new Exception(&quot;Command Error&quot;));
+			return 0;
+		}
+
+		[STAThread]
+		static int Main(string[] args)
+		{
+			try
+			{
+				return Main2(args);
+			}
+			catch (Exception e)
+			{
+				Console.WriteLine(&quot;{0} Caught exception #1.&quot;, e);
+				// throw e;
+				return 1;
+			}
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.csproj
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.csproj	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.csproj	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,90 @@
+&#65279;&lt;Project DefaultTargets=&quot;Build&quot; xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot;&gt;
+  &lt;PropertyGroup&gt;
+    &lt;Configuration Condition=&quot; '$(Configuration)' == '' &quot;&gt;Debug&lt;/Configuration&gt;
+    &lt;Platform Condition=&quot; '$(Platform)' == '' &quot;&gt;AnyCPU&lt;/Platform&gt;
+    &lt;ProductVersion&gt;8.0.50727&lt;/ProductVersion&gt;
+    &lt;SchemaVersion&gt;2.0&lt;/SchemaVersion&gt;
+    &lt;ProjectGuid&gt;{CE33DF18-F9C8-4D6F-9057-DBB4DB96E973}&lt;/ProjectGuid&gt;
+    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
+    &lt;RootNamespace&gt;LzmaAlone&lt;/RootNamespace&gt;
+    &lt;AssemblyName&gt;Lzma#&lt;/AssemblyName&gt;
+    &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' &quot;&gt;
+    &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
+    &lt;DebugType&gt;full&lt;/DebugType&gt;
+    &lt;Optimize&gt;false&lt;/Optimize&gt;
+    &lt;OutputPath&gt;.\bin\Debug\&lt;/OutputPath&gt;
+    &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Release|AnyCPU' &quot;&gt;
+    &lt;DebugSymbols&gt;false&lt;/DebugSymbols&gt;
+    &lt;Optimize&gt;true&lt;/Optimize&gt;
+    &lt;OutputPath&gt;.\bin\Release\&lt;/OutputPath&gt;
+    &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
+    &lt;PlatformTarget&gt;AnyCPU&lt;/PlatformTarget&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;ItemGroup&gt;
+    &lt;Reference Include=&quot;System&quot; /&gt;
+    &lt;Reference Include=&quot;System.Data&quot; /&gt;
+    &lt;Reference Include=&quot;System.Xml&quot; /&gt;
+  &lt;/ItemGroup&gt;
+  &lt;ItemGroup&gt;
+    &lt;Compile Include=&quot;..\..\Common\CommandLineParser.cs&quot;&gt;
+      &lt;Link&gt;Common\CommandLineParser.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\..\Common\CRC.cs&quot;&gt;
+      &lt;Link&gt;Common\CRC.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\..\ICoder.cs&quot;&gt;
+      &lt;Link&gt;ICoder.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\LZ\IMatchFinder.cs&quot;&gt;
+      &lt;Link&gt;LZ\IMatchFinder.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\LZ\LzBinTree.cs&quot;&gt;
+      &lt;Link&gt;LZ\LzBinTree.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\LZ\LzInWindow.cs&quot;&gt;
+      &lt;Link&gt;LZ\LzInWindow.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\LZ\LzOutWindow.cs&quot;&gt;
+      &lt;Link&gt;LZ\LzOutWindow.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\LZMA\LzmaBase.cs&quot;&gt;
+      &lt;Link&gt;LZMA\LzmaBase.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\LZMA\LzmaDecoder.cs&quot;&gt;
+      &lt;Link&gt;LZMA\LzmaDecoder.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\LZMA\LzmaEncoder.cs&quot;&gt;
+      &lt;Link&gt;LZMA\LzmaEncoder.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\RangeCoder\RangeCoder.cs&quot;&gt;
+      &lt;Link&gt;RangeCoder\RangeCoder.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\RangeCoder\RangeCoderBit.cs&quot;&gt;
+      &lt;Link&gt;RangeCoder\RangeCoderBit.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;..\RangeCoder\RangeCoderBitTree.cs&quot;&gt;
+      &lt;Link&gt;RangeCoder\RangeCoderBitTree.cs&lt;/Link&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;LzmaAlone.cs&quot;&gt;
+      &lt;SubType&gt;Code&lt;/SubType&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;LzmaBench.cs&quot;&gt;
+      &lt;SubType&gt;Code&lt;/SubType&gt;
+    &lt;/Compile&gt;
+    &lt;Compile Include=&quot;Properties\AssemblyInfo.cs&quot; /&gt;
+    &lt;Compile Include=&quot;Properties\Settings.cs&quot;&gt;
+      &lt;AutoGen&gt;True&lt;/AutoGen&gt;
+      &lt;DependentUpon&gt;Settings.settings&lt;/DependentUpon&gt;
+    &lt;/Compile&gt;
+    &lt;None Include=&quot;Properties\Settings.settings&quot;&gt;
+      &lt;Generator&gt;SettingsSingleFileGenerator&lt;/Generator&gt;
+      &lt;LastGenOutput&gt;Settings.cs&lt;/LastGenOutput&gt;
+    &lt;/None&gt;
+    &lt;AppDesigner Include=&quot;Properties\&quot; /&gt;
+  &lt;/ItemGroup&gt;
+  &lt;Import Project=&quot;$(MSBuildBinPath)\Microsoft.CSHARP.Targets&quot; /&gt;
+&lt;/Project&gt;
\ No newline at end of file


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.csproj
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.sln
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.sln	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.sln	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,20 @@
+&#65279;
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual C# Express 2005
+Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;LzmaAlone&quot;, &quot;LzmaAlone.csproj&quot;, &quot;{CE33DF18-F9C8-4D6F-9057-DBB4DB96E973}&quot;
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{CE33DF18-F9C8-4D6F-9057-DBB4DB96E973}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{CE33DF18-F9C8-4D6F-9057-DBB4DB96E973}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{CE33DF18-F9C8-4D6F-9057-DBB4DB96E973}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{CE33DF18-F9C8-4D6F-9057-DBB4DB96E973}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaAlone.sln
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaBench.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaBench.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaBench.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,340 @@
+// LzmaBench.cs
+
+using System;
+using System.IO;
+
+namespace SevenZip
+{
+	/// &lt;summary&gt;
+	/// LZMA Benchmark
+	/// &lt;/summary&gt;
+	internal abstract class LzmaBench
+	{
+		const UInt32 kAdditionalSize = (6 &lt;&lt; 20);
+		const UInt32 kCompressedAdditionalSize = (1 &lt;&lt; 10);
+		const UInt32 kMaxLzmaPropSize = 10;
+
+		class CRandomGenerator
+		{
+			UInt32 A1;
+			UInt32 A2;
+			public CRandomGenerator() { Init(); }
+			public void Init() { A1 = 362436069; A2 = 521288629; }
+			public UInt32 GetRnd()
+			{
+				return
+					((A1 = 36969 * (A1 &amp; 0xffff) + (A1 &gt;&gt; 16)) &lt;&lt; 16) ^
+					((A2 = 18000 * (A2 &amp; 0xffff) + (A2 &gt;&gt; 16)));
+			}
+		};
+
+		class CBitRandomGenerator
+		{
+			CRandomGenerator RG = new CRandomGenerator();
+			UInt32 Value;
+			int NumBits;
+			public void Init()
+			{
+				Value = 0;
+				NumBits = 0;
+			}
+			public UInt32 GetRnd(int numBits)
+			{
+				UInt32 result;
+				if (NumBits &gt; numBits)
+				{
+					result = Value &amp; (((UInt32)1 &lt;&lt; numBits) - 1);
+					Value &gt;&gt;= numBits;
+					NumBits -= numBits;
+					return result;
+				}
+				numBits -= NumBits;
+				result = (Value &lt;&lt; numBits);
+				Value = RG.GetRnd();
+				result |= Value &amp; (((UInt32)1 &lt;&lt; numBits) - 1);
+				Value &gt;&gt;= numBits;
+				NumBits = 32 - numBits;
+				return result;
+			}
+		};
+
+		class CBenchRandomGenerator
+		{
+			CBitRandomGenerator RG = new CBitRandomGenerator();
+			UInt32 Pos;
+			UInt32 Rep0;
+			
+			public UInt32 BufferSize;
+			public Byte[] Buffer = null;
+
+			public CBenchRandomGenerator() { }
+
+			public void Set(UInt32 bufferSize)
+			{
+				Buffer = new Byte[bufferSize];
+				Pos = 0;
+				BufferSize = bufferSize;
+			}
+			UInt32 GetRndBit() { return RG.GetRnd(1); }
+			UInt32 GetLogRandBits(int numBits)
+			{
+				UInt32 len = RG.GetRnd(numBits);
+				return RG.GetRnd((int)len);
+			}
+			UInt32 GetOffset()
+			{
+				if (GetRndBit() == 0)
+					return GetLogRandBits(4);
+				return (GetLogRandBits(4) &lt;&lt; 10) | RG.GetRnd(10);
+			}
+			UInt32 GetLen1() { return RG.GetRnd(1 + (int)RG.GetRnd(2)); }
+			UInt32 GetLen2() { return RG.GetRnd(2 + (int)RG.GetRnd(2)); }
+			public void Generate()
+			{
+				RG.Init();
+				Rep0 = 1;
+				while (Pos &lt; BufferSize)
+				{
+					if (GetRndBit() == 0 || Pos &lt; 1)
+						Buffer[Pos++] = (Byte)RG.GetRnd(8);
+					else
+					{
+						UInt32 len;
+						if (RG.GetRnd(3) == 0)
+							len = 1 + GetLen1();
+						else
+						{
+							do
+								Rep0 = GetOffset();
+							while (Rep0 &gt;= Pos);
+							Rep0++;
+							len = 2 + GetLen2();
+						}
+						for (UInt32 i = 0; i &lt; len &amp;&amp; Pos &lt; BufferSize; i++, Pos++)
+							Buffer[Pos] = Buffer[Pos - Rep0];
+					}
+				}
+			}
+		};
+
+		class CrcOutStream : System.IO.Stream
+		{
+			public CRC CRC = new CRC();
+			public void Init() { CRC.Init(); }
+			public UInt32 GetDigest() { return CRC.GetDigest(); }
+
+			public override bool CanRead { get { return false; } }
+			public override bool CanSeek { get { return false; } }
+			public override bool CanWrite { get { return true; } }
+			public override Int64 Length { get { return 0; } }
+			public override Int64 Position { get { return 0; } set { } }
+			public override void Flush() { }
+			public override long Seek(long offset, SeekOrigin origin) { return 0; }
+			public override void SetLength(long value) { }
+			public override int Read(byte[] buffer, int offset, int count) { return 0; }
+
+			public override void WriteByte(byte b)
+			{
+				CRC.UpdateByte(b);
+			}
+			public override void Write(byte[] buffer, int offset, int count)
+			{
+				CRC.Update(buffer, (uint)offset, (uint)count);
+			}
+		};
+
+		class CProgressInfo : ICodeProgress
+		{
+			public Int64 ApprovedStart;
+			public Int64 InSize;
+			public System.DateTime Time;
+			public void Init() { InSize = 0; }
+			public void SetProgress(Int64 inSize, Int64 outSize)
+			{
+				if (inSize &gt;= ApprovedStart &amp;&amp; InSize == 0)
+				{
+					Time = DateTime.UtcNow;
+					InSize = inSize;
+				}
+			}
+		}
+		const int kSubBits = 8;
+
+		static UInt32 GetLogSize(UInt32 size)
+		{
+			for (int i = kSubBits; i &lt; 32; i++)
+				for (UInt32 j = 0; j &lt; (1 &lt;&lt; kSubBits); j++)
+					if (size &lt;= (((UInt32)1) &lt;&lt; i) + (j &lt;&lt; (i - kSubBits)))
+						return (UInt32)(i &lt;&lt; kSubBits) + j;
+			return (32 &lt;&lt; kSubBits);
+		}
+
+		static UInt64 MyMultDiv64(UInt64 value, UInt64 elapsedTime)
+		{
+			UInt64 freq = TimeSpan.TicksPerSecond;
+			UInt64 elTime = elapsedTime;
+			while (freq &gt; 1000000)
+			{
+				freq &gt;&gt;= 1;
+				elTime &gt;&gt;= 1;
+			}
+			if (elTime == 0)
+				elTime = 1;
+			return value * freq / elTime;
+		}
+
+		static UInt64 GetCompressRating(UInt32 dictionarySize, UInt64 elapsedTime, UInt64 size)
+		{
+			UInt64 t = GetLogSize(dictionarySize) - (18 &lt;&lt; kSubBits);
+			UInt64 numCommandsForOne = 1060 + ((t * t * 10) &gt;&gt; (2 * kSubBits));
+			UInt64 numCommands = (UInt64)(size) * numCommandsForOne;
+			return MyMultDiv64(numCommands, elapsedTime);
+		}
+
+		static UInt64 GetDecompressRating(UInt64 elapsedTime, UInt64 outSize, UInt64 inSize)
+		{
+			UInt64 numCommands = inSize * 220 + outSize * 20;
+			return MyMultDiv64(numCommands, elapsedTime);
+		}
+
+		static UInt64 GetTotalRating(
+			UInt32 dictionarySize,
+			UInt64 elapsedTimeEn, UInt64 sizeEn,
+			UInt64 elapsedTimeDe,
+			UInt64 inSizeDe, UInt64 outSizeDe)
+		{
+			return (GetCompressRating(dictionarySize, elapsedTimeEn, sizeEn) +
+				GetDecompressRating(elapsedTimeDe, inSizeDe, outSizeDe)) / 2;
+		}
+
+		static void PrintValue(UInt64 v)
+		{
+			string s = v.ToString();
+			for (int i = 0; i + s.Length &lt; 6; i++)
+				System.Console.Write(&quot; &quot;);
+			System.Console.Write(s);
+		}
+
+		static void PrintRating(UInt64 rating)
+		{
+			PrintValue(rating / 1000000);
+			System.Console.Write(&quot; MIPS&quot;);
+		}
+
+		static void PrintResults(
+			UInt32 dictionarySize,
+			UInt64 elapsedTime,
+			UInt64 size,
+			bool decompressMode, UInt64 secondSize)
+		{
+			UInt64 speed = MyMultDiv64(size, elapsedTime);
+			PrintValue(speed / 1024);
+			System.Console.Write(&quot; KB/s  &quot;);
+			UInt64 rating;
+			if (decompressMode)
+				rating = GetDecompressRating(elapsedTime, size, secondSize);
+			else
+				rating = GetCompressRating(dictionarySize, elapsedTime, size);
+			PrintRating(rating);
+		}
+
+		static public int LzmaBenchmark(Int32 numIterations, UInt32 dictionarySize)
+		{
+			if (numIterations &lt;= 0)
+				return 0;
+			if (dictionarySize &lt; (1 &lt;&lt; 18))
+			{
+				System.Console.WriteLine(&quot;\nError: dictionary size for benchmark must be &gt;= 19 (512 KB)&quot;);
+				return 1;
+			}
+			System.Console.Write(&quot;\n       Compressing                Decompressing\n\n&quot;);
+
+			Compression.LZMA.Encoder encoder = new Compression.LZMA.Encoder();
+			Compression.LZMA.Decoder decoder = new Compression.LZMA.Decoder();
+
+
+			CoderPropID[] propIDs = 
+			{ 
+				CoderPropID.DictionarySize,
+			};
+			object[] properties = 
+			{
+				(Int32)(dictionarySize),
+			};
+
+			UInt32 kBufferSize = dictionarySize + kAdditionalSize;
+			UInt32 kCompressedBufferSize = (kBufferSize / 2) + kCompressedAdditionalSize;
+
+			encoder.SetCoderProperties(propIDs, properties);
+			System.IO.MemoryStream propStream = new System.IO.MemoryStream();
+			encoder.WriteCoderProperties(propStream);
+			byte[] propArray = propStream.ToArray();
+
+			CBenchRandomGenerator rg = new CBenchRandomGenerator();
+
+			rg.Set(kBufferSize);
+			rg.Generate();
+			CRC crc = new CRC();
+			crc.Init();
+			crc.Update(rg.Buffer, 0, rg.BufferSize);
+
+			CProgressInfo progressInfo = new CProgressInfo();
+			progressInfo.ApprovedStart = dictionarySize;
+
+			UInt64 totalBenchSize = 0;
+			UInt64 totalEncodeTime = 0;
+			UInt64 totalDecodeTime = 0;
+			UInt64 totalCompressedSize = 0;
+
+			MemoryStream inStream = new MemoryStream(rg.Buffer, 0, (int)rg.BufferSize);
+			MemoryStream compressedStream = new MemoryStream((int)kCompressedBufferSize);
+			CrcOutStream crcOutStream = new CrcOutStream();
+			for (Int32 i = 0; i &lt; numIterations; i++)
+			{
+				progressInfo.Init();
+				inStream.Seek(0, SeekOrigin.Begin);
+				compressedStream.Seek(0, SeekOrigin.Begin);
+				encoder.Code(inStream, compressedStream, -1, -1, progressInfo);
+				TimeSpan sp2 = DateTime.UtcNow - progressInfo.Time;
+				UInt64 encodeTime = (UInt64)sp2.Ticks;
+
+				long compressedSize = compressedStream.Position;
+				if (progressInfo.InSize == 0)
+					throw (new Exception(&quot;Internal ERROR 1282&quot;));
+
+				UInt64 decodeTime = 0;
+				for (int j = 0; j &lt; 2; j++)
+				{
+					compressedStream.Seek(0, SeekOrigin.Begin);
+					crcOutStream.Init();
+
+					decoder.SetDecoderProperties(propArray);
+					UInt64 outSize = kBufferSize;
+					System.DateTime startTime = DateTime.UtcNow;
+					decoder.Code(compressedStream, crcOutStream, 0, (Int64)outSize, null);
+					TimeSpan sp = (DateTime.UtcNow - startTime);
+					decodeTime = (ulong)sp.Ticks;
+					if (crcOutStream.GetDigest() != crc.GetDigest())
+						throw (new Exception(&quot;CRC Error&quot;));
+				}
+				UInt64 benchSize = kBufferSize - (UInt64)progressInfo.InSize;
+				PrintResults(dictionarySize, encodeTime, benchSize, false, 0);
+				System.Console.Write(&quot;     &quot;);
+				PrintResults(dictionarySize, decodeTime, kBufferSize, true, (ulong)compressedSize);
+				System.Console.WriteLine();
+
+				totalBenchSize += benchSize;
+				totalEncodeTime += encodeTime;
+				totalDecodeTime += decodeTime;
+				totalCompressedSize += (ulong)compressedSize;
+			}
+			System.Console.WriteLine(&quot;---------------------------------------------------&quot;);
+			PrintResults(dictionarySize, totalEncodeTime, totalBenchSize, false, 0);
+			System.Console.Write(&quot;     &quot;);
+			PrintResults(dictionarySize, totalDecodeTime,
+					kBufferSize * (UInt64)numIterations, true, totalCompressedSize);
+			System.Console.WriteLine(&quot;    Average&quot;);
+			return 0;
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/LzmaBench.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/AssemblyInfo.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/AssemblyInfo.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/AssemblyInfo.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,29 @@
+&#65279;#region Using directives
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+#endregion
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle(&quot;LZMA#&quot;)]
+[assembly: AssemblyDescription(&quot;&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;Igor Pavlov&quot;)]
+[assembly: AssemblyProduct(&quot;LZMA# SDK&quot;)]
+[assembly: AssemblyCopyright(&quot;Copyright @ Igor Pavlov 1999-2004&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Revision and Build Numbers 
+// by using the '*' as shown below:
+[assembly: AssemblyVersion(&quot;4.12.*&quot;)]


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/AssemblyInfo.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Resources.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Resources.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Resources.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,70 @@
+&#65279;//------------------------------------------------------------------------------
+// &lt;autogenerated&gt;
+//     This code was generated by a tool.
+//     Runtime Version:2.0.40607.42
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// &lt;/autogenerated&gt;
+//------------------------------------------------------------------------------
+
+namespace LzmaAlone.Properties
+{
+	using System;
+	using System.IO;
+	using System.Resources;
+
+	/// &lt;summary&gt;
+	///    A strongly-typed resource class, for looking up localized strings, etc.
+	/// &lt;/summary&gt;
+	// This class was auto-generated by the Strongly Typed Resource Builder
+	// class via a tool like ResGen or Visual Studio.NET.
+	// To add or remove a member, edit your .ResX file then rerun ResGen
+	// with the /str option, or rebuild your VS project.
+	class Resources
+	{
+
+		private static System.Resources.ResourceManager _resMgr;
+
+		private static System.Globalization.CultureInfo _resCulture;
+
+		/*FamANDAssem*/
+		internal Resources()
+		{
+		}
+
+		/// &lt;summary&gt;
+		///    Returns the cached ResourceManager instance used by this class.
+		/// &lt;/summary&gt;
+		[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
+		public static System.Resources.ResourceManager ResourceManager
+		{
+			get
+			{
+				if ((_resMgr == null))
+				{
+					System.Resources.ResourceManager temp = new System.Resources.ResourceManager(&quot;Resources&quot;, typeof(Resources).Assembly);
+					_resMgr = temp;
+				}
+				return _resMgr;
+			}
+		}
+
+		/// &lt;summary&gt;
+		///    Overrides the current thread's CurrentUICulture property for all
+		///    resource lookups using this strongly typed resource class.
+		/// &lt;/summary&gt;
+		[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
+		public static System.Globalization.CultureInfo Culture
+		{
+			get
+			{
+				return _resCulture;
+			}
+			set
+			{
+				_resCulture = value;
+			}
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Resources.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Settings.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Settings.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Settings.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,42 @@
+&#65279;//------------------------------------------------------------------------------
+// &lt;autogenerated&gt;
+//     This code was generated by a tool.
+//     Runtime Version:2.0.40607.42
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// &lt;/autogenerated&gt;
+//------------------------------------------------------------------------------
+
+namespace LzmaAlone.Properties
+{
+	public partial class Settings : System.Configuration.ApplicationSettingsBase
+	{
+		private static Settings m_Value;
+
+		private static object m_SyncObject = new object();
+
+		public static Settings Value
+		{
+			get
+			{
+				if ((Settings.m_Value == null))
+				{
+					System.Threading.Monitor.Enter(Settings.m_SyncObject);
+					if ((Settings.m_Value == null))
+					{
+						try
+						{
+							Settings.m_Value = new Settings();
+						}
+						finally
+						{
+							System.Threading.Monitor.Exit(Settings.m_SyncObject);
+						}
+					}
+				}
+				return Settings.m_Value;
+			}
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/LzmaAlone/Properties/Settings.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoder.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoder.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoder.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,234 @@
+using System;
+
+namespace SevenZip.Compression.RangeCoder
+{
+	class Encoder
+	{
+		public const uint kTopValue = (1 &lt;&lt; 24);
+
+		System.IO.Stream Stream;
+
+		public UInt64 Low;
+		public uint Range;
+		uint _cacheSize;
+		byte _cache;
+
+		long StartPosition;
+
+		public void SetStream(System.IO.Stream stream)
+		{
+			Stream = stream;
+		}
+
+		public void ReleaseStream()
+		{
+			Stream = null;
+		}
+
+		public void Init()
+		{
+			StartPosition = Stream.Position;
+
+			Low = 0;
+			Range = 0xFFFFFFFF;
+			_cacheSize = 1;
+			_cache = 0;
+		}
+
+		public void FlushData()
+		{
+			for (int i = 0; i &lt; 5; i++)
+				ShiftLow();
+		}
+
+		public void FlushStream()
+		{
+			Stream.Flush();
+		}
+
+		public void CloseStream()
+		{
+			Stream.Close();
+		}
+
+		public void Encode(uint start, uint size, uint total)
+		{
+			Low += start * (Range /= total);
+			Range *= size;
+			while (Range &lt; kTopValue)
+			{
+				Range &lt;&lt;= 8;
+				ShiftLow();
+			}
+		}
+
+		public void ShiftLow()
+		{
+			if ((uint)Low &lt; (uint)0xFF000000 || (uint)(Low &gt;&gt; 32) == 1)
+			{
+				byte temp = _cache;
+				do
+				{
+					Stream.WriteByte((byte)(temp + (Low &gt;&gt; 32)));
+					temp = 0xFF;
+				}
+				while (--_cacheSize != 0);
+				_cache = (byte)(((uint)Low) &gt;&gt; 24);
+			}
+			_cacheSize++;
+			Low = ((uint)Low) &lt;&lt; 8;
+		}
+
+		public void EncodeDirectBits(uint v, int numTotalBits)
+		{
+			for (int i = numTotalBits - 1; i &gt;= 0; i--)
+			{
+				Range &gt;&gt;= 1;
+				if (((v &gt;&gt; i) &amp; 1) == 1)
+					Low += Range;
+				if (Range &lt; kTopValue)
+				{
+					Range &lt;&lt;= 8;
+					ShiftLow();
+				}
+			}
+		}
+
+		public void EncodeBit(uint size0, int numTotalBits, uint symbol)
+		{
+			uint newBound = (Range &gt;&gt; numTotalBits) * size0;
+			if (symbol == 0)
+				Range = newBound;
+			else
+			{
+				Low += newBound;
+				Range -= newBound;
+			}
+			while (Range &lt; kTopValue)
+			{
+				Range &lt;&lt;= 8;
+				ShiftLow();
+			}
+		}
+
+		public long GetProcessedSizeAdd()
+		{
+			return _cacheSize +
+				Stream.Position - StartPosition + 4;
+			// (long)Stream.GetProcessedSize();
+		}
+	}
+
+	class Decoder
+	{
+		public const uint kTopValue = (1 &lt;&lt; 24);
+		public uint Range;
+		public uint Code;
+		// public Buffer.InBuffer Stream = new Buffer.InBuffer(1 &lt;&lt; 16);
+		public System.IO.Stream Stream;
+
+		public void Init(System.IO.Stream stream)
+		{
+			// Stream.Init(stream);
+			Stream = stream;
+
+			Code = 0;
+			Range = 0xFFFFFFFF;
+			for (int i = 0; i &lt; 5; i++)
+				Code = (Code &lt;&lt; 8) | (byte)Stream.ReadByte();
+		}
+
+		public void ReleaseStream()
+		{
+			// Stream.ReleaseStream();
+			Stream = null;
+		}
+
+		public void CloseStream()
+		{
+			Stream.Close();
+		}
+
+		public void Normalize()
+		{
+			while (Range &lt; kTopValue)
+			{
+				Code = (Code &lt;&lt; 8) | (byte)Stream.ReadByte();
+				Range &lt;&lt;= 8;
+			}
+		}
+
+		public void Normalize2()
+		{
+			if (Range &lt; kTopValue)
+			{
+				Code = (Code &lt;&lt; 8) | (byte)Stream.ReadByte();
+				Range &lt;&lt;= 8;
+			}
+		}
+
+		public uint GetThreshold(uint total)
+		{
+			return Code / (Range /= total);
+		}
+
+		public void Decode(uint start, uint size, uint total)
+		{
+			Code -= start * Range;
+			Range *= size;
+			Normalize();
+		}
+
+		public uint DecodeDirectBits(int numTotalBits)
+		{
+			uint range = Range;
+			uint code = Code;
+			uint result = 0;
+			for (int i = numTotalBits; i &gt; 0; i--)
+			{
+				range &gt;&gt;= 1;
+				/*
+				result &lt;&lt;= 1;
+				if (code &gt;= range)
+				{
+					code -= range;
+					result |= 1;
+				}
+				*/
+				uint t = (code - range) &gt;&gt; 31;
+				code -= range &amp; (t - 1);
+				result = (result &lt;&lt; 1) | (1 - t);
+
+				if (range &lt; kTopValue)
+				{
+					code = (code &lt;&lt; 8) | (byte)Stream.ReadByte();
+					range &lt;&lt;= 8;
+				}
+			}
+			Range = range;
+			Code = code;
+			return result;
+		}
+
+		public uint DecodeBit(uint size0, int numTotalBits)
+		{
+			uint newBound = (Range &gt;&gt; numTotalBits) * size0;
+			uint symbol;
+			if (Code &lt; newBound)
+			{
+				symbol = 0;
+				Range = newBound;
+			}
+			else
+			{
+				symbol = 1;
+				Code -= newBound;
+				Range -= newBound;
+			}
+			Normalize();
+			return symbol;
+		}
+
+		// ulong GetProcessedSize() {return Stream.GetProcessedSize(); }
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoder.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBit.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBit.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBit.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,117 @@
+using System;
+
+namespace SevenZip.Compression.RangeCoder
+{
+	struct BitEncoder
+	{
+		public const int kNumBitModelTotalBits = 11;
+		public const uint kBitModelTotal = (1 &lt;&lt; kNumBitModelTotalBits);
+		const int kNumMoveBits = 5;
+		const int kNumMoveReducingBits = 2;
+		public const int kNumBitPriceShiftBits = 6;
+
+		uint Prob;
+
+		public void Init() { Prob = kBitModelTotal &gt;&gt; 1; }
+
+		public void UpdateModel(uint symbol)
+		{
+			if (symbol == 0)
+				Prob += (kBitModelTotal - Prob) &gt;&gt; kNumMoveBits;
+			else
+				Prob -= (Prob) &gt;&gt; kNumMoveBits;
+		}
+
+		public void Encode(Encoder encoder, uint symbol)
+		{
+			// encoder.EncodeBit(Prob, kNumBitModelTotalBits, symbol);
+			// UpdateModel(symbol);
+			uint newBound = (encoder.Range &gt;&gt; kNumBitModelTotalBits) * Prob;
+			if (symbol == 0)
+			{
+				encoder.Range = newBound;
+				Prob += (kBitModelTotal - Prob) &gt;&gt; kNumMoveBits;
+			}
+			else
+			{
+				encoder.Low += newBound;
+				encoder.Range -= newBound;
+				Prob -= (Prob) &gt;&gt; kNumMoveBits;
+			}
+			if (encoder.Range &lt; Encoder.kTopValue)
+			{
+				encoder.Range &lt;&lt;= 8;
+				encoder.ShiftLow();
+			}
+		}
+
+		private static UInt32[] ProbPrices = new UInt32[kBitModelTotal &gt;&gt; kNumMoveReducingBits];
+
+		static BitEncoder()
+		{
+			const int kNumBits = (kNumBitModelTotalBits - kNumMoveReducingBits);
+			for (int i = kNumBits - 1; i &gt;= 0; i--)
+			{
+				UInt32 start = (UInt32)1 &lt;&lt; (kNumBits - i - 1);
+				UInt32 end = (UInt32)1 &lt;&lt; (kNumBits - i);
+				for (UInt32 j = start; j &lt; end; j++)
+					ProbPrices[j] = ((UInt32)i &lt;&lt; kNumBitPriceShiftBits) +
+						(((end - j) &lt;&lt; kNumBitPriceShiftBits) &gt;&gt; (kNumBits - i - 1));
+			}
+		}
+
+		public uint GetPrice(uint symbol)
+		{
+			return ProbPrices[(((Prob - symbol) ^ ((-(int)symbol))) &amp; (kBitModelTotal - 1)) &gt;&gt; kNumMoveReducingBits];
+		}
+	  public uint GetPrice0() { return ProbPrices[Prob &gt;&gt; kNumMoveReducingBits]; }
+		public uint GetPrice1() { return ProbPrices[(kBitModelTotal - Prob) &gt;&gt; kNumMoveReducingBits]; }
+	}
+
+	struct BitDecoder
+	{
+		public const int kNumBitModelTotalBits = 11;
+		public const uint kBitModelTotal = (1 &lt;&lt; kNumBitModelTotalBits);
+		const int kNumMoveBits = 5;
+
+		uint Prob;
+
+		public void UpdateModel(int numMoveBits, uint symbol)
+		{
+			if (symbol == 0)
+				Prob += (kBitModelTotal - Prob) &gt;&gt; numMoveBits;
+			else
+				Prob -= (Prob) &gt;&gt; numMoveBits;
+		}
+
+		public void Init() { Prob = kBitModelTotal &gt;&gt; 1; }
+
+		public uint Decode(RangeCoder.Decoder rangeDecoder)
+		{
+			uint newBound = (uint)(rangeDecoder.Range &gt;&gt; kNumBitModelTotalBits) * (uint)Prob;
+			if (rangeDecoder.Code &lt; newBound)
+			{
+				rangeDecoder.Range = newBound;
+				Prob += (kBitModelTotal - Prob) &gt;&gt; kNumMoveBits;
+				if (rangeDecoder.Range &lt; Decoder.kTopValue)
+				{
+					rangeDecoder.Code = (rangeDecoder.Code &lt;&lt; 8) | (byte)rangeDecoder.Stream.ReadByte();
+					rangeDecoder.Range &lt;&lt;= 8;
+				}
+				return 0;
+			}
+			else
+			{
+				rangeDecoder.Range -= newBound;
+				rangeDecoder.Code -= newBound;
+				Prob -= (Prob) &gt;&gt; kNumMoveBits;
+				if (rangeDecoder.Range &lt; Decoder.kTopValue)
+				{
+					rangeDecoder.Code = (rangeDecoder.Code &lt;&lt; 8) | (byte)rangeDecoder.Stream.ReadByte();
+					rangeDecoder.Range &lt;&lt;= 8;
+				}
+				return 1;
+			}
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBit.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBitTree.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBitTree.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBitTree.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,157 @@
+using System;
+
+namespace SevenZip.Compression.RangeCoder
+{
+	struct BitTreeEncoder
+	{
+		BitEncoder[] Models;
+		int NumBitLevels;
+
+		public BitTreeEncoder(int numBitLevels)
+		{
+			NumBitLevels = numBitLevels;
+			Models = new BitEncoder[1 &lt;&lt; numBitLevels];
+		}
+
+		public void Init()
+		{
+			for (uint i = 1; i &lt; (1 &lt;&lt; NumBitLevels); i++)
+				Models[i].Init();
+		}
+
+		public void Encode(Encoder rangeEncoder, UInt32 symbol)
+		{
+			UInt32 m = 1;
+			for (int bitIndex = NumBitLevels; bitIndex &gt; 0; )
+			{
+				bitIndex--;
+				UInt32 bit = (symbol &gt;&gt; bitIndex) &amp; 1;
+				Models[m].Encode(rangeEncoder, bit);
+				m = (m &lt;&lt; 1) | bit;
+			}
+		}
+
+		public void ReverseEncode(Encoder rangeEncoder, UInt32 symbol)
+		{
+			UInt32 m = 1;
+			for (UInt32 i = 0; i &lt; NumBitLevels; i++)
+			{
+				UInt32 bit = symbol &amp; 1;
+				Models[m].Encode(rangeEncoder, bit);
+				m = (m &lt;&lt; 1) | bit;
+				symbol &gt;&gt;= 1;
+			}
+		}
+
+		public UInt32 GetPrice(UInt32 symbol)
+		{
+			UInt32 price = 0;
+			UInt32 m = 1;
+			for (int bitIndex = NumBitLevels; bitIndex &gt; 0; )
+			{
+				bitIndex--;
+				UInt32 bit = (symbol &gt;&gt; bitIndex) &amp; 1;
+				price += Models[m].GetPrice(bit);
+				m = (m &lt;&lt; 1) + bit;
+			}
+			return price;
+		}
+
+		public UInt32 ReverseGetPrice(UInt32 symbol)
+		{
+			UInt32 price = 0;
+			UInt32 m = 1;
+			for (int i = NumBitLevels; i &gt; 0; i--)
+			{
+				UInt32 bit = symbol &amp; 1;
+				symbol &gt;&gt;= 1;
+				price += Models[m].GetPrice(bit);
+				m = (m &lt;&lt; 1) | bit;
+			}
+			return price;
+		}
+
+		public static UInt32 ReverseGetPrice(BitEncoder[] Models, UInt32 startIndex,
+			int NumBitLevels, UInt32 symbol)
+		{
+			UInt32 price = 0;
+			UInt32 m = 1;
+			for (int i = NumBitLevels; i &gt; 0; i--)
+			{
+				UInt32 bit = symbol &amp; 1;
+				symbol &gt;&gt;= 1;
+				price += Models[startIndex + m].GetPrice(bit);
+				m = (m &lt;&lt; 1) | bit;
+			}
+			return price;
+		}
+
+		public static void ReverseEncode(BitEncoder[] Models, UInt32 startIndex,
+			Encoder rangeEncoder, int NumBitLevels, UInt32 symbol)
+		{
+			UInt32 m = 1;
+			for (int i = 0; i &lt; NumBitLevels; i++)
+			{
+				UInt32 bit = symbol &amp; 1;
+				Models[startIndex + m].Encode(rangeEncoder, bit);
+				m = (m &lt;&lt; 1) | bit;
+				symbol &gt;&gt;= 1;
+			}
+		}
+	}
+
+	struct BitTreeDecoder
+	{
+		BitDecoder[] Models;
+		int NumBitLevels;
+
+		public BitTreeDecoder(int numBitLevels)
+		{
+			NumBitLevels = numBitLevels;
+			Models = new BitDecoder[1 &lt;&lt; numBitLevels];
+		}
+
+		public void Init()
+		{
+			for (uint i = 1; i &lt; (1 &lt;&lt; NumBitLevels); i++)
+				Models[i].Init();
+		}
+
+		public uint Decode(RangeCoder.Decoder rangeDecoder)
+		{
+			uint m = 1;
+			for (int bitIndex = NumBitLevels; bitIndex &gt; 0; bitIndex--)
+				m = (m &lt;&lt; 1) + Models[m].Decode(rangeDecoder);
+			return m - ((uint)1 &lt;&lt; NumBitLevels);
+		}
+
+		public uint ReverseDecode(RangeCoder.Decoder rangeDecoder)
+		{
+			uint m = 1;
+			uint symbol = 0;
+			for (int bitIndex = 0; bitIndex &lt; NumBitLevels; bitIndex++)
+			{
+				uint bit = Models[m].Decode(rangeDecoder);
+				m &lt;&lt;= 1;
+				m += bit;
+				symbol |= (bit &lt;&lt; bitIndex);
+			}
+			return symbol;
+		}
+
+		public static uint ReverseDecode(BitDecoder[] Models, UInt32 startIndex,
+			RangeCoder.Decoder rangeDecoder, int NumBitLevels)
+		{
+			uint m = 1;
+			uint symbol = 0;
+			for (int bitIndex = 0; bitIndex &lt; NumBitLevels; bitIndex++)
+			{
+				uint bit = Models[startIndex + m].Decode(rangeDecoder);
+				m &lt;&lt;= 1;
+				m += bit;
+				symbol |= (bit &lt;&lt; bitIndex);
+			}
+			return symbol;
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/Compress/RangeCoder/RangeCoderBitTree.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/ICoder.cs
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/ICoder.cs	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/ICoder.cs	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,145 @@
+// ICoder.h
+
+using System;
+
+namespace SevenZip
+{
+	/// &lt;summary&gt;
+	/// The exception that is thrown when an error in input stream occurs during decoding.
+	/// &lt;/summary&gt;
+	class DataErrorException : ApplicationException
+	{
+		public DataErrorException(): base(&quot;Data Error&quot;) { }
+	}
+
+	/// &lt;summary&gt;
+	/// The exception that is thrown when the value of an argument is outside the allowable range.
+	/// &lt;/summary&gt;
+	class InvalidParamException : ApplicationException
+	{
+		public InvalidParamException(): base(&quot;Invalid Parameter&quot;) { }
+	}
+
+	public interface ICodeProgress
+	{
+		/// &lt;summary&gt;
+		/// Callback progress.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;inSize&quot;&gt;
+		/// input size. -1 if unknown.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;outSize&quot;&gt;
+		/// output size. -1 if unknown.
+		/// &lt;/param&gt;
+		void SetProgress(Int64 inSize, Int64 outSize);
+	};
+
+	public interface ICoder
+	{
+		/// &lt;summary&gt;
+		/// Codes streams.
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;inStream&quot;&gt;
+		/// input Stream.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;outStream&quot;&gt;
+		/// output Stream.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;inSize&quot;&gt;
+		/// input Size. -1 if unknown.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;outSize&quot;&gt;
+		/// output Size. -1 if unknown.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;progress&quot;&gt;
+		/// callback progress reference.
+		/// &lt;/param&gt;
+		/// &lt;exception cref=&quot;SevenZip.DataErrorException&quot;&gt;
+		/// if input stream is not valid
+		/// &lt;/exception&gt;
+		void Code(System.IO.Stream inStream, System.IO.Stream outStream,
+			Int64 inSize, Int64 outSize, ICodeProgress progress);
+	};
+
+	/*
+	public interface ICoder2
+	{
+		 void Code(ISequentialInStream []inStreams,
+				const UInt64 []inSizes, 
+				ISequentialOutStream []outStreams, 
+				UInt64 []outSizes,
+				ICodeProgress progress);
+	};
+  */
+
+	/// &lt;summary&gt;
+	/// Provides the fields that represent properties idenitifiers for compressing.
+	/// &lt;/summary&gt;
+	public enum CoderPropID
+	{
+		/// &lt;summary&gt;
+		/// Specifies size of dictionary.
+		/// &lt;/summary&gt;
+		DictionarySize = 0x400,
+		/// &lt;summary&gt;
+		/// Specifies size of memory for PPM*.
+		/// &lt;/summary&gt;
+		UsedMemorySize,
+		/// &lt;summary&gt;
+		/// Specifies order for PPM methods.
+		/// &lt;/summary&gt;
+		Order,
+		/// &lt;summary&gt;
+		/// Specifies number of postion state bits for LZMA (0 &lt;= x &lt;= 4).
+		/// &lt;/summary&gt;
+		PosStateBits = 0x440,
+		/// &lt;summary&gt;
+		/// Specifies number of literal context bits for LZMA (0 &lt;= x &lt;= 8).
+		/// &lt;/summary&gt;
+		LitContextBits,
+		/// &lt;summary&gt;
+		/// Specifies number of literal position bits for LZMA (0 &lt;= x &lt;= 4).
+		/// &lt;/summary&gt;
+		LitPosBits,
+		/// &lt;summary&gt;
+		/// Specifies number of fast bytes for LZ*.
+		/// &lt;/summary&gt;
+		NumFastBytes = 0x450,
+		/// &lt;summary&gt;
+		/// Specifies match finder. LZMA: &quot;BT2&quot;, &quot;BT4&quot; or &quot;BT4B&quot;.
+		/// &lt;/summary&gt;
+		MatchFinder,
+		/// &lt;summary&gt;
+		/// Specifies number of passes.
+		/// &lt;/summary&gt;
+		NumPasses = 0x460,
+		/// &lt;summary&gt;
+		/// Specifies number of algorithm.
+		/// &lt;/summary&gt;
+		Algorithm = 0x470,
+		/// &lt;summary&gt;
+		/// Specifies multithread mode.
+		/// &lt;/summary&gt;
+		MultiThread = 0x480,
+		/// &lt;summary&gt;
+		/// Specifies mode with end marker.
+		/// &lt;/summary&gt;
+		EndMarker = 0x490
+	};
+
+
+	public interface ISetCoderProperties
+	{
+		void SetCoderProperties(CoderPropID[] propIDs, object[] properties);
+	};
+
+	public interface IWriteCoderProperties
+	{
+		void WriteCoderProperties(System.IO.Stream outStream);
+	}
+
+	public interface ISetDecoderProperties
+	{
+		void SetDecoderProperties(byte[] properties);
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/CS/7zip/ICoder.cs
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/CRC.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/CRC.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/CRC.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,52 @@
+// SevenZip/CRC.java
+
+package SevenZip;
+
+public class CRC
+{
+	static public int[] Table = new int[256];
+	
+	static
+	{
+		for (int i = 0; i &lt; 256; i++)
+		{
+			int r = i;
+			for (int j = 0; j &lt; 8; j++)
+				if ((r &amp; 1) != 0)
+					r = (r &gt;&gt;&gt; 1) ^ 0xEDB88320;
+				else
+					r &gt;&gt;&gt;= 1;
+			Table[i] = r;
+		}
+	}
+	
+	int _value = -1;
+	
+	public void Init()
+	{
+		_value = -1;
+	}
+	
+	public void Update(byte[] data, int offset, int size)
+	{
+		for (int i = 0; i &lt; size; i++)
+			_value = Table[(_value ^ data[offset + i]) &amp; 0xFF] ^ (_value &gt;&gt;&gt; 8);
+	}
+	
+	public void Update(byte[] data)
+	{
+		int size = data.length;
+		for (int i = 0; i &lt; size; i++)
+			_value = Table[(_value ^ data[i]) &amp; 0xFF] ^ (_value &gt;&gt;&gt; 8);
+	}
+	
+	public void UpdateByte(int b)
+	{
+		_value = Table[(_value ^ b) &amp; 0xFF] ^ (_value &gt;&gt;&gt; 8);
+	}
+	
+	public int GetDigest()
+	{
+		return _value ^ (-1);
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/CRC.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/ICodeProgress.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/ICodeProgress.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/ICodeProgress.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,6 @@
+package SevenZip;
+
+public interface ICodeProgress
+{
+	public void SetProgress(long inSize, long outSize);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/ICodeProgress.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/BinTree.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/BinTree.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/BinTree.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,382 @@
+// LZ.BinTree
+
+package SevenZip.Compression.LZ;
+import java.io.IOException;
+
+
+public class BinTree extends InWindow
+{
+	int _cyclicBufferPos;
+	int _cyclicBufferSize = 0;
+	int _matchMaxLen;
+	
+	int[] _son;
+	int[] _hash;
+	
+	int _cutValue = 0xFF;
+	int _hashMask;
+	int _hashSizeSum = 0;
+	
+	boolean HASH_ARRAY = true;
+
+	static final int kHash2Size = 1 &lt;&lt; 10;
+	static final int kHash3Size = 1 &lt;&lt; 16;
+	static final int kBT2HashSize = 1 &lt;&lt; 16;
+	static final int kStartMaxLen = 1;
+	static final int kHash3Offset = kHash2Size;
+	static final int kEmptyHashValue = 0;
+	static final int kMaxValForNormalize = (1 &lt;&lt; 30) - 1;
+	
+	int kNumHashDirectBytes = 0;
+	int kMinMatchCheck = 4;
+	int kFixHashSize = kHash2Size + kHash3Size;
+
+	public void SetType(int numHashBytes)
+	{
+		HASH_ARRAY = (numHashBytes &gt; 2);
+		if (HASH_ARRAY)
+		{
+			kNumHashDirectBytes = 0;
+			kMinMatchCheck = 4;
+			kFixHashSize = kHash2Size + kHash3Size;
+		}
+		else
+		{
+			kNumHashDirectBytes = 2;
+			kMinMatchCheck = 2 + 1;
+			kFixHashSize = 0;
+		}
+	}
+	
+
+	
+
+	public void Init() throws IOException
+	{
+		super.Init();
+		for (int i = 0; i &lt; _hashSizeSum; i++)
+			_hash[i] = kEmptyHashValue;
+		_cyclicBufferPos = 0;
+		ReduceOffsets(-1);
+	}
+	
+	public void MovePos() throws IOException
+	{
+		if (++_cyclicBufferPos &gt;= _cyclicBufferSize)
+			_cyclicBufferPos = 0;
+		super.MovePos();
+		if (_pos == kMaxValForNormalize)
+			Normalize();
+	}
+	
+
+	
+	
+	
+	
+	
+	
+	public boolean Create(int historySize, int keepAddBufferBefore,
+			int matchMaxLen, int keepAddBufferAfter)
+	{
+		if (historySize &gt; kMaxValForNormalize - 256)
+			return false;
+		_cutValue = 16 + (matchMaxLen &gt;&gt; 1);
+
+		int windowReservSize = (historySize + keepAddBufferBefore +
+				matchMaxLen + keepAddBufferAfter) / 2 + 256;
+		
+		super.Create(historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, windowReservSize);
+		
+		_matchMaxLen = matchMaxLen;
+
+		int cyclicBufferSize = historySize + 1;
+		if (_cyclicBufferSize != cyclicBufferSize)
+			_son = new int[(_cyclicBufferSize = cyclicBufferSize) * 2];
+
+		int hs = kBT2HashSize;
+
+		if (HASH_ARRAY)
+		{
+			hs = historySize - 1;
+			hs |= (hs &gt;&gt; 1);
+			hs |= (hs &gt;&gt; 2);
+			hs |= (hs &gt;&gt; 4);
+			hs |= (hs &gt;&gt; 8);
+			hs &gt;&gt;= 1;
+			hs |= 0xFFFF;
+			if (hs &gt; (1 &lt;&lt; 24))
+				hs &gt;&gt;= 1;
+			_hashMask = hs;
+			hs++;
+			hs += kFixHashSize;
+		}
+		if (hs != _hashSizeSum)
+			_hash = new int [_hashSizeSum = hs];
+		return true;
+	}
+	public int GetMatches(int[] distances) throws IOException
+	{
+		int lenLimit;
+		if (_pos + _matchMaxLen &lt;= _streamPos)
+			lenLimit = _matchMaxLen;
+		else
+		{
+			lenLimit = _streamPos - _pos;
+			if (lenLimit &lt; kMinMatchCheck)
+			{
+				MovePos();
+				return 0;
+			}
+		}
+
+		int offset = 0;
+		int matchMinPos = (_pos &gt; _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
+		int cur = _bufferOffset + _pos;
+		int maxLen = kStartMaxLen; // to avoid items for len &lt; hashSize;
+		int hashValue, hash2Value = 0, hash3Value = 0;
+		
+		if (HASH_ARRAY)
+		{
+			int temp = CrcTable[_bufferBase[cur] &amp; 0xFF] ^ (_bufferBase[cur + 1] &amp; 0xFF);
+			hash2Value = temp &amp; (kHash2Size - 1);
+			temp ^= ((int)(_bufferBase[cur + 2] &amp; 0xFF) &lt;&lt; 8);
+			hash3Value = temp &amp; (kHash3Size - 1);
+			hashValue = (temp ^ (CrcTable[_bufferBase[cur + 3] &amp; 0xFF] &lt;&lt; 5)) &amp; _hashMask;
+		}
+		else
+			hashValue = ((_bufferBase[cur] &amp; 0xFF) ^ ((int)(_bufferBase[cur + 1] &amp; 0xFF) &lt;&lt; 8));
+
+		int curMatch = _hash[kFixHashSize + hashValue];
+		if (HASH_ARRAY)
+		{
+			int curMatch2 = _hash[hash2Value];
+			int curMatch3 = _hash[kHash3Offset + hash3Value];
+			_hash[hash2Value] = _pos;
+			_hash[kHash3Offset + hash3Value] = _pos;
+			if (curMatch2 &gt; matchMinPos)
+				if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])
+				{
+					distances[offset++] = maxLen = 2;
+					distances[offset++] = _pos - curMatch2 - 1;
+				}
+			if (curMatch3 &gt; matchMinPos)
+				if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])
+				{
+					if (curMatch3 == curMatch2)
+						offset -= 2;
+					distances[offset++] = maxLen = 3;
+					distances[offset++] = _pos - curMatch3 - 1;
+					curMatch2 = curMatch3;
+				}
+			if (offset != 0 &amp;&amp; curMatch2 == curMatch)
+			{
+				offset -= 2;
+				maxLen = kStartMaxLen;
+			}
+		}
+
+		_hash[kFixHashSize + hashValue] = _pos;
+
+		int ptr0 = (_cyclicBufferPos &lt;&lt; 1) + 1;
+		int ptr1 = (_cyclicBufferPos &lt;&lt; 1);
+
+		int len0, len1;
+		len0 = len1 = kNumHashDirectBytes;
+
+		if (kNumHashDirectBytes != 0)
+		{
+			if (curMatch &gt; matchMinPos)
+			{
+				if (_bufferBase[_bufferOffset + curMatch + kNumHashDirectBytes] !=
+						_bufferBase[cur + kNumHashDirectBytes])
+				{
+					distances[offset++] = maxLen = kNumHashDirectBytes;
+					distances[offset++] = _pos - curMatch - 1;
+				}
+			}
+		}
+
+		int count = _cutValue;
+
+		while (true)
+		{
+			if (curMatch &lt;= matchMinPos || count-- == 0)
+			{
+				_son[ptr0] = _son[ptr1] = kEmptyHashValue;
+				break;
+			}
+			int delta = _pos - curMatch;
+			int cyclicPos = ((delta &lt;= _cyclicBufferPos) ?
+				(_cyclicBufferPos - delta) :
+				(_cyclicBufferPos - delta + _cyclicBufferSize)) &lt;&lt; 1;
+
+			int pby1 = _bufferOffset + curMatch;
+			int len = Math.min(len0, len1);
+			if (_bufferBase[pby1 + len] == _bufferBase[cur + len])
+			{
+				while(++len != lenLimit)
+					if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
+						break;
+				if (maxLen &lt; len)
+				{
+					distances[offset++] = maxLen = len;
+					distances[offset++] = delta - 1;
+					if (len == lenLimit)
+					{
+						_son[ptr1] = _son[cyclicPos];
+						_son[ptr0] = _son[cyclicPos + 1];
+						break;
+					}
+				}
+			}
+			if ((_bufferBase[pby1 + len] &amp; 0xFF) &lt; (_bufferBase[cur + len] &amp; 0xFF))
+			{
+				_son[ptr1] = curMatch;
+				ptr1 = cyclicPos + 1;
+				curMatch = _son[ptr1];
+				len1 = len;
+			}
+			else
+			{
+				_son[ptr0] = curMatch;
+				ptr0 = cyclicPos;
+				curMatch = _son[ptr0];
+				len0 = len;
+			}
+		}
+		MovePos();
+		return offset;
+	}
+
+	public void Skip(int num) throws IOException
+	{
+		do
+		{
+			int lenLimit;
+			if (_pos + _matchMaxLen &lt;= _streamPos)
+			lenLimit = _matchMaxLen;
+			else
+			{
+				lenLimit = _streamPos - _pos;
+				if (lenLimit &lt; kMinMatchCheck)
+				{
+					MovePos();
+					continue;
+				}
+			}
+
+			int matchMinPos = (_pos &gt; _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
+			int cur = _bufferOffset + _pos;
+			
+			int hashValue;
+
+			if (HASH_ARRAY)
+			{
+				int temp = CrcTable[_bufferBase[cur] &amp; 0xFF] ^ (_bufferBase[cur + 1] &amp; 0xFF);
+				int hash2Value = temp &amp; (kHash2Size - 1);
+				_hash[hash2Value] = _pos;
+				temp ^= ((int)(_bufferBase[cur + 2] &amp; 0xFF) &lt;&lt; 8);
+				int hash3Value = temp &amp; (kHash3Size - 1);
+				_hash[kHash3Offset + hash3Value] = _pos;
+				hashValue = (temp ^ (CrcTable[_bufferBase[cur + 3] &amp; 0xFF] &lt;&lt; 5)) &amp; _hashMask;
+			}
+			else
+				hashValue = ((_bufferBase[cur] &amp; 0xFF) ^ ((int)(_bufferBase[cur + 1] &amp; 0xFF) &lt;&lt; 8));
+
+			int curMatch = _hash[kFixHashSize + hashValue];
+			_hash[kFixHashSize + hashValue] = _pos;
+
+			int ptr0 = (_cyclicBufferPos &lt;&lt; 1) + 1;
+			int ptr1 = (_cyclicBufferPos &lt;&lt; 1);
+
+			int len0, len1;
+			len0 = len1 = kNumHashDirectBytes;
+
+			int count = _cutValue;
+			while (true)
+			{
+				if (curMatch &lt;= matchMinPos || count-- == 0)
+				{
+					_son[ptr0] = _son[ptr1] = kEmptyHashValue;
+					break;
+				}
+
+				int delta = _pos - curMatch;
+				int cyclicPos = ((delta &lt;= _cyclicBufferPos) ?
+					(_cyclicBufferPos - delta) :
+					(_cyclicBufferPos - delta + _cyclicBufferSize)) &lt;&lt; 1;
+
+				int pby1 = _bufferOffset + curMatch;
+				int len = Math.min(len0, len1);
+				if (_bufferBase[pby1 + len] == _bufferBase[cur + len])
+				{
+					while (++len != lenLimit)
+						if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
+							break;
+					if (len == lenLimit)
+					{
+						_son[ptr1] = _son[cyclicPos];
+						_son[ptr0] = _son[cyclicPos + 1];
+						break;
+					}
+				}
+				if ((_bufferBase[pby1 + len] &amp; 0xFF) &lt; (_bufferBase[cur + len] &amp; 0xFF))
+				{
+					_son[ptr1] = curMatch;
+					ptr1 = cyclicPos + 1;
+					curMatch = _son[ptr1];
+					len1 = len;
+				}
+				else
+				{
+					_son[ptr0] = curMatch;
+					ptr0 = cyclicPos;
+					curMatch = _son[ptr0];
+					len0 = len;
+				}
+			}
+			MovePos();
+		}
+		while (--num != 0);
+	}
+	
+	void NormalizeLinks(int[] items, int numItems, int subValue)
+	{
+		for (int i = 0; i &lt; numItems; i++)
+		{
+			int value = items[i];
+			if (value &lt;= subValue)
+				value = kEmptyHashValue;
+			else
+				value -= subValue;
+			items[i] = value;
+		}
+	}
+	
+	void Normalize()
+	{
+		int subValue = _pos - _cyclicBufferSize;
+		NormalizeLinks(_son, _cyclicBufferSize * 2, subValue);
+		NormalizeLinks(_hash, _hashSizeSum, subValue);
+		ReduceOffsets(subValue);
+	}
+	
+	public void SetCutValue(int cutValue) { _cutValue = cutValue; }
+
+	private static final int[] CrcTable = new int[256];
+
+	static
+	{
+		for (int i = 0; i &lt; 256; i++)
+		{
+			int r = i;
+			for (int j = 0; j &lt; 8; j++)
+				if ((r &amp; 1) != 0)
+					r = (r &gt;&gt;&gt; 1) ^ 0xEDB88320;
+				else
+					r &gt;&gt;&gt;= 1;
+			CrcTable[i] = r;
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/BinTree.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/InWindow.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/InWindow.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/InWindow.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,131 @@
+// LZ.InWindow
+
+package SevenZip.Compression.LZ;
+
+import java.io.IOException;
+
+public class InWindow
+{
+	public byte[] _bufferBase; // pointer to buffer with data
+	java.io.InputStream _stream;
+	int _posLimit;  // offset (from _buffer) of first byte when new block reading must be done
+	boolean _streamEndWasReached; // if (true) then _streamPos shows real end of stream
+	
+	int _pointerToLastSafePosition;
+	
+	public int _bufferOffset;
+	
+	public int _blockSize;  // Size of Allocated memory block
+	public int _pos;             // offset (from _buffer) of curent byte
+	int _keepSizeBefore;  // how many BYTEs must be kept in buffer before _pos
+	int _keepSizeAfter;   // how many BYTEs must be kept buffer after _pos
+	public int _streamPos;   // offset (from _buffer) of first not read byte from Stream
+	
+	public void MoveBlock()
+	{
+		int offset = _bufferOffset + _pos - _keepSizeBefore;
+		// we need one additional byte, since MovePos moves on 1 byte.
+		if (offset &gt; 0)
+			offset--;
+
+		int numBytes = _bufferOffset + _streamPos - offset;
+		
+		// check negative offset ????
+		for (int i = 0; i &lt; numBytes; i++)
+			_bufferBase[i] = _bufferBase[offset + i];
+		_bufferOffset -= offset;
+	}
+	
+	public void ReadBlock() throws IOException
+	{
+		if (_streamEndWasReached)
+			return;
+		while (true)
+		{
+			int size = (0 - _bufferOffset) + _blockSize - _streamPos;
+			if (size == 0)
+				return;
+			int numReadBytes = _stream.read(_bufferBase, _bufferOffset + _streamPos, size);
+			if (numReadBytes == -1)
+			{
+				_posLimit = _streamPos;
+				int pointerToPostion = _bufferOffset + _posLimit;
+				if (pointerToPostion &gt; _pointerToLastSafePosition)
+					_posLimit = _pointerToLastSafePosition - _bufferOffset;
+				
+				_streamEndWasReached = true;
+				return;
+			}
+			_streamPos += numReadBytes;
+			if (_streamPos &gt;= _pos + _keepSizeAfter)
+				_posLimit = _streamPos - _keepSizeAfter;
+		}
+	}
+	
+	void Free() { _bufferBase = null; }
+	
+	public void Create(int keepSizeBefore, int keepSizeAfter, int keepSizeReserv)
+	{
+		_keepSizeBefore = keepSizeBefore;
+		_keepSizeAfter = keepSizeAfter;
+		int blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
+		if (_bufferBase == null || _blockSize != blockSize)
+		{
+			Free();
+			_blockSize = blockSize;
+			_bufferBase = new byte[_blockSize];
+		}
+		_pointerToLastSafePosition = _blockSize - keepSizeAfter;
+	}
+	
+	public void SetStream(java.io.InputStream stream) { _stream = stream; 	}
+	public void ReleaseStream() { _stream = null; }
+
+	public void Init() throws IOException
+	{
+		_bufferOffset = 0;
+		_pos = 0;
+		_streamPos = 0;
+		_streamEndWasReached = false;
+		ReadBlock();
+	}
+	
+	public void MovePos() throws IOException
+	{
+		_pos++;
+		if (_pos &gt; _posLimit)
+		{
+			int pointerToPostion = _bufferOffset + _pos;
+			if (pointerToPostion &gt; _pointerToLastSafePosition)
+				MoveBlock();
+			ReadBlock();
+		}
+	}
+	
+	public byte GetIndexByte(int index)	{ return _bufferBase[_bufferOffset + _pos + index]; }
+	
+	// index + limit have not to exceed _keepSizeAfter;
+	public int GetMatchLen(int index, int distance, int limit)
+	{
+		if (_streamEndWasReached)
+			if ((_pos + index) + limit &gt; _streamPos)
+				limit = _streamPos - (_pos + index);
+		distance++;
+		// Byte *pby = _buffer + (size_t)_pos + index;
+		int pby = _bufferOffset + _pos + index;
+		
+		int i;
+		for (i = 0; i &lt; limit &amp;&amp; _bufferBase[pby + i] == _bufferBase[pby + i - distance]; i++);
+		return i;
+	}
+	
+	public int GetNumAvailableBytes()	{ return _streamPos - _pos; }
+	
+	public void ReduceOffsets(int subValue)
+	{
+		_bufferOffset += subValue;
+		_posLimit -= subValue;
+		_pos -= subValue;
+		_streamPos -= subValue;
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/InWindow.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/OutWindow.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/OutWindow.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/OutWindow.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,85 @@
+// LZ.OutWindow
+
+package SevenZip.Compression.LZ;
+
+import java.io.IOException;
+
+public class OutWindow
+{
+	byte[] _buffer;
+	int _pos;
+	int _windowSize = 0;
+	int _streamPos;
+	java.io.OutputStream _stream;
+	
+	public void Create(int windowSize)
+	{
+		if (_buffer == null || _windowSize != windowSize)
+			_buffer = new byte[windowSize];
+		_windowSize = windowSize;
+		_pos = 0;
+		_streamPos = 0;
+	}
+	
+	public void SetStream(java.io.OutputStream stream) throws IOException
+	{
+		ReleaseStream();
+		_stream = stream;
+	}
+	
+	public void ReleaseStream() throws IOException
+	{
+		Flush();
+		_stream = null;
+	}
+	
+	public void Init(boolean solid)
+	{
+		if (!solid)
+		{
+			_streamPos = 0;
+			_pos = 0;
+		}
+	}
+	
+	public void Flush() throws IOException
+	{
+		int size = _pos - _streamPos;
+		if (size == 0)
+			return;
+		_stream.write(_buffer, _streamPos, size);
+		if (_pos &gt;= _windowSize)
+			_pos = 0;
+		_streamPos = _pos;
+	}
+	
+	public void CopyBlock(int distance, int len) throws IOException
+	{
+		int pos = _pos - distance - 1;
+		if (pos &lt; 0)
+			pos += _windowSize;
+		for (; len != 0; len--)
+		{
+			if (pos &gt;= _windowSize)
+				pos = 0;
+			_buffer[_pos++] = _buffer[pos++];
+			if (_pos &gt;= _windowSize)
+				Flush();
+		}
+	}
+	
+	public void PutByte(byte b) throws IOException
+	{
+		_buffer[_pos++] = b;
+		if (_pos &gt;= _windowSize)
+			Flush();
+	}
+	
+	public byte GetByte(int distance)
+	{
+		int pos = _pos - distance - 1;
+		if (pos &lt; 0)
+			pos += _windowSize;
+		return _buffer[pos];
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZ/OutWindow.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Base.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Base.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Base.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,88 @@
+// Base.java
+
+package SevenZip.Compression.LZMA;
+
+public class Base
+{
+	public static final int kNumRepDistances = 4;
+	public static final int kNumStates = 12;
+	
+	public static final int StateInit()
+	{
+		return 0;
+	}
+	
+	public static final int StateUpdateChar(int index)
+	{
+		if (index &lt; 4) 
+			return 0;
+		if (index &lt; 10) 
+			return index - 3;
+		return index - 6;
+	}
+	
+	public static final int StateUpdateMatch(int index)
+	{
+		return (index &lt; 7 ? 7 : 10); 
+	}
+
+	public static final int StateUpdateRep(int index)
+	{ 
+		return (index &lt; 7 ? 8 : 11); 
+	}
+	
+	public static final int StateUpdateShortRep(int index)
+	{ 
+		return (index &lt; 7 ? 9 : 11); 
+	}
+
+	public static final boolean StateIsCharState(int index)
+	{ 
+		return index &lt; 7; 
+	}
+	
+	public static final int kNumPosSlotBits = 6;
+	public static final int kDicLogSizeMin = 0;
+	// public static final int kDicLogSizeMax = 28;
+	// public static final int kDistTableSizeMax = kDicLogSizeMax * 2;
+	
+	public static final int kNumLenToPosStatesBits = 2; // it's for speed optimization
+	public static final int kNumLenToPosStates = 1 &lt;&lt; kNumLenToPosStatesBits;
+	
+	public static final int kMatchMinLen = 2;
+	
+	public static final int GetLenToPosState(int len)
+	{
+		len -= kMatchMinLen;
+		if (len &lt; kNumLenToPosStates)
+			return len;
+		return (int)(kNumLenToPosStates - 1);
+	}
+	
+	public static final int kNumAlignBits = 4;
+	public static final int kAlignTableSize = 1 &lt;&lt; kNumAlignBits;
+	public static final int kAlignMask = (kAlignTableSize - 1);
+	
+	public static final int kStartPosModelIndex = 4;
+	public static final int kEndPosModelIndex = 14;
+	public static final int kNumPosModels = kEndPosModelIndex - kStartPosModelIndex;
+	
+	public static final  int kNumFullDistances = 1 &lt;&lt; (kEndPosModelIndex / 2);
+	
+	public static final  int kNumLitPosStatesBitsEncodingMax = 4;
+	public static final  int kNumLitContextBitsMax = 8;
+	
+	public static final  int kNumPosStatesBitsMax = 4;
+	public static final  int kNumPosStatesMax = (1 &lt;&lt; kNumPosStatesBitsMax);
+	public static final  int kNumPosStatesBitsEncodingMax = 4;
+	public static final  int kNumPosStatesEncodingMax = (1 &lt;&lt; kNumPosStatesBitsEncodingMax);
+	
+	public static final  int kNumLowLenBits = 3;
+	public static final  int kNumMidLenBits = 3;
+	public static final  int kNumHighLenBits = 8;
+	public static final  int kNumLowLenSymbols = 1 &lt;&lt; kNumLowLenBits;
+	public static final  int kNumMidLenSymbols = 1 &lt;&lt; kNumMidLenBits;
+	public static final  int kNumLenSymbols = kNumLowLenSymbols + kNumMidLenSymbols +
+			(1 &lt;&lt; kNumHighLenBits);
+	public static final  int kMatchMaxLen = kMatchMinLen + kNumLenSymbols - 1;
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Base.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Decoder.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Decoder.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Decoder.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,329 @@
+package SevenZip.Compression.LZMA;
+
+import SevenZip.Compression.RangeCoder.BitTreeDecoder;
+import SevenZip.Compression.LZMA.Base;
+import SevenZip.Compression.LZ.OutWindow;
+import java.io.IOException;
+
+public class Decoder
+{
+	class LenDecoder
+	{
+		short[] m_Choice = new short[2];
+		BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
+		BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
+		BitTreeDecoder m_HighCoder = new BitTreeDecoder(Base.kNumHighLenBits);
+		int m_NumPosStates = 0;
+		
+		public void Create(int numPosStates)
+		{
+			for (; m_NumPosStates &lt; numPosStates; m_NumPosStates++)
+			{
+				m_LowCoder[m_NumPosStates] = new BitTreeDecoder(Base.kNumLowLenBits);
+				m_MidCoder[m_NumPosStates] = new BitTreeDecoder(Base.kNumMidLenBits);
+			}
+		}
+		
+		public void Init()
+		{
+			SevenZip.Compression.RangeCoder.Decoder.InitBitModels(m_Choice);
+			for (int posState = 0; posState &lt; m_NumPosStates; posState++)
+			{
+				m_LowCoder[posState].Init();
+				m_MidCoder[posState].Init();
+			}
+			m_HighCoder.Init();
+		}
+		
+		public int Decode(SevenZip.Compression.RangeCoder.Decoder rangeDecoder, int posState) throws IOException
+		{
+			if (rangeDecoder.DecodeBit(m_Choice, 0) == 0)
+				return m_LowCoder[posState].Decode(rangeDecoder);
+			int symbol = Base.kNumLowLenSymbols;
+			if (rangeDecoder.DecodeBit(m_Choice, 1) == 0)
+				symbol += m_MidCoder[posState].Decode(rangeDecoder);
+			else
+				symbol += Base.kNumMidLenSymbols + m_HighCoder.Decode(rangeDecoder);
+			return symbol;
+		}
+	}
+	
+	class LiteralDecoder
+	{
+		class Decoder2
+		{
+			short[] m_Decoders = new short[0x300];
+			
+			public void Init()
+			{
+				SevenZip.Compression.RangeCoder.Decoder.InitBitModels(m_Decoders);
+			}
+			
+			public byte DecodeNormal(SevenZip.Compression.RangeCoder.Decoder rangeDecoder) throws IOException
+			{
+				int symbol = 1;
+				do
+					symbol = (symbol &lt;&lt; 1) | rangeDecoder.DecodeBit(m_Decoders, symbol);
+				while (symbol &lt; 0x100);
+				return (byte)symbol;
+			}
+			
+			public byte DecodeWithMatchByte(SevenZip.Compression.RangeCoder.Decoder rangeDecoder, byte matchByte) throws IOException
+			{
+				int symbol = 1;
+				do
+				{
+					int matchBit = (matchByte &gt;&gt; 7) &amp; 1;
+					matchByte &lt;&lt;= 1;
+					int bit = rangeDecoder.DecodeBit(m_Decoders, ((1 + matchBit) &lt;&lt; 8) + symbol);
+					symbol = (symbol &lt;&lt; 1) | bit;
+					if (matchBit != bit)
+					{
+						while (symbol &lt; 0x100)
+							symbol = (symbol &lt;&lt; 1) | rangeDecoder.DecodeBit(m_Decoders, symbol);
+						break;
+					}
+				}
+				while (symbol &lt; 0x100);
+				return (byte)symbol;
+			}
+		}
+		
+		Decoder2[] m_Coders;
+		int m_NumPrevBits;
+		int m_NumPosBits;
+		int m_PosMask;
+		
+		public void Create(int numPosBits, int numPrevBits)
+		{
+			if (m_Coders != null &amp;&amp; m_NumPrevBits == numPrevBits &amp;&amp; m_NumPosBits == numPosBits)
+				return;
+			m_NumPosBits = numPosBits;
+			m_PosMask = (1 &lt;&lt; numPosBits) - 1;
+			m_NumPrevBits = numPrevBits;
+			int numStates = 1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);
+			m_Coders = new Decoder2[numStates];
+			for (int i = 0; i &lt; numStates; i++)
+				m_Coders[i] = new Decoder2();
+		}
+		
+		public void Init()
+		{
+			int numStates = 1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);
+			for (int i = 0; i &lt; numStates; i++)
+				m_Coders[i].Init();
+		}
+		
+		Decoder2 GetDecoder(int pos, byte prevByte)
+		{
+			return m_Coders[((pos &amp; m_PosMask) &lt;&lt; m_NumPrevBits) + ((prevByte &amp; 0xFF) &gt;&gt;&gt; (8 - m_NumPrevBits))];
+		}
+	}
+	
+	OutWindow m_OutWindow = new OutWindow();
+	SevenZip.Compression.RangeCoder.Decoder m_RangeDecoder = new SevenZip.Compression.RangeCoder.Decoder();
+	
+	short[] m_IsMatchDecoders = new short[Base.kNumStates &lt;&lt; Base.kNumPosStatesBitsMax];
+	short[] m_IsRepDecoders = new short[Base.kNumStates];
+	short[] m_IsRepG0Decoders = new short[Base.kNumStates];
+	short[] m_IsRepG1Decoders = new short[Base.kNumStates];
+	short[] m_IsRepG2Decoders = new short[Base.kNumStates];
+	short[] m_IsRep0LongDecoders = new short[Base.kNumStates &lt;&lt; Base.kNumPosStatesBitsMax];
+	
+	BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[Base.kNumLenToPosStates];
+	short[] m_PosDecoders = new short[Base.kNumFullDistances - Base.kEndPosModelIndex];
+	
+	BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(Base.kNumAlignBits);
+	
+	LenDecoder m_LenDecoder = new LenDecoder();
+	LenDecoder m_RepLenDecoder = new LenDecoder();
+	
+	LiteralDecoder m_LiteralDecoder = new LiteralDecoder();
+	
+	int m_DictionarySize = -1;
+	int m_DictionarySizeCheck =  -1;
+	
+	int m_PosStateMask;
+	
+	public Decoder()
+	{
+		for (int i = 0; i &lt; Base.kNumLenToPosStates; i++)
+			m_PosSlotDecoder[i] = new BitTreeDecoder(Base.kNumPosSlotBits);
+	}
+	
+	boolean SetDictionarySize(int dictionarySize)
+	{
+		if (dictionarySize &lt; 0)
+			return false;
+		if (m_DictionarySize != dictionarySize)
+		{
+			m_DictionarySize = dictionarySize;
+			m_DictionarySizeCheck = Math.max(m_DictionarySize, 1);
+			m_OutWindow.Create(Math.max(m_DictionarySizeCheck, (1 &lt;&lt; 12)));
+		}
+		return true;
+	}
+	
+	boolean SetLcLpPb(int lc, int lp, int pb)
+	{
+		if (lc &gt; Base.kNumLitContextBitsMax || lp &gt; 4 || pb &gt; Base.kNumPosStatesBitsMax)
+			return false;
+		m_LiteralDecoder.Create(lp, lc);
+		int numPosStates = 1 &lt;&lt; pb;
+		m_LenDecoder.Create(numPosStates);
+		m_RepLenDecoder.Create(numPosStates);
+		m_PosStateMask = numPosStates - 1;
+		return true;
+	}
+	
+	void Init() throws IOException
+	{
+		m_OutWindow.Init(false);
+		
+		SevenZip.Compression.RangeCoder.Decoder.InitBitModels(m_IsMatchDecoders);
+		SevenZip.Compression.RangeCoder.Decoder.InitBitModels(m_IsRep0LongDecoders);
+		SevenZip.Compression.RangeCoder.Decoder.InitBitModels(m_IsRepDecoders);
+		SevenZip.Compression.RangeCoder.Decoder.InitBitModels(m_IsRepG0Decoders);
+		SevenZip.Compression.RangeCoder.Decoder.InitBitModels(m_IsRepG1Decoders);
+		SevenZip.Compression.RangeCoder.Decoder.InitBitModels(m_IsRepG2Decoders);
+		SevenZip.Compression.RangeCoder.Decoder.InitBitModels(m_PosDecoders);
+		
+		m_LiteralDecoder.Init();
+		int i;
+		for (i = 0; i &lt; Base.kNumLenToPosStates; i++)
+			m_PosSlotDecoder[i].Init();
+		m_LenDecoder.Init();
+		m_RepLenDecoder.Init();
+		m_PosAlignDecoder.Init();
+		m_RangeDecoder.Init();
+	}
+	
+	public boolean Code(java.io.InputStream inStream, java.io.OutputStream outStream,
+			long outSize) throws IOException
+	{
+		m_RangeDecoder.SetStream(inStream);
+		m_OutWindow.SetStream(outStream);
+		Init();
+		
+		int state = Base.StateInit();
+		int rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0;
+		
+		long nowPos64 = 0;
+		byte prevByte = 0;
+		while (outSize &lt; 0 || nowPos64 &lt; outSize)
+		{
+			int posState = (int)nowPos64 &amp; m_PosStateMask;
+			if (m_RangeDecoder.DecodeBit(m_IsMatchDecoders, (state &lt;&lt; Base.kNumPosStatesBitsMax) + posState) == 0)
+			{
+				LiteralDecoder.Decoder2 decoder2 = m_LiteralDecoder.GetDecoder((int)nowPos64, prevByte);
+				if (!Base.StateIsCharState(state))
+					prevByte = decoder2.DecodeWithMatchByte(m_RangeDecoder, m_OutWindow.GetByte(rep0));
+				else
+					prevByte = decoder2.DecodeNormal(m_RangeDecoder);
+				m_OutWindow.PutByte(prevByte);
+				state = Base.StateUpdateChar(state);
+				nowPos64++;
+			}
+			else
+			{
+				int len;
+				if (m_RangeDecoder.DecodeBit(m_IsRepDecoders, state) == 1)
+				{
+					len = 0;
+					if (m_RangeDecoder.DecodeBit(m_IsRepG0Decoders, state) == 0)
+					{
+						if (m_RangeDecoder.DecodeBit(m_IsRep0LongDecoders, (state &lt;&lt; Base.kNumPosStatesBitsMax) + posState) == 0)
+						{
+							state = Base.StateUpdateShortRep(state);
+							len = 1;
+						}
+					}
+					else
+					{
+						int distance;
+						if (m_RangeDecoder.DecodeBit(m_IsRepG1Decoders, state) == 0)
+							distance = rep1;
+						else
+						{
+							if (m_RangeDecoder.DecodeBit(m_IsRepG2Decoders, state) == 0)
+								distance = rep2;
+							else
+							{
+								distance = rep3;
+								rep3 = rep2;
+							}
+							rep2 = rep1;
+						}
+						rep1 = rep0;
+						rep0 = distance;
+					}
+					if (len == 0)
+					{
+						len = m_RepLenDecoder.Decode(m_RangeDecoder, posState) + Base.kMatchMinLen;
+						state = Base.StateUpdateRep(state);
+					}
+				}
+				else
+				{
+					rep3 = rep2;
+					rep2 = rep1;
+					rep1 = rep0;
+					len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder, posState);
+					state = Base.StateUpdateMatch(state);
+					int posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);
+					if (posSlot &gt;= Base.kStartPosModelIndex)
+					{
+						int numDirectBits = (posSlot &gt;&gt; 1) - 1;
+						rep0 = ((2 | (posSlot &amp; 1)) &lt;&lt; numDirectBits);
+						if (posSlot &lt; Base.kEndPosModelIndex)
+							rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders,
+									rep0 - posSlot - 1, m_RangeDecoder, numDirectBits);
+						else
+						{
+							rep0 += (m_RangeDecoder.DecodeDirectBits(
+									numDirectBits - Base.kNumAlignBits) &lt;&lt; Base.kNumAlignBits);
+							rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);
+							if (rep0 &lt; 0)
+							{
+								if (rep0 == -1)
+									break;
+								return false;
+							}
+						}
+					}
+					else
+						rep0 = posSlot;
+				}
+				if (rep0 &gt;= nowPos64 || rep0 &gt;= m_DictionarySizeCheck)
+				{
+					// m_OutWindow.Flush();
+					return false;
+				}
+				m_OutWindow.CopyBlock(rep0, len);
+				nowPos64 += len;
+				prevByte = m_OutWindow.GetByte(0);
+			}
+		}
+		m_OutWindow.Flush();
+		m_OutWindow.ReleaseStream();
+		m_RangeDecoder.ReleaseStream();
+		return true;
+	}
+	
+	public boolean SetDecoderProperties(byte[] properties)
+	{
+		if (properties.length &lt; 5)
+			return false;
+		int val = properties[0] &amp; 0xFF;
+		int lc = val % 9;
+		int remainder = val / 9;
+		int lp = remainder % 5;
+		int pb = remainder / 5;
+		int dictionarySize = 0;
+		for (int i = 0; i &lt; 4; i++)
+			dictionarySize += ((int)(properties[1 + i]) &amp; 0xFF) &lt;&lt; (i * 8);
+		if (!SetLcLpPb(lc, lp, pb))
+			return false;
+		return SetDictionarySize(dictionarySize);
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Decoder.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Encoder.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Encoder.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Encoder.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,1416 @@
+package SevenZip.Compression.LZMA;
+
+import SevenZip.Compression.RangeCoder.BitTreeEncoder;
+import SevenZip.Compression.LZMA.Base;
+import SevenZip.Compression.LZ.BinTree;
+import SevenZip.ICodeProgress;
+import java.io.IOException;
+
+public class Encoder
+{
+	public static final int EMatchFinderTypeBT2 = 0;
+	public static final int EMatchFinderTypeBT4 = 1;
+
+
+
+
+	static final int kIfinityPrice = 0xFFFFFFF;
+
+	static byte[] g_FastPos = new byte[1 &lt;&lt; 11];
+
+	static
+	{
+		int kFastSlots = 22;
+		int c = 2;
+		g_FastPos[0] = 0;
+		g_FastPos[1] = 1;
+		for (int slotFast = 2; slotFast &lt; kFastSlots; slotFast++)
+		{
+			int k = (1 &lt;&lt; ((slotFast &gt;&gt; 1) - 1));
+			for (int j = 0; j &lt; k; j++, c++)
+				g_FastPos[c] = (byte)slotFast;
+		}
+	}
+
+	static int GetPosSlot(int pos)
+	{
+		if (pos &lt; (1 &lt;&lt; 11))
+			return g_FastPos[pos];
+		if (pos &lt; (1 &lt;&lt; 21))
+			return (g_FastPos[pos &gt;&gt; 10] + 20);
+		return (g_FastPos[pos &gt;&gt; 20] + 40);
+	}
+
+	static int GetPosSlot2(int pos)
+	{
+		if (pos &lt; (1 &lt;&lt; 17))
+			return (g_FastPos[pos &gt;&gt; 6] + 12);
+		if (pos &lt; (1 &lt;&lt; 27))
+			return (g_FastPos[pos &gt;&gt; 16] + 32);
+		return (g_FastPos[pos &gt;&gt; 26] + 52);
+	}
+
+	int _state = Base.StateInit();
+	byte _previousByte;
+	int[] _repDistances = new int[Base.kNumRepDistances];
+
+	void BaseInit()
+	{
+		_state = Base.StateInit();
+		_previousByte = 0;
+		for (int i = 0; i &lt; Base.kNumRepDistances; i++)
+			_repDistances[i] = 0;
+	}
+
+	static final int kDefaultDictionaryLogSize = 22;
+	static final int kNumFastBytesDefault = 0x20;
+
+	class LiteralEncoder
+	{
+		class Encoder2
+		{
+			short[] m_Encoders = new short[0x300];
+
+			public void Init() { SevenZip.Compression.RangeCoder.Encoder.InitBitModels(m_Encoders); }
+
+
+
+			public void Encode(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, byte symbol) throws IOException
+			{
+				int context = 1;
+				for (int i = 7; i &gt;= 0; i--)
+				{
+					int bit = ((symbol &gt;&gt; i) &amp; 1);
+					rangeEncoder.Encode(m_Encoders, context, bit);
+					context = (context &lt;&lt; 1) | bit;
+				}
+			}
+
+			public void EncodeMatched(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, byte matchByte, byte symbol) throws IOException
+			{
+				int context = 1;
+				boolean same = true;
+				for (int i = 7; i &gt;= 0; i--)
+				{
+					int bit = ((symbol &gt;&gt; i) &amp; 1);
+					int state = context;
+					if (same)
+					{
+						int matchBit = ((matchByte &gt;&gt; i) &amp; 1);
+						state += ((1 + matchBit) &lt;&lt; 8);
+						same = (matchBit == bit);
+					}
+					rangeEncoder.Encode(m_Encoders, state, bit);
+					context = (context &lt;&lt; 1) | bit;
+				}
+			}
+
+			public int GetPrice(boolean matchMode, byte matchByte, byte symbol)
+			{
+				int price = 0;
+				int context = 1;
+				int i = 7;
+				if (matchMode)
+				{
+					for (; i &gt;= 0; i--)
+					{
+						int matchBit = (matchByte &gt;&gt; i) &amp; 1;
+						int bit = (symbol &gt;&gt; i) &amp; 1;
+						price += SevenZip.Compression.RangeCoder.Encoder.GetPrice(m_Encoders[((1 + matchBit) &lt;&lt; 8) + context], bit);
+						context = (context &lt;&lt; 1) | bit;
+						if (matchBit != bit)
+						{
+							i--;
+							break;
+						}
+					}
+				}
+				for (; i &gt;= 0; i--)
+				{
+					int bit = (symbol &gt;&gt; i) &amp; 1;
+					price += SevenZip.Compression.RangeCoder.Encoder.GetPrice(m_Encoders[context], bit);
+					context = (context &lt;&lt; 1) | bit;
+				}
+				return price;
+			}
+		}
+
+		Encoder2[] m_Coders;
+		int m_NumPrevBits;
+		int m_NumPosBits;
+		int m_PosMask;
+
+		public void Create(int numPosBits, int numPrevBits)
+		{
+			if (m_Coders != null &amp;&amp; m_NumPrevBits == numPrevBits &amp;&amp; m_NumPosBits == numPosBits)
+				return;
+			m_NumPosBits = numPosBits;
+			m_PosMask = (1 &lt;&lt; numPosBits) - 1;
+			m_NumPrevBits = numPrevBits;
+			int numStates = 1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);
+			m_Coders = new Encoder2[numStates];
+			for (int i = 0; i &lt; numStates; i++)
+				m_Coders[i] = new Encoder2();
+		}
+
+		public void Init()
+		{
+			int numStates = 1 &lt;&lt; (m_NumPrevBits + m_NumPosBits);
+			for (int i = 0; i &lt; numStates; i++)
+				m_Coders[i].Init();
+		}
+
+		public Encoder2 GetSubCoder(int pos, byte prevByte)
+		{ return m_Coders[((pos &amp; m_PosMask) &lt;&lt; m_NumPrevBits) + ((prevByte &amp; 0xFF) &gt;&gt;&gt; (8 - m_NumPrevBits))]; }
+	}
+
+	class LenEncoder
+	{
+		short[] _choice = new short[2];
+		BitTreeEncoder[] _lowCoder = new BitTreeEncoder[Base.kNumPosStatesEncodingMax];
+		BitTreeEncoder[] _midCoder = new BitTreeEncoder[Base.kNumPosStatesEncodingMax];
+		BitTreeEncoder _highCoder = new BitTreeEncoder(Base.kNumHighLenBits);
+
+
+		public LenEncoder()
+		{
+			for (int posState = 0; posState &lt; Base.kNumPosStatesEncodingMax; posState++)
+			{
+				_lowCoder[posState] = new BitTreeEncoder(Base.kNumLowLenBits);
+				_midCoder[posState] = new BitTreeEncoder(Base.kNumMidLenBits);
+			}
+		}
+
+		public void Init(int numPosStates)
+		{
+			SevenZip.Compression.RangeCoder.Encoder.InitBitModels(_choice);
+
+			for (int posState = 0; posState &lt; numPosStates; posState++)
+			{
+				_lowCoder[posState].Init();
+				_midCoder[posState].Init();
+			}
+			_highCoder.Init();
+		}
+
+		public void Encode(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, int symbol, int posState) throws IOException
+		{
+			if (symbol &lt; Base.kNumLowLenSymbols)
+			{
+				rangeEncoder.Encode(_choice, 0, 0);
+				_lowCoder[posState].Encode(rangeEncoder, symbol);
+			}
+			else
+			{
+				symbol -= Base.kNumLowLenSymbols;
+				rangeEncoder.Encode(_choice, 0, 1);
+				if (symbol &lt; Base.kNumMidLenSymbols)
+				{
+					rangeEncoder.Encode(_choice, 1, 0);
+					_midCoder[posState].Encode(rangeEncoder, symbol);
+				}
+				else
+				{
+					rangeEncoder.Encode(_choice, 1, 1);
+					_highCoder.Encode(rangeEncoder, symbol - Base.kNumMidLenSymbols);
+				}
+			}
+		}
+
+		public void SetPrices(int posState, int numSymbols, int[] prices, int st)
+		{
+			int a0 = SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_choice[0]);
+			int a1 = SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_choice[0]);
+			int b0 = a1 + SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_choice[1]);
+			int b1 = a1 + SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_choice[1]);
+			int i = 0;
+			for (i = 0; i &lt; Base.kNumLowLenSymbols; i++)
+			{
+				if (i &gt;= numSymbols)
+					return;
+				prices[st + i] = a0 + _lowCoder[posState].GetPrice(i);
+			}
+			for (; i &lt; Base.kNumLowLenSymbols + Base.kNumMidLenSymbols; i++)
+			{
+				if (i &gt;= numSymbols)
+					return;
+				prices[st + i] = b0 + _midCoder[posState].GetPrice(i - Base.kNumLowLenSymbols);
+			}
+			for (; i &lt; numSymbols; i++)
+				prices[st + i] = b1 + _highCoder.GetPrice(i - Base.kNumLowLenSymbols - Base.kNumMidLenSymbols);
+		}
+	};
+
+	public static final int kNumLenSpecSymbols = Base.kNumLowLenSymbols + Base.kNumMidLenSymbols;
+
+	class LenPriceTableEncoder extends LenEncoder
+	{
+		int[] _prices = new int[Base.kNumLenSymbols&lt;&lt;Base.kNumPosStatesBitsEncodingMax];
+		int _tableSize;
+		int[] _counters = new int[Base.kNumPosStatesEncodingMax];
+
+		public void SetTableSize(int tableSize) { _tableSize = tableSize; }
+
+		public int GetPrice(int symbol, int posState)
+		{
+			return _prices[posState * Base.kNumLenSymbols + symbol];
+		}
+
+		void UpdateTable(int posState)
+		{
+			SetPrices(posState, _tableSize, _prices, posState * Base.kNumLenSymbols);
+			_counters[posState] = _tableSize;
+		}
+
+		public void UpdateTables(int numPosStates)
+		{
+			for (int posState = 0; posState &lt; numPosStates; posState++)
+				UpdateTable(posState);
+		}
+
+		public void Encode(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, int symbol, int posState) throws IOException
+		{
+			super.Encode(rangeEncoder, symbol, posState);
+			if (--_counters[posState] == 0)
+				UpdateTable(posState);
+		}
+	}
+
+	static final int kNumOpts = 1 &lt;&lt; 12;
+	class Optimal
+	{
+		public int State;
+
+		public boolean Prev1IsChar;
+		public boolean Prev2;
+
+		public int PosPrev2;
+		public int BackPrev2;
+
+		public int Price;
+		public int PosPrev;
+		public int BackPrev;
+
+		public int Backs0;
+		public int Backs1;
+		public int Backs2;
+		public int Backs3;
+
+		public void MakeAsChar() { BackPrev = -1; Prev1IsChar = false; }
+		public void MakeAsShortRep() { BackPrev = 0; ; Prev1IsChar = false; }
+		public boolean IsShortRep() { return (BackPrev == 0); }
+	};
+	Optimal[] _optimum = new Optimal[kNumOpts];
+	SevenZip.Compression.LZ.BinTree _matchFinder = null;
+	SevenZip.Compression.RangeCoder.Encoder _rangeEncoder = new SevenZip.Compression.RangeCoder.Encoder();
+
+	short[] _isMatch = new short[Base.kNumStates&lt;&lt;Base.kNumPosStatesBitsMax];
+	short[] _isRep = new short[Base.kNumStates];
+	short[] _isRepG0 = new short[Base.kNumStates];
+	short[] _isRepG1 = new short[Base.kNumStates];
+	short[] _isRepG2 = new short[Base.kNumStates];
+	short[] _isRep0Long = new short[Base.kNumStates&lt;&lt;Base.kNumPosStatesBitsMax];
+
+	BitTreeEncoder[] _posSlotEncoder = new BitTreeEncoder[Base.kNumLenToPosStates]; // kNumPosSlotBits
+
+	short[] _posEncoders = new short[Base.kNumFullDistances-Base.kEndPosModelIndex];
+	BitTreeEncoder _posAlignEncoder = new BitTreeEncoder(Base.kNumAlignBits);
+
+	LenPriceTableEncoder _lenEncoder = new LenPriceTableEncoder();
+	LenPriceTableEncoder _repMatchLenEncoder = new LenPriceTableEncoder();
+
+	LiteralEncoder _literalEncoder = new LiteralEncoder();
+
+	int[] _matchDistances = new int[Base.kMatchMaxLen*2+2];
+
+	int _numFastBytes = kNumFastBytesDefault;
+	int _longestMatchLength;
+	int _numDistancePairs;
+
+	int _additionalOffset;
+
+	int _optimumEndIndex;
+	int _optimumCurrentIndex;
+
+	boolean _longestMatchWasFound;
+
+	int[] _posSlotPrices = new int[1&lt;&lt;(Base.kNumPosSlotBits+Base.kNumLenToPosStatesBits)];
+	int[] _distancesPrices = new int[Base.kNumFullDistances&lt;&lt;Base.kNumLenToPosStatesBits];
+	int[] _alignPrices = new int[Base.kAlignTableSize];
+	int _alignPriceCount;
+
+	int _distTableSize = (kDefaultDictionaryLogSize * 2);
+
+	int _posStateBits = 2;
+	int _posStateMask = (4 - 1);
+	int _numLiteralPosStateBits = 0;
+	int _numLiteralContextBits = 3;
+
+	int _dictionarySize = (1 &lt;&lt; kDefaultDictionaryLogSize);
+	int _dictionarySizePrev = -1;
+	int _numFastBytesPrev = -1;
+
+	long nowPos64;
+	boolean _finished;
+	java.io.InputStream _inStream;
+
+	int _matchFinderType = EMatchFinderTypeBT4;
+	boolean _writeEndMark = false;
+
+	boolean _needReleaseMFStream = false;
+
+	void Create()
+	{
+		if (_matchFinder == null)
+		{
+			SevenZip.Compression.LZ.BinTree bt = new SevenZip.Compression.LZ.BinTree();
+			int numHashBytes = 4;
+			if (_matchFinderType == EMatchFinderTypeBT2)
+				numHashBytes = 2;
+			bt.SetType(numHashBytes);
+			_matchFinder = bt;
+		}
+		_literalEncoder.Create(_numLiteralPosStateBits, _numLiteralContextBits);
+
+		if (_dictionarySize == _dictionarySizePrev &amp;&amp; _numFastBytesPrev == _numFastBytes)
+			return;
+		_matchFinder.Create(_dictionarySize, kNumOpts, _numFastBytes, Base.kMatchMaxLen + 1);
+		_dictionarySizePrev = _dictionarySize;
+		_numFastBytesPrev = _numFastBytes;
+	}
+
+	public Encoder()
+	{
+		for (int i = 0; i &lt; kNumOpts; i++)
+			_optimum[i] = new Optimal();
+		for (int i = 0; i &lt; Base.kNumLenToPosStates; i++)
+			_posSlotEncoder[i] = new BitTreeEncoder(Base.kNumPosSlotBits);
+	}
+
+	void SetWriteEndMarkerMode(boolean writeEndMarker)
+	{
+		_writeEndMark = writeEndMarker;
+	}
+
+	void Init()
+	{
+		BaseInit();
+		_rangeEncoder.Init();
+
+		SevenZip.Compression.RangeCoder.Encoder.InitBitModels(_isMatch);
+		SevenZip.Compression.RangeCoder.Encoder.InitBitModels(_isRep0Long);
+		SevenZip.Compression.RangeCoder.Encoder.InitBitModels(_isRep);
+		SevenZip.Compression.RangeCoder.Encoder.InitBitModels(_isRepG0);
+		SevenZip.Compression.RangeCoder.Encoder.InitBitModels(_isRepG1);
+		SevenZip.Compression.RangeCoder.Encoder.InitBitModels(_isRepG2);
+		SevenZip.Compression.RangeCoder.Encoder.InitBitModels(_posEncoders);
+
+
+
+
+
+
+
+		_literalEncoder.Init();
+		for (int i = 0; i &lt; Base.kNumLenToPosStates; i++)
+			_posSlotEncoder[i].Init();
+
+
+
+		_lenEncoder.Init(1 &lt;&lt; _posStateBits);
+		_repMatchLenEncoder.Init(1 &lt;&lt; _posStateBits);
+
+		_posAlignEncoder.Init();
+
+		_longestMatchWasFound = false;
+		_optimumEndIndex = 0;
+		_optimumCurrentIndex = 0;
+		_additionalOffset = 0;
+	}
+
+	int ReadMatchDistances() throws java.io.IOException
+	{
+		int lenRes = 0;
+		_numDistancePairs = _matchFinder.GetMatches(_matchDistances);
+		if (_numDistancePairs &gt; 0)
+		{
+			lenRes = _matchDistances[_numDistancePairs - 2];
+			if (lenRes == _numFastBytes)
+				lenRes += _matchFinder.GetMatchLen((int)lenRes - 1, _matchDistances[_numDistancePairs - 1],
+					Base.kMatchMaxLen - lenRes);
+		}
+		_additionalOffset++;
+		return lenRes;
+	}
+
+	void MovePos(int num) throws java.io.IOException
+	{
+		if (num &gt; 0)
+		{
+			_matchFinder.Skip(num);
+			_additionalOffset += num;
+		}
+	}
+
+	int GetRepLen1Price(int state, int posState)
+	{
+		return SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isRepG0[state]) +
+				SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isRep0Long[(state &lt;&lt; Base.kNumPosStatesBitsMax) + posState]);
+	}
+
+	int GetPureRepPrice(int repIndex, int state, int posState)
+	{
+		int price;
+		if (repIndex == 0)
+		{
+			price = SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isRepG0[state]);
+			price += SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isRep0Long[(state &lt;&lt; Base.kNumPosStatesBitsMax) + posState]);
+		}
+		else
+		{
+			price = SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isRepG0[state]);
+			if (repIndex == 1)
+				price += SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isRepG1[state]);
+			else
+			{
+				price += SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isRepG1[state]);
+				price += SevenZip.Compression.RangeCoder.Encoder.GetPrice(_isRepG2[state], repIndex - 2);
+			}
+		}
+		return price;
+	}
+
+	int GetRepPrice(int repIndex, int len, int state, int posState)
+	{
+		int price = _repMatchLenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
+		return price + GetPureRepPrice(repIndex, state, posState);
+	}
+
+	int GetPosLenPrice(int pos, int len, int posState)
+	{
+		int price;
+		int lenToPosState = Base.GetLenToPosState(len);
+		if (pos &lt; Base.kNumFullDistances)
+			price = _distancesPrices[(lenToPosState * Base.kNumFullDistances) + pos];
+		else
+			price = _posSlotPrices[(lenToPosState &lt;&lt; Base.kNumPosSlotBits) + GetPosSlot2(pos)] +
+				_alignPrices[pos &amp; Base.kAlignMask];
+		return price + _lenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
+	}
+
+	int Backward(int cur)
+	{
+		_optimumEndIndex = cur;
+		int posMem = _optimum[cur].PosPrev;
+		int backMem = _optimum[cur].BackPrev;
+		do
+		{
+			if (_optimum[cur].Prev1IsChar)
+			{
+				_optimum[posMem].MakeAsChar();
+				_optimum[posMem].PosPrev = posMem - 1;
+				if (_optimum[cur].Prev2)
+				{
+					_optimum[posMem - 1].Prev1IsChar = false;
+					_optimum[posMem - 1].PosPrev = _optimum[cur].PosPrev2;
+					_optimum[posMem - 1].BackPrev = _optimum[cur].BackPrev2;
+				}
+			}
+			int posPrev = posMem;
+			int backCur = backMem;
+
+			backMem = _optimum[posPrev].BackPrev;
+			posMem = _optimum[posPrev].PosPrev;
+
+			_optimum[posPrev].BackPrev = backCur;
+			_optimum[posPrev].PosPrev = cur;
+			cur = posPrev;
+		}
+		while (cur &gt; 0);
+		backRes = _optimum[0].BackPrev;
+		_optimumCurrentIndex = _optimum[0].PosPrev;
+		return _optimumCurrentIndex;
+	}
+
+	int[] reps = new int[Base.kNumRepDistances];
+	int[] repLens = new int[Base.kNumRepDistances];
+	int backRes;
+
+	int GetOptimum(int position) throws IOException
+	{
+		if (_optimumEndIndex != _optimumCurrentIndex)
+		{
+			int lenRes = _optimum[_optimumCurrentIndex].PosPrev - _optimumCurrentIndex;
+			backRes = _optimum[_optimumCurrentIndex].BackPrev;
+			_optimumCurrentIndex = _optimum[_optimumCurrentIndex].PosPrev;
+			return lenRes;
+		}
+		_optimumCurrentIndex = _optimumEndIndex = 0;
+
+		int lenMain, numDistancePairs;
+		if (!_longestMatchWasFound)
+		{
+			lenMain = ReadMatchDistances();
+		}
+		else
+		{
+			lenMain = _longestMatchLength;
+			_longestMatchWasFound = false;
+		}
+		numDistancePairs = _numDistancePairs;
+
+		int numAvailableBytes = _matchFinder.GetNumAvailableBytes() + 1;
+		if (numAvailableBytes &lt; 2)
+		{
+			backRes = -1;
+			return 1;
+		}
+		if (numAvailableBytes &gt; Base.kMatchMaxLen)
+			numAvailableBytes = Base.kMatchMaxLen;
+
+		int repMaxIndex = 0;
+		int i;
+		for (i = 0; i &lt; Base.kNumRepDistances; i++)
+		{
+			reps[i] = _repDistances[i];
+			repLens[i] = _matchFinder.GetMatchLen(0 - 1, reps[i], Base.kMatchMaxLen);
+			if (repLens[i] &gt; repLens[repMaxIndex])
+				repMaxIndex = i;
+		}
+		if (repLens[repMaxIndex] &gt;= _numFastBytes)
+		{
+			backRes = repMaxIndex;
+			int lenRes = repLens[repMaxIndex];
+			MovePos(lenRes - 1);
+			return lenRes;
+		}
+
+		if (lenMain &gt;= _numFastBytes)
+		{
+			backRes = _matchDistances[numDistancePairs - 1] + Base.kNumRepDistances;
+			MovePos(lenMain - 1);
+			return lenMain;
+		}
+
+		byte currentByte = _matchFinder.GetIndexByte(0 - 1);
+		byte matchByte = _matchFinder.GetIndexByte(0 - _repDistances[0] - 1 - 1);
+
+		if (lenMain &lt; 2 &amp;&amp; currentByte != matchByte &amp;&amp; repLens[repMaxIndex] &lt; 2)
+		{
+			backRes = -1;
+			return 1;
+		}
+
+		_optimum[0].State = _state;
+
+		int posState = (position &amp; _posStateMask);
+
+		_optimum[1].Price = SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isMatch[(_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState]) +
+				_literalEncoder.GetSubCoder(position, _previousByte).GetPrice(!Base.StateIsCharState(_state), matchByte, currentByte);
+		_optimum[1].MakeAsChar();
+
+		int matchPrice = SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isMatch[(_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState]);
+		int repMatchPrice = matchPrice + SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isRep[_state]);
+
+		if (matchByte == currentByte)
+		{
+			int shortRepPrice = repMatchPrice + GetRepLen1Price(_state, posState);
+			if (shortRepPrice &lt; _optimum[1].Price)
+			{
+				_optimum[1].Price = shortRepPrice;
+				_optimum[1].MakeAsShortRep();
+			}
+		}
+
+		int lenEnd = ((lenMain &gt;= repLens[repMaxIndex]) ? lenMain : repLens[repMaxIndex]);
+
+		if (lenEnd &lt; 2)
+		{
+			backRes = _optimum[1].BackPrev;
+			return 1;
+		}
+
+		_optimum[1].PosPrev = 0;
+
+		_optimum[0].Backs0 = reps[0];
+		_optimum[0].Backs1 = reps[1];
+		_optimum[0].Backs2 = reps[2];
+		_optimum[0].Backs3 = reps[3];
+
+		int len = lenEnd;
+		do
+			_optimum[len--].Price = kIfinityPrice;
+		while (len &gt;= 2);
+
+		for (i = 0; i &lt; Base.kNumRepDistances; i++)
+		{
+			int repLen = repLens[i];
+			if (repLen &lt; 2)
+				continue;
+			int price = repMatchPrice + GetPureRepPrice(i, _state, posState);
+			do
+			{
+				int curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2, posState);
+				Optimal optimum = _optimum[repLen];
+				if (curAndLenPrice &lt; optimum.Price)
+				{
+					optimum.Price = curAndLenPrice;
+					optimum.PosPrev = 0;
+					optimum.BackPrev = i;
+					optimum.Prev1IsChar = false;
+				}
+			}
+			while (--repLen &gt;= 2);
+		}
+
+		int normalMatchPrice = matchPrice + SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isRep[_state]);
+
+		len = ((repLens[0] &gt;= 2) ? repLens[0] + 1 : 2);
+		if (len &lt;= lenMain)
+		{
+			int offs = 0;
+			while (len &gt; _matchDistances[offs])
+				offs += 2;
+			for (; ; len++)
+			{
+				int distance = _matchDistances[offs + 1];
+				int curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance, len, posState);
+				Optimal optimum = _optimum[len];
+				if (curAndLenPrice &lt; optimum.Price)
+				{
+					optimum.Price = curAndLenPrice;
+					optimum.PosPrev = 0;
+					optimum.BackPrev = distance + Base.kNumRepDistances;
+					optimum.Prev1IsChar = false;
+				}
+				if (len == _matchDistances[offs])
+				{
+					offs += 2;
+					if (offs == numDistancePairs)
+						break;
+				}
+			}
+		}
+
+		int cur = 0;
+
+		while (true)
+		{
+			cur++;
+			if (cur == lenEnd)
+				return Backward(cur);
+			int newLen = ReadMatchDistances();
+			numDistancePairs = _numDistancePairs;
+			if (newLen &gt;= _numFastBytes)
+			{
+
+				_longestMatchLength = newLen;
+				_longestMatchWasFound = true;
+				return Backward(cur);
+			}
+			position++;
+			int posPrev = _optimum[cur].PosPrev;
+			int state;
+			if (_optimum[cur].Prev1IsChar)
+			{
+				posPrev--;
+				if (_optimum[cur].Prev2)
+				{
+					state = _optimum[_optimum[cur].PosPrev2].State;
+					if (_optimum[cur].BackPrev2 &lt; Base.kNumRepDistances)
+						state = Base.StateUpdateRep(state);
+					else
+						state = Base.StateUpdateMatch(state);
+				}
+				else
+					state = _optimum[posPrev].State;
+				state = Base.StateUpdateChar(state);
+			}
+			else
+				state = _optimum[posPrev].State;
+			if (posPrev == cur - 1)
+			{
+				if (_optimum[cur].IsShortRep())
+					state = Base.StateUpdateShortRep(state);
+				else
+					state = Base.StateUpdateChar(state);
+			}
+			else
+			{
+				int pos;
+				if (_optimum[cur].Prev1IsChar &amp;&amp; _optimum[cur].Prev2)
+				{
+					posPrev = _optimum[cur].PosPrev2;
+					pos = _optimum[cur].BackPrev2;
+					state = Base.StateUpdateRep(state);
+				}
+				else
+				{
+					pos = _optimum[cur].BackPrev;
+					if (pos &lt; Base.kNumRepDistances)
+						state = Base.StateUpdateRep(state);
+					else
+						state = Base.StateUpdateMatch(state);
+				}
+				Optimal opt = _optimum[posPrev];
+				if (pos &lt; Base.kNumRepDistances)
+				{
+					if (pos == 0)
+					{
+						reps[0] = opt.Backs0;
+						reps[1] = opt.Backs1;
+						reps[2] = opt.Backs2;
+						reps[3] = opt.Backs3;
+					}
+					else if (pos == 1)
+					{
+						reps[0] = opt.Backs1;
+						reps[1] = opt.Backs0;
+						reps[2] = opt.Backs2;
+						reps[3] = opt.Backs3;
+					}
+					else if (pos == 2)
+					{
+						reps[0] = opt.Backs2;
+						reps[1] = opt.Backs0;
+						reps[2] = opt.Backs1;
+						reps[3] = opt.Backs3;
+					}
+					else
+					{
+						reps[0] = opt.Backs3;
+						reps[1] = opt.Backs0;
+						reps[2] = opt.Backs1;
+						reps[3] = opt.Backs2;
+					}
+				}
+				else
+				{
+					reps[0] = (pos - Base.kNumRepDistances);
+					reps[1] = opt.Backs0;
+					reps[2] = opt.Backs1;
+					reps[3] = opt.Backs2;
+				}
+			}
+			_optimum[cur].State = state;
+			_optimum[cur].Backs0 = reps[0];
+			_optimum[cur].Backs1 = reps[1];
+			_optimum[cur].Backs2 = reps[2];
+			_optimum[cur].Backs3 = reps[3];
+			int curPrice = _optimum[cur].Price;
+
+			currentByte = _matchFinder.GetIndexByte(0 - 1);
+			matchByte = _matchFinder.GetIndexByte(0 - reps[0] - 1 - 1);
+
+			posState = (position &amp; _posStateMask);
+
+			int curAnd1Price = curPrice +
+				SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isMatch[(state &lt;&lt; Base.kNumPosStatesBitsMax) + posState]) +
+				_literalEncoder.GetSubCoder(position, _matchFinder.GetIndexByte(0 - 2)).
+				GetPrice(!Base.StateIsCharState(state), matchByte, currentByte);
+
+			Optimal nextOptimum = _optimum[cur + 1];
+
+			boolean nextIsChar = false;
+			if (curAnd1Price &lt; nextOptimum.Price)
+			{
+				nextOptimum.Price = curAnd1Price;
+				nextOptimum.PosPrev = cur;
+				nextOptimum.MakeAsChar();
+				nextIsChar = true;
+			}
+
+			matchPrice = curPrice + SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isMatch[(state &lt;&lt; Base.kNumPosStatesBitsMax) + posState]);
+			repMatchPrice = matchPrice + SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isRep[state]);
+
+			if (matchByte == currentByte &amp;&amp;
+				!(nextOptimum.PosPrev &lt; cur &amp;&amp; nextOptimum.BackPrev == 0))
+			{
+				int shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);
+				if (shortRepPrice &lt;= nextOptimum.Price)
+				{
+					nextOptimum.Price = shortRepPrice;
+					nextOptimum.PosPrev = cur;
+					nextOptimum.MakeAsShortRep();
+					nextIsChar = true;
+				}
+			}
+
+			int numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;
+			numAvailableBytesFull = Math.min(kNumOpts - 1 - cur, numAvailableBytesFull);
+			numAvailableBytes = numAvailableBytesFull;
+
+			if (numAvailableBytes &lt; 2)
+				continue;
+			if (numAvailableBytes &gt; _numFastBytes)
+				numAvailableBytes = _numFastBytes;
+			if (!nextIsChar &amp;&amp; matchByte != currentByte)
+			{
+				// try Literal + rep0
+				int t = Math.min(numAvailableBytesFull - 1, _numFastBytes);
+				int lenTest2 = _matchFinder.GetMatchLen(0, reps[0], t);
+				if (lenTest2 &gt;= 2)
+				{
+					int state2 = Base.StateUpdateChar(state);
+
+					int posStateNext = (position + 1) &amp; _posStateMask;
+					int nextRepMatchPrice = curAnd1Price +
+						SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext]) +
+						SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isRep[state2]);
+					{
+						int offset = cur + 1 + lenTest2;
+						while (lenEnd &lt; offset)
+							_optimum[++lenEnd].Price = kIfinityPrice;
+						int curAndLenPrice = nextRepMatchPrice + GetRepPrice(
+								0, lenTest2, state2, posStateNext);
+						Optimal optimum = _optimum[offset];
+						if (curAndLenPrice &lt; optimum.Price)
+						{
+							optimum.Price = curAndLenPrice;
+							optimum.PosPrev = cur + 1;
+							optimum.BackPrev = 0;
+							optimum.Prev1IsChar = true;
+							optimum.Prev2 = false;
+						}
+					}
+				}
+			}
+
+			int startLen = 2; // speed optimization 
+
+			for (int repIndex = 0; repIndex &lt; Base.kNumRepDistances; repIndex++)
+			{
+				int lenTest = _matchFinder.GetMatchLen(0 - 1, reps[repIndex], numAvailableBytes);
+				if (lenTest &lt; 2)
+					continue;
+				int lenTestTemp = lenTest;
+				do
+				{
+					while (lenEnd &lt; cur + lenTest)
+						_optimum[++lenEnd].Price = kIfinityPrice;
+					int curAndLenPrice = repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState);
+					Optimal optimum = _optimum[cur + lenTest];
+					if (curAndLenPrice &lt; optimum.Price)
+					{
+						optimum.Price = curAndLenPrice;
+						optimum.PosPrev = cur;
+						optimum.BackPrev = repIndex;
+						optimum.Prev1IsChar = false;
+					}
+				}
+				while (--lenTest &gt;= 2);
+				lenTest = lenTestTemp;
+
+				if (repIndex == 0)
+					startLen = lenTest + 1;
+
+				// if (_maxMode)
+				if (lenTest &lt; numAvailableBytesFull)
+				{
+					int t = Math.min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
+					int lenTest2 = _matchFinder.GetMatchLen(lenTest, reps[repIndex], t);
+					if (lenTest2 &gt;= 2)
+					{
+						int state2 = Base.StateUpdateRep(state);
+
+						int posStateNext = (position + lenTest) &amp; _posStateMask;
+						int curAndLenCharPrice =
+								repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState) +
+								SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext]) +
+								_literalEncoder.GetSubCoder(position + lenTest,
+								_matchFinder.GetIndexByte(lenTest - 1 - 1)).GetPrice(true,
+								_matchFinder.GetIndexByte(lenTest - 1 - (reps[repIndex] + 1)),
+								_matchFinder.GetIndexByte(lenTest - 1));
+						state2 = Base.StateUpdateChar(state2);
+						posStateNext = (position + lenTest + 1) &amp; _posStateMask;
+						int nextMatchPrice = curAndLenCharPrice + SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext]);
+						int nextRepMatchPrice = nextMatchPrice + SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isRep[state2]);
+
+						// for(; lenTest2 &gt;= 2; lenTest2--)
+						{
+							int offset = lenTest + 1 + lenTest2;
+							while (lenEnd &lt; cur + offset)
+								_optimum[++lenEnd].Price = kIfinityPrice;
+							int curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
+							Optimal optimum = _optimum[cur + offset];
+							if (curAndLenPrice &lt; optimum.Price)
+							{
+								optimum.Price = curAndLenPrice;
+								optimum.PosPrev = cur + lenTest + 1;
+								optimum.BackPrev = 0;
+								optimum.Prev1IsChar = true;
+								optimum.Prev2 = true;
+								optimum.PosPrev2 = cur;
+								optimum.BackPrev2 = repIndex;
+							}
+						}
+					}
+				}
+			}
+
+			if (newLen &gt; numAvailableBytes)
+			{
+				newLen = numAvailableBytes;
+				for (numDistancePairs = 0; newLen &gt; _matchDistances[numDistancePairs]; numDistancePairs += 2) ;
+				_matchDistances[numDistancePairs] = newLen;
+				numDistancePairs += 2;
+			}
+			if (newLen &gt;= startLen)
+			{
+				normalMatchPrice = matchPrice + SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isRep[state]);
+				while (lenEnd &lt; cur + newLen)
+					_optimum[++lenEnd].Price = kIfinityPrice;
+
+				int offs = 0;
+				while (startLen &gt; _matchDistances[offs])
+					offs += 2;
+
+				for (int lenTest = startLen; ; lenTest++)
+				{
+					int curBack = _matchDistances[offs + 1];
+					int curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack, lenTest, posState);
+					Optimal optimum = _optimum[cur + lenTest];
+					if (curAndLenPrice &lt; optimum.Price)
+					{
+						optimum.Price = curAndLenPrice;
+						optimum.PosPrev = cur;
+						optimum.BackPrev = curBack + Base.kNumRepDistances;
+						optimum.Prev1IsChar = false;
+					}
+
+					if (lenTest == _matchDistances[offs])
+					{
+						if (lenTest &lt; numAvailableBytesFull)
+						{
+							int t = Math.min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
+							int lenTest2 = _matchFinder.GetMatchLen(lenTest, curBack, t);
+							if (lenTest2 &gt;= 2)
+							{
+								int state2 = Base.StateUpdateMatch(state);
+
+								int posStateNext = (position + lenTest) &amp; _posStateMask;
+								int curAndLenCharPrice = curAndLenPrice +
+									SevenZip.Compression.RangeCoder.Encoder.GetPrice0(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext]) +
+									_literalEncoder.GetSubCoder(position + lenTest,
+									_matchFinder.GetIndexByte(lenTest - 1 - 1)).
+									GetPrice(true,
+									_matchFinder.GetIndexByte(lenTest - (curBack + 1) - 1),
+									_matchFinder.GetIndexByte(lenTest - 1));
+								state2 = Base.StateUpdateChar(state2);
+								posStateNext = (position + lenTest + 1) &amp; _posStateMask;
+								int nextMatchPrice = curAndLenCharPrice + SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isMatch[(state2 &lt;&lt; Base.kNumPosStatesBitsMax) + posStateNext]);
+								int nextRepMatchPrice = nextMatchPrice + SevenZip.Compression.RangeCoder.Encoder.GetPrice1(_isRep[state2]);
+
+								int offset = lenTest + 1 + lenTest2;
+								while (lenEnd &lt; cur + offset)
+									_optimum[++lenEnd].Price = kIfinityPrice;
+								curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
+								optimum = _optimum[cur + offset];
+								if (curAndLenPrice &lt; optimum.Price)
+								{
+									optimum.Price = curAndLenPrice;
+									optimum.PosPrev = cur + lenTest + 1;
+									optimum.BackPrev = 0;
+									optimum.Prev1IsChar = true;
+									optimum.Prev2 = true;
+									optimum.PosPrev2 = cur;
+									optimum.BackPrev2 = curBack + Base.kNumRepDistances;
+								}
+							}
+						}
+						offs += 2;
+						if (offs == numDistancePairs)
+							break;
+					}
+				}
+			}
+		}
+	}
+
+	boolean ChangePair(int smallDist, int bigDist)
+	{
+		int kDif = 7;
+		return (smallDist &lt; (1 &lt;&lt; (32 - kDif)) &amp;&amp; bigDist &gt;= (smallDist &lt;&lt; kDif));
+	}
+
+	void WriteEndMarker(int posState) throws IOException
+	{
+		if (!_writeEndMark)
+			return;
+
+		_rangeEncoder.Encode(_isMatch, (_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState, 1);
+		_rangeEncoder.Encode(_isRep, _state, 0);
+		_state = Base.StateUpdateMatch(_state);
+		int len = Base.kMatchMinLen;
+		_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
+		int posSlot = (1 &lt;&lt; Base.kNumPosSlotBits) - 1;
+		int lenToPosState = Base.GetLenToPosState(len);
+		_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);
+		int footerBits = 30;
+		int posReduced = (1 &lt;&lt; footerBits) - 1;
+		_rangeEncoder.EncodeDirectBits(posReduced &gt;&gt; Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
+		_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced &amp; Base.kAlignMask);
+	}
+
+	void Flush(int nowPos) throws IOException
+	{
+		ReleaseMFStream();
+		WriteEndMarker(nowPos &amp; _posStateMask);
+		_rangeEncoder.FlushData();
+		_rangeEncoder.FlushStream();
+	}
+
+	public void CodeOneBlock(long[] inSize, long[] outSize, boolean[] finished) throws IOException
+	{
+		inSize[0] = 0;
+		outSize[0] = 0;
+		finished[0] = true;
+
+		if (_inStream != null)
+		{
+			_matchFinder.SetStream(_inStream);
+			_matchFinder.Init();
+			_needReleaseMFStream = true;
+			_inStream = null;
+		}
+
+		if (_finished)
+			return;
+		_finished = true;
+
+
+		long progressPosValuePrev = nowPos64;
+		if (nowPos64 == 0)
+		{
+			if (_matchFinder.GetNumAvailableBytes() == 0)
+			{
+				Flush((int)nowPos64);
+				return;
+			}
+
+			ReadMatchDistances();
+			int posState = (int)(nowPos64) &amp; _posStateMask;
+			_rangeEncoder.Encode(_isMatch, (_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState, 0);
+			_state = Base.StateUpdateChar(_state);
+			byte curByte = _matchFinder.GetIndexByte(0 - _additionalOffset);
+			_literalEncoder.GetSubCoder((int)(nowPos64), _previousByte).Encode(_rangeEncoder, curByte);
+			_previousByte = curByte;
+			_additionalOffset--;
+			nowPos64++;
+		}
+		if (_matchFinder.GetNumAvailableBytes() == 0)
+		{
+			Flush((int)nowPos64);
+			return;
+		}
+		while (true)
+		{
+
+			int len = GetOptimum((int)nowPos64);
+			int pos = backRes;
+			int posState = ((int)nowPos64) &amp; _posStateMask;
+			int complexState = (_state &lt;&lt; Base.kNumPosStatesBitsMax) + posState;
+			if (len == 1 &amp;&amp; pos == -1)
+			{
+				_rangeEncoder.Encode(_isMatch, complexState, 0);
+				byte curByte = _matchFinder.GetIndexByte((int)(0 - _additionalOffset));
+				LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((int)nowPos64, _previousByte);
+				if (!Base.StateIsCharState(_state))
+				{
+					byte matchByte = _matchFinder.GetIndexByte((int)(0 - _repDistances[0] - 1 - _additionalOffset));
+					subCoder.EncodeMatched(_rangeEncoder, matchByte, curByte);
+				}
+				else
+					subCoder.Encode(_rangeEncoder, curByte);
+				_previousByte = curByte;
+				_state = Base.StateUpdateChar(_state);
+			}
+			else
+			{
+				_rangeEncoder.Encode(_isMatch, complexState, 1);
+				if (pos &lt; Base.kNumRepDistances)
+				{
+					_rangeEncoder.Encode(_isRep, _state, 1);
+					if (pos == 0)
+					{
+						_rangeEncoder.Encode(_isRepG0, _state, 0);
+						if (len == 1)
+							_rangeEncoder.Encode(_isRep0Long, complexState, 0);
+						else
+							_rangeEncoder.Encode(_isRep0Long, complexState, 1);
+					}
+					else
+					{
+						_rangeEncoder.Encode(_isRepG0, _state, 1);
+						if (pos == 1)
+							_rangeEncoder.Encode(_isRepG1, _state, 0);
+						else
+						{
+							_rangeEncoder.Encode(_isRepG1, _state, 1);
+							_rangeEncoder.Encode(_isRepG2, _state, pos - 2);
+						}
+					}
+					if (len == 1)
+						_state = Base.StateUpdateShortRep(_state);
+					else
+					{
+						_repMatchLenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
+						_state = Base.StateUpdateRep(_state);
+					}
+					int distance = _repDistances[pos];
+					if (pos != 0)
+					{
+						for (int i = pos; i &gt;= 1; i--)
+							_repDistances[i] = _repDistances[i - 1];
+						_repDistances[0] = distance;
+					}
+				}
+				else
+				{
+					_rangeEncoder.Encode(_isRep, _state, 0);
+					_state = Base.StateUpdateMatch(_state);
+					_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
+					pos -= Base.kNumRepDistances;
+					int posSlot = GetPosSlot(pos);
+					int lenToPosState = Base.GetLenToPosState(len);
+					_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);
+
+					if (posSlot &gt;= Base.kStartPosModelIndex)
+					{
+						int footerBits = (int)((posSlot &gt;&gt; 1) - 1);
+						int baseVal = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+						int posReduced = pos - baseVal;
+
+						if (posSlot &lt; Base.kEndPosModelIndex)
+							BitTreeEncoder.ReverseEncode(_posEncoders,
+									baseVal - posSlot - 1, _rangeEncoder, footerBits, posReduced);
+						else
+						{
+							_rangeEncoder.EncodeDirectBits(posReduced &gt;&gt; Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
+							_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced &amp; Base.kAlignMask);
+							_alignPriceCount++;
+						}
+					}
+					int distance = pos;
+					for (int i = Base.kNumRepDistances - 1; i &gt;= 1; i--)
+						_repDistances[i] = _repDistances[i - 1];
+					_repDistances[0] = distance;
+					_matchPriceCount++;
+				}
+				_previousByte = _matchFinder.GetIndexByte(len - 1 - _additionalOffset);
+			}
+			_additionalOffset -= len;
+			nowPos64 += len;
+			if (_additionalOffset == 0)
+			{
+				// if (!_fastMode)
+				if (_matchPriceCount &gt;= (1 &lt;&lt; 7))
+					FillDistancesPrices();
+				if (_alignPriceCount &gt;= Base.kAlignTableSize)
+					FillAlignPrices();
+				inSize[0] = nowPos64;
+				outSize[0] = _rangeEncoder.GetProcessedSizeAdd();
+				if (_matchFinder.GetNumAvailableBytes() == 0)
+				{
+					Flush((int)nowPos64);
+					return;
+				}
+
+				if (nowPos64 - progressPosValuePrev &gt;= (1 &lt;&lt; 12))
+				{
+					_finished = false;
+					finished[0] = false;
+					return;
+				}
+			}
+		}
+	}
+
+	void ReleaseMFStream()
+	{
+		if (_matchFinder != null &amp;&amp; _needReleaseMFStream)
+		{
+			_matchFinder.ReleaseStream();
+			_needReleaseMFStream = false;
+		}
+	}
+
+	void SetOutStream(java.io.OutputStream outStream)
+	{ _rangeEncoder.SetStream(outStream); }
+	void ReleaseOutStream()
+	{ _rangeEncoder.ReleaseStream(); }
+
+	void ReleaseStreams()
+	{
+		ReleaseMFStream();
+		ReleaseOutStream();
+	}
+
+	void SetStreams(java.io.InputStream inStream, java.io.OutputStream outStream,
+			long inSize, long outSize)
+	{
+		_inStream = inStream;
+		_finished = false;
+		Create();
+		SetOutStream(outStream);
+		Init();
+
+		// if (!_fastMode)
+		{
+			FillDistancesPrices();
+			FillAlignPrices();
+		}
+
+		_lenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
+		_lenEncoder.UpdateTables(1 &lt;&lt; _posStateBits);
+		_repMatchLenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
+		_repMatchLenEncoder.UpdateTables(1 &lt;&lt; _posStateBits);
+
+		nowPos64 = 0;
+	}
+
+	long[] processedInSize = new long[1]; long[] processedOutSize = new long[1]; boolean[] finished = new boolean[1];
+	public void Code(java.io.InputStream inStream, java.io.OutputStream outStream,
+			long inSize, long outSize, ICodeProgress progress) throws IOException
+	{
+		_needReleaseMFStream = false;
+		try
+		{
+			SetStreams(inStream, outStream, inSize, outSize);
+			while (true)
+			{
+
+
+
+				CodeOneBlock(processedInSize, processedOutSize, finished);
+				if (finished[0])
+					return;
+				if (progress != null)
+				{
+					progress.SetProgress(processedInSize[0], processedOutSize[0]);
+				}
+			}
+		}
+		finally
+		{
+			ReleaseStreams();
+		}
+	}
+
+	public static final int kPropSize = 5;
+	byte[] properties = new byte[kPropSize];
+
+	public void WriteCoderProperties(java.io.OutputStream outStream) throws IOException
+	{
+		properties[0] = (byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
+		for (int i = 0; i &lt; 4; i++)
+			properties[1 + i] = (byte)(_dictionarySize &gt;&gt; (8 * i));
+		outStream.write(properties, 0, kPropSize);
+	}
+
+	int[] tempPrices = new int[Base.kNumFullDistances];
+	int _matchPriceCount;
+
+	void FillDistancesPrices()
+	{
+		for (int i = Base.kStartPosModelIndex; i &lt; Base.kNumFullDistances; i++)
+		{
+			int posSlot = GetPosSlot(i);
+			int footerBits = (int)((posSlot &gt;&gt; 1) - 1);
+			int baseVal = ((2 | (posSlot &amp; 1)) &lt;&lt; footerBits);
+			tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders,
+				baseVal - posSlot - 1, footerBits, i - baseVal);
+		}
+
+		for (int lenToPosState = 0; lenToPosState &lt; Base.kNumLenToPosStates; lenToPosState++)
+		{
+			int posSlot;
+			BitTreeEncoder encoder = _posSlotEncoder[lenToPosState];
+
+			int st = (lenToPosState &lt;&lt; Base.kNumPosSlotBits);
+			for (posSlot = 0; posSlot &lt; _distTableSize; posSlot++)
+				_posSlotPrices[st + posSlot] = encoder.GetPrice(posSlot);
+			for (posSlot = Base.kEndPosModelIndex; posSlot &lt; _distTableSize; posSlot++)
+				_posSlotPrices[st + posSlot] += ((((posSlot &gt;&gt; 1) - 1) - Base.kNumAlignBits) &lt;&lt; SevenZip.Compression.RangeCoder.Encoder.kNumBitPriceShiftBits);
+
+			int st2 = lenToPosState * Base.kNumFullDistances;
+			int i;
+			for (i = 0; i &lt; Base.kStartPosModelIndex; i++)
+				_distancesPrices[st2 + i] = _posSlotPrices[st + i];
+			for (; i &lt; Base.kNumFullDistances; i++)
+				_distancesPrices[st2 + i] = _posSlotPrices[st + GetPosSlot(i)] + tempPrices[i];
+		}
+		_matchPriceCount = 0;
+	}
+
+	void FillAlignPrices()
+	{
+		for (int i = 0; i &lt; Base.kAlignTableSize; i++)
+			_alignPrices[i] = _posAlignEncoder.ReverseGetPrice(i);
+		_alignPriceCount = 0;
+	}
+
+
+	public boolean SetAlgorithm(int algorithm)
+	{
+		/*
+		_fastMode = (algorithm == 0);
+		_maxMode = (algorithm &gt;= 2);
+		*/
+		return true;
+	}
+
+	public boolean SetDictionarySize(int dictionarySize)
+	{
+		int kDicLogSizeMaxCompress = 29;
+		if (dictionarySize &lt; (1 &lt;&lt; Base.kDicLogSizeMin) || dictionarySize &gt; (1 &lt;&lt; kDicLogSizeMaxCompress))
+			return false;
+		_dictionarySize = dictionarySize;
+		int dicLogSize;
+		for (dicLogSize = 0; dictionarySize &gt; (1 &lt;&lt; dicLogSize); dicLogSize++) ;
+		_distTableSize = dicLogSize * 2;
+		return true;
+	}
+
+	public boolean SeNumFastBytes(int numFastBytes)
+	{
+		if (numFastBytes &lt; 5 || numFastBytes &gt; Base.kMatchMaxLen)
+			return false;
+		_numFastBytes = numFastBytes;
+		return true;
+	}
+
+	public boolean SetMatchFinder(int matchFinderIndex)
+	{
+		if (matchFinderIndex &lt; 0 || matchFinderIndex &gt; 2)
+			return false;
+		int matchFinderIndexPrev = _matchFinderType;
+		_matchFinderType = matchFinderIndex;
+		if (_matchFinder != null &amp;&amp; matchFinderIndexPrev != _matchFinderType)
+		{
+			_dictionarySizePrev = -1;
+			_matchFinder = null;
+		}
+		return true;
+	}
+
+	public boolean SetLcLpPb(int lc, int lp, int pb)
+	{
+		if (
+				lp &lt; 0 || lp &gt; Base.kNumLitPosStatesBitsEncodingMax ||
+				lc &lt; 0 || lc &gt; Base.kNumLitContextBitsMax ||
+				pb &lt; 0 || pb &gt; Base.kNumPosStatesBitsEncodingMax)
+			return false;
+		_numLiteralPosStateBits = lp;
+		_numLiteralContextBits = lc;
+		_posStateBits = pb;
+		_posStateMask = ((1) &lt;&lt; _posStateBits) - 1;
+		return true;
+	}
+
+	public void SetEndMarkerMode(boolean endMarkerMode)
+	{
+		_writeEndMark = endMarkerMode;
+	}
+}
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/LZMA/Encoder.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeDecoder.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeDecoder.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeDecoder.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,55 @@
+package SevenZip.Compression.RangeCoder;
+
+public class BitTreeDecoder
+{
+	short[] Models;
+	int NumBitLevels;
+	
+	public BitTreeDecoder(int numBitLevels)
+	{
+		NumBitLevels = numBitLevels;
+		Models = new short[1 &lt;&lt; numBitLevels];
+	}
+	
+	public void Init()
+	{
+		Decoder.InitBitModels(Models);
+	}
+	
+	public int Decode(Decoder rangeDecoder) throws java.io.IOException
+	{
+		int m = 1;
+		for (int bitIndex = NumBitLevels; bitIndex != 0; bitIndex--)
+			m = (m &lt;&lt; 1) + rangeDecoder.DecodeBit(Models, m);
+		return m - (1 &lt;&lt; NumBitLevels);
+	}
+	
+	public int ReverseDecode(Decoder rangeDecoder) throws java.io.IOException
+	{
+		int m = 1;
+		int symbol = 0;
+		for (int bitIndex = 0; bitIndex &lt; NumBitLevels; bitIndex++)
+		{
+			int bit = rangeDecoder.DecodeBit(Models, m);
+			m &lt;&lt;= 1;
+			m += bit;
+			symbol |= (bit &lt;&lt; bitIndex);
+		}
+		return symbol;
+	}
+	
+	public static int ReverseDecode(short[] Models, int startIndex,
+			Decoder rangeDecoder, int NumBitLevels) throws java.io.IOException
+	{
+		int m = 1;
+		int symbol = 0;
+		for (int bitIndex = 0; bitIndex &lt; NumBitLevels; bitIndex++)
+		{
+			int bit = rangeDecoder.DecodeBit(Models, startIndex + m);
+			m &lt;&lt;= 1;
+			m += bit;
+			symbol |= (bit &lt;&lt; bitIndex);
+		}
+		return symbol;
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeDecoder.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeEncoder.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeEncoder.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeEncoder.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,99 @@
+package SevenZip.Compression.RangeCoder;
+import java.io.IOException;
+
+public class BitTreeEncoder
+{
+	short[] Models;
+	int NumBitLevels;
+	
+	public BitTreeEncoder(int numBitLevels)
+	{
+		NumBitLevels = numBitLevels;
+		Models = new short[1 &lt;&lt; numBitLevels];
+	}
+	
+	public void Init()
+	{
+		Decoder.InitBitModels(Models);
+	}
+	
+	public void Encode(Encoder rangeEncoder, int symbol) throws IOException
+	{
+		int m = 1;
+		for (int bitIndex = NumBitLevels; bitIndex != 0; )
+		{
+			bitIndex--;
+			int bit = (symbol &gt;&gt;&gt; bitIndex) &amp; 1;
+			rangeEncoder.Encode(Models, m, bit);
+			m = (m &lt;&lt; 1) | bit;
+		}
+	}
+	
+	public void ReverseEncode(Encoder rangeEncoder, int symbol) throws IOException
+	{
+		int m = 1;
+		for (int  i = 0; i &lt; NumBitLevels; i++)
+		{
+			int bit = symbol &amp; 1;
+			rangeEncoder.Encode(Models, m, bit);
+			m = (m &lt;&lt; 1) | bit;
+			symbol &gt;&gt;= 1;
+		}
+	}
+	
+	public int GetPrice(int symbol)
+	{
+		int price = 0;
+		int m = 1;
+		for (int bitIndex = NumBitLevels; bitIndex != 0; )
+		{
+			bitIndex--;
+			int bit = (symbol &gt;&gt;&gt; bitIndex) &amp; 1;
+			price += Encoder.GetPrice(Models[m], bit);
+			m = (m &lt;&lt; 1) + bit;
+		}
+		return price;
+	}
+	
+	public int ReverseGetPrice(int symbol)
+	{
+		int price = 0;
+		int m = 1;
+		for (int i = NumBitLevels; i != 0; i--)
+		{
+			int bit = symbol &amp; 1;
+			symbol &gt;&gt;&gt;= 1;
+			price += Encoder.GetPrice(Models[m], bit);
+			m = (m &lt;&lt; 1) | bit;
+		}
+		return price;
+	}
+	
+	public static int ReverseGetPrice(short[] Models, int startIndex,
+			int NumBitLevels, int symbol)
+	{
+		int price = 0;
+		int m = 1;
+		for (int i = NumBitLevels; i != 0; i--)
+		{
+			int bit = symbol &amp; 1;
+			symbol &gt;&gt;&gt;= 1;
+			price += Encoder.GetPrice(Models[startIndex + m], bit);
+			m = (m &lt;&lt; 1) | bit;
+		}
+		return price;
+	}
+	
+	public static void ReverseEncode(short[] Models, int startIndex,
+			Encoder rangeEncoder, int NumBitLevels, int symbol) throws IOException
+	{
+		int m = 1;
+		for (int i = 0; i &lt; NumBitLevels; i++)
+		{
+			int bit = symbol &amp; 1;
+			rangeEncoder.Encode(Models, startIndex + m, bit);
+			m = (m &lt;&lt; 1) | bit;
+			symbol &gt;&gt;= 1;
+		}
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/BitTreeEncoder.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Decoder.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Decoder.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Decoder.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,88 @@
+package SevenZip.Compression.RangeCoder;
+import java.io.IOException;
+
+public class Decoder
+{
+	static final int kTopMask = ~((1 &lt;&lt; 24) - 1);
+	
+	static final int kNumBitModelTotalBits = 11;
+	static final int kBitModelTotal = (1 &lt;&lt; kNumBitModelTotalBits);
+	static final int kNumMoveBits = 5;
+	
+	int Range;
+	int Code;
+
+	java.io.InputStream Stream;
+	
+	public final void SetStream(java.io.InputStream stream)
+	{ 
+		Stream = stream; 
+	}
+	
+	public final void ReleaseStream()
+	{ 
+		Stream = null; 
+	}
+	
+	public final void Init() throws IOException
+	{
+		Code = 0;
+		Range = -1;
+		for (int i = 0; i &lt; 5; i++)
+			Code = (Code &lt;&lt; 8) | Stream.read();
+	}
+	
+	public final int DecodeDirectBits(int numTotalBits) throws IOException
+	{
+		int result = 0;
+		for (int i = numTotalBits; i != 0; i--)
+		{
+			Range &gt;&gt;&gt;= 1;
+			int t = ((Code - Range) &gt;&gt;&gt; 31);
+			Code -= Range &amp; (t - 1);
+			result = (result &lt;&lt; 1) | (1 - t);
+			
+			if ((Range &amp; kTopMask) == 0)
+			{
+				Code = (Code &lt;&lt; 8) | Stream.read();
+				Range &lt;&lt;= 8;
+			}
+		}
+		return result;
+	}
+	
+	public int DecodeBit(short []probs, int index) throws IOException
+	{
+		int prob = probs[index];
+		int newBound = (Range &gt;&gt;&gt; kNumBitModelTotalBits) * prob;
+		if ((Code ^ 0x80000000) &lt; (newBound ^ 0x80000000))
+		{
+			Range = newBound;
+			probs[index] = (short)(prob + ((kBitModelTotal - prob) &gt;&gt;&gt; kNumMoveBits));
+			if ((Range &amp; kTopMask) == 0)
+			{
+				Code = (Code &lt;&lt; 8) | Stream.read();
+				Range &lt;&lt;= 8;
+			}
+			return 0;
+		}
+		else
+		{
+			Range -= newBound;
+			Code -= newBound;
+			probs[index] = (short)(prob - ((prob) &gt;&gt;&gt; kNumMoveBits));
+			if ((Range &amp; kTopMask) == 0)
+			{
+				Code = (Code &lt;&lt; 8) | Stream.read();
+				Range &lt;&lt;= 8;
+			}
+			return 1;
+		}
+	}
+	
+	public static void InitBitModels(short []probs)
+	{
+		for (int i = 0; i &lt; probs.length; i++)
+			probs[i] = (kBitModelTotal &gt;&gt;&gt; 1);
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Decoder.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Encoder.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Encoder.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Encoder.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,151 @@
+package SevenZip.Compression.RangeCoder;
+import java.io.IOException;
+
+public class Encoder
+{
+	static final int kTopMask = ~((1 &lt;&lt; 24) - 1);
+	
+	static final int kNumBitModelTotalBits = 11;
+	static final int kBitModelTotal = (1 &lt;&lt; kNumBitModelTotalBits);
+	static final int kNumMoveBits = 5;
+	
+	java.io.OutputStream Stream;
+
+	long Low;
+	int Range;
+	int _cacheSize;
+	int _cache;
+	
+	long _position;
+	
+	public void SetStream(java.io.OutputStream stream)
+	{
+		Stream = stream;
+	}
+	
+	public void ReleaseStream()
+	{
+		Stream = null;
+	}
+	
+	public void Init()
+	{
+		_position = 0;
+		Low = 0;
+		Range = -1;
+		_cacheSize = 1;
+		_cache = 0;
+	}
+	
+	public void FlushData() throws IOException
+	{
+		for (int i = 0; i &lt; 5; i++)
+			ShiftLow();
+	}
+	
+	public void FlushStream() throws IOException
+	{
+		Stream.flush();
+	}
+	
+	public void ShiftLow() throws IOException
+	{
+		int LowHi = (int)(Low &gt;&gt;&gt; 32);
+		if (LowHi != 0 || Low &lt; 0xFF000000L)
+		{
+			_position += _cacheSize;
+			int temp = _cache;
+			do
+			{
+				Stream.write(temp + LowHi);
+				temp = 0xFF;
+			}
+			while(--_cacheSize != 0);
+			_cache = (((int)Low) &gt;&gt;&gt; 24);
+		}
+		_cacheSize++;
+		Low = (Low &amp; 0xFFFFFF) &lt;&lt; 8;
+	}
+	
+	public void EncodeDirectBits(int v, int numTotalBits) throws IOException
+	{
+		for (int i = numTotalBits - 1; i &gt;= 0; i--)
+		{
+			Range &gt;&gt;&gt;= 1;
+			if (((v &gt;&gt;&gt; i) &amp; 1) == 1)
+				Low += Range;
+			if ((Range &amp; Encoder.kTopMask) == 0)
+			{
+				Range &lt;&lt;= 8;
+				ShiftLow();
+			}
+		}
+	}
+	
+	
+	public long GetProcessedSizeAdd()
+	{
+		return _cacheSize + _position + 4;
+	}
+	
+	
+	
+	static final int kNumMoveReducingBits = 2;
+	public static final int kNumBitPriceShiftBits = 6;
+	
+	public static void InitBitModels(short []probs)
+	{
+		for (int i = 0; i &lt; probs.length; i++)
+			probs[i] = (kBitModelTotal &gt;&gt;&gt; 1);
+	}
+	
+	public void Encode(short []probs, int index, int symbol) throws IOException
+	{
+		int prob = probs[index];
+		int newBound = (Range &gt;&gt;&gt; kNumBitModelTotalBits) * prob;
+		if (symbol == 0)
+		{
+			Range = newBound;
+			probs[index] = (short)(prob + ((kBitModelTotal - prob) &gt;&gt;&gt; kNumMoveBits));
+		}
+		else
+		{
+			Low += (newBound &amp; 0xFFFFFFFFL);
+			Range -= newBound;
+			probs[index] = (short)(prob - ((prob) &gt;&gt;&gt; kNumMoveBits));
+		}
+		if ((Range &amp; kTopMask) == 0)
+		{
+			Range &lt;&lt;= 8;
+			ShiftLow();
+		}
+	}
+	
+	private static int[] ProbPrices = new int[kBitModelTotal &gt;&gt;&gt; kNumMoveReducingBits];
+	
+	static
+	{
+		int kNumBits = (kNumBitModelTotalBits - kNumMoveReducingBits);
+		for (int i = kNumBits - 1; i &gt;= 0; i--)
+		{
+			int start = 1 &lt;&lt; (kNumBits - i - 1);
+			int end = 1 &lt;&lt; (kNumBits - i);
+			for (int j = start; j &lt; end; j++)
+				ProbPrices[j] = (i &lt;&lt; kNumBitPriceShiftBits) +
+						(((end - j) &lt;&lt; kNumBitPriceShiftBits) &gt;&gt;&gt; (kNumBits - i - 1));
+		}
+	}
+	
+	static public int GetPrice(int Prob, int symbol)
+	{
+		return ProbPrices[(((Prob - symbol) ^ ((-symbol))) &amp; (kBitModelTotal - 1)) &gt;&gt;&gt; kNumMoveReducingBits];
+	}
+	static public int GetPrice0(int Prob)
+	{ 
+		return ProbPrices[Prob &gt;&gt;&gt; kNumMoveReducingBits]; 
+	}
+	static public int GetPrice1(int Prob)
+	{ 
+		return ProbPrices[(kBitModelTotal - Prob) &gt;&gt;&gt; kNumMoveReducingBits]; 
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/Compression/RangeCoder/Encoder.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/ICodeProgress.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/ICodeProgress.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/ICodeProgress.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,6 @@
+package SevenZip;
+
+public interface ICodeProgress
+{
+	public void SetProgress(long inSize, long outSize);
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/ICodeProgress.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaAlone.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaAlone.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaAlone.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,253 @@
+package SevenZip;
+
+public class LzmaAlone
+{
+	static public class CommandLine
+	{
+		public static final int kEncode = 0;
+		public static final int kDecode = 1;
+		public static final int kBenchmak = 2;
+		
+		public int Command = -1;
+		public int NumBenchmarkPasses = 10;
+		
+		public int DictionarySize = 1 &lt;&lt; 23;
+		public boolean DictionarySizeIsDefined = false;
+		
+		public int Lc = 3;
+		public int Lp = 0;
+		public int Pb = 2;
+		
+		public int Fb = 128;
+		public boolean FbIsDefined = false;
+		
+		public boolean Eos = false;
+		
+		public int Algorithm = 2;
+		public int MatchFinder = 1;
+		
+		public String InFile;
+		public String OutFile;
+		
+		boolean ParseSwitch(String s)
+		{
+			if (s.startsWith(&quot;d&quot;))
+			{
+				DictionarySize = 1 &lt;&lt; Integer.parseInt(s.substring(1));
+				DictionarySizeIsDefined = true;
+			}
+			else if (s.startsWith(&quot;fb&quot;))
+			{
+				Fb = Integer.parseInt(s.substring(2));
+				FbIsDefined = true;
+			}
+			else if (s.startsWith(&quot;a&quot;))
+				Algorithm = Integer.parseInt(s.substring(1));
+			else if (s.startsWith(&quot;lc&quot;))
+				Lc = Integer.parseInt(s.substring(2));
+			else if (s.startsWith(&quot;lp&quot;))
+				Lp = Integer.parseInt(s.substring(2));
+			else if (s.startsWith(&quot;pb&quot;))
+				Pb = Integer.parseInt(s.substring(2));
+			else if (s.startsWith(&quot;eos&quot;))
+				Eos = true;
+			else if (s.startsWith(&quot;mf&quot;))
+			{
+				String mfs = s.substring(2);
+				if (mfs.equals(&quot;bt2&quot;))
+					MatchFinder = 0;
+				else if (mfs.equals(&quot;bt4&quot;))
+					MatchFinder = 1;
+				else if (mfs.equals(&quot;bt4b&quot;))
+					MatchFinder = 2;
+				else
+					return false;
+			}
+			else
+				return false;
+			return true;
+		}
+		
+		public boolean Parse(String[] args) throws Exception
+		{
+			int pos = 0;
+			boolean switchMode = true;
+			for (int i = 0; i &lt; args.length; i++)
+			{
+				String s = args[i];
+				if (s.length() == 0)
+					return false;
+				if (switchMode)
+				{
+					if (s.compareTo(&quot;--&quot;) == 0)
+					{
+						switchMode = false;
+						continue;
+					}
+					if (s.charAt(0) == '-')
+					{
+						String sw = s.substring(1).toLowerCase();
+						if (sw.length() == 0)
+							return false;
+						try
+						{
+							if (!ParseSwitch(sw))
+								return false;
+						}
+						catch (NumberFormatException e)
+						{
+							return false;
+						}
+						continue;
+					}
+				}
+				if (pos == 0)
+				{
+					if (s.equalsIgnoreCase(&quot;e&quot;))
+						Command = kEncode;
+					else if (s.equalsIgnoreCase(&quot;d&quot;))
+						Command = kDecode;
+					else if (s.equalsIgnoreCase(&quot;b&quot;))
+						Command = kBenchmak;
+					else
+						return false;
+				}
+				else if(pos == 1)
+				{
+					if (Command == kBenchmak)
+					{
+						try
+						{
+							NumBenchmarkPasses = Integer.parseInt(s);
+							if (NumBenchmarkPasses &lt; 1)
+								return false;
+						}
+						catch (NumberFormatException e)
+						{
+							return false;
+						}
+					}
+					else
+						InFile = s;
+				}
+				else if(pos == 2)
+					OutFile = s;
+				else
+					return false;
+				pos++;
+				continue;
+			}
+			return true;
+		}
+	}
+	
+	
+	static void PrintHelp()
+	{
+		System.out.println(
+				&quot;\nUsage:  LZMA &lt;e|d&gt; [&lt;switches&gt;...] inputFile outputFile\n&quot; +
+				&quot;  e: encode file\n&quot; +
+				&quot;  d: decode file\n&quot; +
+				&quot;  b: Benchmark\n&quot; +
+				&quot;&lt;Switches&gt;\n&quot; +
+				// &quot;  -a{N}:  set compression mode - [0, 1], default: 1 (max)\n&quot; +
+				&quot;  -d{N}:  set dictionary - [0,28], default: 23 (8MB)\n&quot; +
+				&quot;  -fb{N}: set number of fast bytes - [5, 273], default: 128\n&quot; +
+				&quot;  -lc{N}: set number of literal context bits - [0, 8], default: 3\n&quot; +
+				&quot;  -lp{N}: set number of literal pos bits - [0, 4], default: 0\n&quot; +
+				&quot;  -pb{N}: set number of pos bits - [0, 4], default: 2\n&quot; +
+				&quot;  -mf{MF_ID}: set Match Finder: [bt2, bt4], default: bt4\n&quot; +
+				&quot;  -eos:   write End Of Stream marker\n&quot;
+				);
+	}
+	
+	public static void main(String[] args) throws Exception
+	{
+		System.out.println(&quot;\nLZMA (Java) 4.42 Copyright (c) 1999-2006 Igor Pavlov  2006-05-15\n&quot;);
+		
+		if (args.length &lt; 1)
+		{
+			PrintHelp();
+			return;
+		}
+		
+		CommandLine params = new CommandLine();
+		if (!params.Parse(args))
+		{
+			System.out.println(&quot;\nIncorrect command&quot;);
+			return;
+		}
+		
+		if (params.Command == CommandLine.kBenchmak)
+		{
+			int dictionary = (1 &lt;&lt; 21);
+			if (params.DictionarySizeIsDefined)
+				dictionary = params.DictionarySize;
+			if (params.MatchFinder &gt; 1)
+				throw new Exception(&quot;Unsupported match finder&quot;);
+			SevenZip.LzmaBench.LzmaBenchmark(params.NumBenchmarkPasses, dictionary);
+		}
+		else if (params.Command == CommandLine.kEncode || params.Command == CommandLine.kDecode)
+		{
+			java.io.File inFile = new java.io.File(params.InFile);
+			java.io.File outFile = new java.io.File(params.OutFile);
+			
+			java.io.BufferedInputStream inStream  = new java.io.BufferedInputStream(new java.io.FileInputStream(inFile));
+			java.io.BufferedOutputStream outStream = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outFile));
+			
+			boolean eos = false;
+			if (params.Eos)
+				eos = true;
+			if (params.Command == CommandLine.kEncode)
+			{
+				SevenZip.Compression.LZMA.Encoder encoder = new SevenZip.Compression.LZMA.Encoder();
+				if (!encoder.SetAlgorithm(params.Algorithm))
+					throw new Exception(&quot;Incorrect compression mode&quot;);
+				if (!encoder.SetDictionarySize(params.DictionarySize))
+					throw new Exception(&quot;Incorrect dictionary size&quot;);
+				if (!encoder.SeNumFastBytes(params.Fb))
+					throw new Exception(&quot;Incorrect -fb value&quot;);
+				if (!encoder.SetMatchFinder(params.MatchFinder))
+					throw new Exception(&quot;Incorrect -mf value&quot;);
+				if (!encoder.SetLcLpPb(params.Lc, params.Lp, params.Pb))
+					throw new Exception(&quot;Incorrect -lc or -lp or -pb value&quot;);
+				encoder.SetEndMarkerMode(eos);
+				encoder.WriteCoderProperties(outStream);
+				long fileSize;
+				if (eos)
+					fileSize = -1;
+				else
+					fileSize = inFile.length();
+				for (int i = 0; i &lt; 8; i++)
+					outStream.write((int)(fileSize &gt;&gt;&gt; (8 * i)) &amp; 0xFF);
+				encoder.Code(inStream, outStream, -1, -1, null);
+			}
+			else
+			{
+				int propertiesSize = 5;
+				byte[] properties = new byte[propertiesSize];
+				if (inStream.read(properties, 0, propertiesSize) != propertiesSize)
+					throw new Exception(&quot;input .lzma file is too short&quot;);
+				SevenZip.Compression.LZMA.Decoder decoder = new SevenZip.Compression.LZMA.Decoder();
+				if (!decoder.SetDecoderProperties(properties))
+					throw new Exception(&quot;Incorrect stream properties&quot;);
+				long outSize = 0;
+				for (int i = 0; i &lt; 8; i++)
+				{
+					int v = inStream.read();
+					if (v &lt; 0)
+						throw new Exception(&quot;Can't read stream size&quot;);
+					outSize |= ((long)v) &lt;&lt; (8 * i);
+				}
+				if (!decoder.Code(inStream, outStream, outSize))
+					throw new Exception(&quot;Error in data stream&quot;);
+			}
+			outStream.flush();
+			outStream.close();
+			inStream.close();
+		}
+		else
+			throw new Exception(&quot;Incorrect command&quot;);
+		return;
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaAlone.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaBench.java
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaBench.java	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaBench.java	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,392 @@
+package SevenZip;
+
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+public class LzmaBench
+{
+	static final int kAdditionalSize = (1 &lt;&lt; 21);
+	static final int kCompressedAdditionalSize = (1 &lt;&lt; 10);
+	
+	static class CRandomGenerator
+	{
+		int A1;
+		int A2;
+		public CRandomGenerator() { Init(); }
+		public void Init() { A1 = 362436069; A2 = 521288629; }
+		public int GetRnd()
+		{
+			return
+				((A1 = 36969 * (A1 &amp; 0xffff) + (A1 &gt;&gt;&gt; 16)) &lt;&lt; 16) ^
+				((A2 = 18000 * (A2 &amp; 0xffff) + (A2 &gt;&gt;&gt; 16)));
+		}
+	};
+	
+	static class CBitRandomGenerator
+	{
+		CRandomGenerator RG = new CRandomGenerator();
+		int Value;
+		int NumBits;
+		public void Init()
+		{
+			Value = 0;
+			NumBits = 0;
+		}
+		public int GetRnd(int numBits)
+		{
+			int result;
+			if (NumBits &gt; numBits)
+			{
+				result = Value &amp; ((1 &lt;&lt; numBits) - 1);
+				Value &gt;&gt;&gt;= numBits;
+				NumBits -= numBits;
+				return result;
+			}
+			numBits -= NumBits;
+			result = (Value &lt;&lt; numBits);
+			Value = RG.GetRnd();
+			result |= Value &amp; (((int)1 &lt;&lt; numBits) - 1);
+			Value &gt;&gt;&gt;= numBits;
+			NumBits = 32 - numBits;
+			return result;
+		}
+	};
+	
+	static class CBenchRandomGenerator
+	{
+		CBitRandomGenerator RG = new CBitRandomGenerator();
+		int Pos;
+		int Rep0;
+
+		public int BufferSize;
+		public byte[] Buffer = null;
+
+		public CBenchRandomGenerator() { }
+		public void Set(int bufferSize)
+		{
+			Buffer = new byte[bufferSize];
+			Pos = 0;
+			BufferSize = bufferSize;
+		}
+		int GetRndBit() { return RG.GetRnd(1); }
+		int GetLogRandBits(int numBits)
+		{
+			int len = RG.GetRnd(numBits);
+			return RG.GetRnd((int)len);
+		}
+		int GetOffset()
+		{
+			if (GetRndBit() == 0)
+				return GetLogRandBits(4);
+			return (GetLogRandBits(4) &lt;&lt; 10) | RG.GetRnd(10);
+		}
+		int GetLen1() { return RG.GetRnd(1 + (int)RG.GetRnd(2)); }
+		int GetLen2() { return RG.GetRnd(2 + (int)RG.GetRnd(2)); }
+		public void Generate()
+		{
+			RG.Init();
+			Rep0 = 1;
+			while (Pos &lt; BufferSize)
+			{
+				if (GetRndBit() == 0 || Pos &lt; 1)
+					Buffer[Pos++] = (byte)(RG.GetRnd(8));
+				else
+				{
+					int len;
+					if (RG.GetRnd(3) == 0)
+						len = 1 + GetLen1();
+					else
+					{
+						do
+							Rep0 = GetOffset();
+						while (Rep0 &gt;= Pos);
+						Rep0++;
+						len = 2 + GetLen2();
+					}
+					for (int i = 0; i &lt; len &amp;&amp; Pos &lt; BufferSize; i++, Pos++)
+						Buffer[Pos] = Buffer[Pos - Rep0];
+				}
+			}
+		}
+	};
+	
+	static class CrcOutStream extends java.io.OutputStream
+	{
+		public CRC CRC = new CRC();
+		
+		public void Init()
+		{ 
+			CRC.Init(); 
+		}
+		public int GetDigest()
+		{ 
+			return CRC.GetDigest(); 
+		}
+		public void write(byte[] b)
+		{
+			CRC.Update(b);
+		}
+		public void write(byte[] b, int off, int len)
+		{
+			CRC.Update(b, off, len);
+		}
+		public void write(int b)
+		{
+			CRC.UpdateByte(b);
+		}
+	};
+
+	static class MyOutputStream extends java.io.OutputStream
+	{
+		byte[] _buffer;
+		int _size;
+		int _pos;
+		
+		public MyOutputStream(byte[] buffer)
+		{
+			_buffer = buffer;
+			_size = _buffer.length;
+		}
+		
+		public void reset()
+		{ 
+			_pos = 0; 
+		}
+		
+		public void write(int b) throws IOException
+		{
+			if (_pos &gt;= _size)
+				throw new IOException(&quot;Error&quot;);
+			_buffer[_pos++] = (byte)b;
+		}
+		
+		public int size()
+		{
+			return _pos;
+		}
+	};
+
+	static class MyInputStream extends java.io.InputStream
+	{
+		byte[] _buffer;
+		int _size;
+		int _pos;
+		
+		public MyInputStream(byte[] buffer, int size)
+		{
+			_buffer = buffer;
+			_size = size;
+		}
+		
+		public void reset()
+		{ 
+			_pos = 0; 
+		}
+		
+		public int read()
+		{
+			if (_pos &gt;= _size)
+				return -1;
+			return _buffer[_pos++] &amp; 0xFF;
+		}
+	};
+	
+	static class CProgressInfo implements ICodeProgress
+	{
+		public long ApprovedStart;
+		public long InSize;
+		public long Time;
+		public void Init()
+		{ InSize = 0; }
+		public void SetProgress(long inSize, long outSize)
+		{
+			if (inSize &gt;= ApprovedStart &amp;&amp; InSize == 0)
+			{
+				Time = System.currentTimeMillis();
+				InSize = inSize;
+			}
+		}
+	}
+	static final int kSubBits = 8;
+	
+	static int GetLogSize(int size)
+	{
+		for (int i = kSubBits; i &lt; 32; i++)
+			for (int j = 0; j &lt; (1 &lt;&lt; kSubBits); j++)
+				if (size &lt;= ((1) &lt;&lt; i) + (j &lt;&lt; (i - kSubBits)))
+					return (i &lt;&lt; kSubBits) + j;
+		return (32 &lt;&lt; kSubBits);
+	}
+	
+	static long MyMultDiv64(long value, long elapsedTime)
+	{
+		long freq = 1000; // ms
+		long elTime = elapsedTime;
+		while (freq &gt; 1000000)
+		{
+			freq &gt;&gt;&gt;= 1;
+			elTime &gt;&gt;&gt;= 1;
+		}
+		if (elTime == 0)
+			elTime = 1;
+		return value * freq / elTime;
+	}
+	
+	static long GetCompressRating(int dictionarySize, long elapsedTime, long size)
+	{
+		long t = GetLogSize(dictionarySize) - (18 &lt;&lt; kSubBits);
+		long numCommandsForOne = 1060 + ((t * t * 10) &gt;&gt; (2 * kSubBits));
+		long numCommands = (long)(size) * numCommandsForOne;
+		return MyMultDiv64(numCommands, elapsedTime);
+	}
+	
+	static long GetDecompressRating(long elapsedTime, long outSize, long inSize)
+	{
+		long numCommands = inSize * 220 + outSize * 20;
+		return MyMultDiv64(numCommands, elapsedTime);
+	}
+	
+	static long GetTotalRating(
+			int dictionarySize,
+			long elapsedTimeEn, long sizeEn,
+			long elapsedTimeDe,
+			long inSizeDe, long outSizeDe)
+	{
+		return (GetCompressRating(dictionarySize, elapsedTimeEn, sizeEn) +
+				GetDecompressRating(elapsedTimeDe, inSizeDe, outSizeDe)) / 2;
+	}
+	
+	static void PrintValue(long v)
+	{
+		String s = &quot;&quot;;
+		s += v;
+		for (int i = 0; i + s.length() &lt; 6; i++)
+			System.out.print(&quot; &quot;);
+		System.out.print(s);
+	}
+	
+	static void PrintRating(long rating)
+	{
+		PrintValue(rating / 1000000);
+		System.out.print(&quot; MIPS&quot;);
+	}
+	
+	static void PrintResults(
+			int dictionarySize,
+			long elapsedTime,
+			long size,
+			boolean decompressMode, long secondSize)
+	{
+		long speed = MyMultDiv64(size, elapsedTime);
+		PrintValue(speed / 1024);
+		System.out.print(&quot; KB/s  &quot;);
+		long rating;
+		if (decompressMode)
+			rating = GetDecompressRating(elapsedTime, size, secondSize);
+		else
+			rating = GetCompressRating(dictionarySize, elapsedTime, size);
+		PrintRating(rating);
+	}
+	
+	static public int LzmaBenchmark(int numIterations, int dictionarySize) throws Exception
+	{
+		if (numIterations &lt;= 0)
+			return 0;
+		if (dictionarySize &lt; (1 &lt;&lt; 18))
+		{
+			System.out.println(&quot;\nError: dictionary size for benchmark must be &gt;= 18 (256 KB)&quot;);
+			return 1;
+		}
+		System.out.print(&quot;\n       Compressing                Decompressing\n\n&quot;);
+		
+		SevenZip.Compression.LZMA.Encoder encoder = new SevenZip.Compression.LZMA.Encoder();
+		SevenZip.Compression.LZMA.Decoder decoder = new SevenZip.Compression.LZMA.Decoder();
+		
+		if (!encoder.SetDictionarySize(dictionarySize))
+			throw new Exception(&quot;Incorrect dictionary size&quot;);
+		
+		int kBufferSize = dictionarySize + kAdditionalSize;
+		int kCompressedBufferSize = (kBufferSize / 2) + kCompressedAdditionalSize;
+		
+		ByteArrayOutputStream propStream = new ByteArrayOutputStream();
+		encoder.WriteCoderProperties(propStream);
+		byte[] propArray = propStream.toByteArray();
+		decoder.SetDecoderProperties(propArray);
+		
+		CBenchRandomGenerator rg = new CBenchRandomGenerator();
+
+		rg.Set(kBufferSize);
+		rg.Generate();
+		CRC crc = new CRC();
+		crc.Init();
+		crc.Update(rg.Buffer, 0, rg.BufferSize);
+		
+		CProgressInfo progressInfo = new CProgressInfo();
+		progressInfo.ApprovedStart = dictionarySize;
+		
+		long totalBenchSize = 0;
+		long totalEncodeTime = 0;
+		long totalDecodeTime = 0;
+		long totalCompressedSize = 0;
+		
+		MyInputStream inStream = new MyInputStream(rg.Buffer, rg.BufferSize);
+
+		byte[] compressedBuffer = new byte[kCompressedBufferSize];
+		MyOutputStream compressedStream = new MyOutputStream(compressedBuffer);
+		CrcOutStream crcOutStream = new CrcOutStream();
+		MyInputStream inputCompressedStream = null;
+		int compressedSize = 0;
+		for (int i = 0; i &lt; numIterations; i++)
+		{
+			progressInfo.Init();
+			inStream.reset();
+			compressedStream.reset();
+			encoder.Code(inStream, compressedStream, -1, -1, progressInfo);
+			long encodeTime = System.currentTimeMillis() - progressInfo.Time;
+			
+			if (i == 0)
+			{
+				compressedSize = compressedStream.size();
+				inputCompressedStream = new MyInputStream(compressedBuffer, compressedSize);
+			}
+			else if (compressedSize != compressedStream.size())
+				throw (new Exception(&quot;Encoding error&quot;));
+				
+			if (progressInfo.InSize == 0)
+				throw (new Exception(&quot;Internal ERROR 1282&quot;));
+
+			long decodeTime = 0;
+			for (int j = 0; j &lt; 2; j++)
+			{
+				inputCompressedStream.reset();
+				crcOutStream.Init();
+				
+				long outSize = kBufferSize;
+				long startTime = System.currentTimeMillis();
+				if (!decoder.Code(inputCompressedStream, crcOutStream, outSize))
+					throw (new Exception(&quot;Decoding Error&quot;));;
+				decodeTime = System.currentTimeMillis() - startTime;
+				if (crcOutStream.GetDigest() != crc.GetDigest())
+					throw (new Exception(&quot;CRC Error&quot;));
+			}
+			long benchSize = kBufferSize - (long)progressInfo.InSize;
+			PrintResults(dictionarySize, encodeTime, benchSize, false, 0);
+			System.out.print(&quot;     &quot;);
+			PrintResults(dictionarySize, decodeTime, kBufferSize, true, compressedSize);
+			System.out.println();
+			
+			totalBenchSize += benchSize;
+			totalEncodeTime += encodeTime;
+			totalDecodeTime += decodeTime;
+			totalCompressedSize += compressedSize;
+		}
+		System.out.println(&quot;---------------------------------------------------&quot;);
+		PrintResults(dictionarySize, totalEncodeTime, totalBenchSize, false, 0);
+		System.out.print(&quot;     &quot;);
+		PrintResults(dictionarySize, totalDecodeTime,
+				kBufferSize * (long)numIterations, true, totalCompressedSize);
+		System.out.println(&quot;    Average&quot;);
+		return 0;
+	}
+}


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Java/SevenZip/LzmaBench.java
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/LGPL.txt
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/LGPL.txt	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/LGPL.txt	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,504 @@
+      GNU LESSER GENERAL PUBLIC LICENSE
+           Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+          Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the &quot;Lesser&quot; General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+&quot;work based on the library&quot; and a &quot;work that uses the library&quot;.  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+      GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called &quot;this License&quot;).
+Each licensee is addressed as &quot;you&quot;.
+
+  A &quot;library&quot; means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The &quot;Library&quot;, below, refers to any such software library or work
+which has been distributed under these terms.  A &quot;work based on the
+Library&quot; means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term &quot;modification&quot;.)
+
+  &quot;Source code&quot; for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a &quot;work that uses the Library&quot;.  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a &quot;work that uses the Library&quot; with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a &quot;work that uses the
+library&quot;.  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a &quot;work that uses the Library&quot; uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a &quot;work that uses the Library&quot; with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable &quot;work that
+    uses the Library&quot;, as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the &quot;work that uses the
+Library&quot; must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+&quot;any later version&quot;, you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+          NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY &quot;AS IS&quot; WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+         END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+&quot;copyright&quot; line and a pointer to where the full notice is found.
+
+    &lt;one line to give the library's name and a brief idea of what it does.&gt;
+    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a &quot;copyright disclaimer&quot; for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  &lt;signature of Ty Coon&gt;, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/LGPL.txt
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/Methods.txt
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/Methods.txt	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/Methods.txt	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,138 @@
+Compression method IDs (4.38)
+-----------------------------
+
+Each compression method in 7z has unique binary value (ID).
+The length of ID in bytes is arbitrary but it can not exceed 15 bytes.
+
+If you want to add some new ID, you have two ways:
+1) Write request for allocating IDs to 7-zip developers.
+2) Use such random ID:
+  03 E0  ZZ ... ZZ  MM ... MM  VV ... VV
+
+    ZZ != 0, MM != 0, VV != 0
+
+    03 E0      - Prefix for random IDs 
+    ZZ ... ZZ  - Developer ID. (length &gt;= 4). Use real random bytes.
+                 You can notify 7-Zip developers about your Developer ID.
+    MM ... MM  - Method ID (length &gt;= 1)
+    VV ... VV  - Version  (length &gt;= 1)
+
+    Note: Use new ID (MM ... MM  VV .. VV) only if old codec can not decode 
+    data encoded with new version.
+
+
+List of defined IDs
+-------------------
+      
+00 - Copy
+01 - Reserved
+02 - Common
+   03 Swap
+      - 2 Swap2
+      - 4 Swap4
+   04 Delta (subject to change)
+
+03 - 7z
+   01 - LZMA
+      01 - Version
+  
+   03 - Branch
+      01 - x86
+         03  - BCJ
+         1B  - BCJ2
+      02 - PPC
+         05 - BC_PPC_B (Big Endian)
+      03 - Alpha
+         01 - BC_Alpha
+      04 - IA64
+         01 - BC_IA64
+      05 - ARM
+         01 - BC_ARM
+      06 - M68
+         05 - BC_M68_B (Big Endian)
+      07 - ARM Thumb
+         01 - BC_ARMThumb
+      08 - SPARC
+         05 - BC_SPARC
+
+   04 - PPMD
+      01 - Version
+
+   80 - reserved for independent developers
+
+   E0 - Random IDs
+
+04 - Misc
+   00 - Reserved
+   01 - Zip
+      00 - Copy (not used). Use {00} instead
+      01 - Shrink
+      06 - Implode
+      08 - Deflate
+      09 - Deflate64
+      12 - BZip2 (not used). Use {04 02 02} instead
+   02 - BZip
+      02 - BZip2
+   03 - Rar
+      01 - Rar15
+      02 - Rar20
+      03 - Rar29
+   04 - Arj
+      01 - Arj (1,2,3)
+      02 - Arj 4
+   05 - Z
+   06 - Lzh
+   07 - Reserved for 7z
+   08 - Cab
+   09 - NSIS
+      01 - DeflateNSIS
+      02 - BZip2NSIS
+
+
+06 - Crypto 
+   00 - 
+   01 - AES
+      0x - AES-128
+      4x - AES-192
+      8x - AES-256
+
+      x0 - ECB
+      x1 - CBC
+      x2 - CFB
+      x3 - OFB
+
+   07 - Reserved
+   0F - Reserved
+
+   F0 - Misc Ciphers (Real Ciphers without hashing algo)
+
+   F1 - Misc Ciphers (Combine)
+      01 - Zip
+         01 - Main Zip crypto algo
+      03 - RAR
+         02 - 
+         03 - Rar29 AES-128 + (modified SHA-1)
+      07 - 7z
+         01 - AES-256 + SHA-256
+
+07 - Hash (subject to change)
+   00 - 
+   01 - CRC
+   02 - SHA-1
+   03 - SHA-256
+   04 - SHA-384
+   05 - SHA-512
+
+   F0 - Misc Hash
+
+   F1 - Misc
+      03 - RAR
+         03 - Rar29 Password Hashing (modified SHA1)
+      07 - 7z 
+         01 - SHA-256 Password Hashing
+    
+   
+
+
+---
+End of document


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/Methods.txt
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/history.txt
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/history.txt	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/history.txt	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,182 @@
+HISTORY of the LZMA SDK
+-----------------------
+
+  Version 4.43                2006-06-04
+  --------------------------------------
+    - Small changes for more compatibility with some C/C++ compilers.
+      
+
+  Version 4.42                2006-05-15
+  --------------------------------------
+    - Small changes in .h files in ANSI-C version.
+      
+
+  Version 4.39 beta           2006-04-14
+  --------------------------------------
+    - Bug in versions 4.33b:4.38b was fixed:
+      C++ version of LZMA encoder could not correctly compress 
+      files larger than 2 GB with HC4 match finder (-mfhc4).
+      
+
+  Version 4.37 beta           2005-04-06
+  --------------------------------------
+    - Fixes in C++ code: code could no be compiled if _NO_EXCEPTIONS was defined. 
+
+  
+  Version 4.35 beta           2005-03-02
+  --------------------------------------
+    - Bug was fixed in C++ version of LZMA Decoder:
+       If encoded stream was corrupted, decoder could access memory 
+       outside of allocated range.
+
+  
+  Version 4.34 beta           2006-02-27
+  --------------------------------------
+    - Compressing speed and memory requirements for compressing were increased
+    - LZMA now can use only these match finders: HC4, BT2, BT3, BT4
+
+  
+  Version 4.32                2005-12-09
+  --------------------------------------
+    - Java version of LZMA SDK was included
+
+
+  Version 4.30                2005-11-20
+  --------------------------------------
+    - Compression ratio was improved in -a2 mode
+    - Speed optimizations for compressing in -a2 mode
+    - -fb switch now supports values up to 273
+    - Bug in 7z_C (7zIn.c) was fixed:
+      It used Alloc/Free functions from different memory pools.
+      So if program used two memory pools, it worked incorrectly.
+    - 7z_C: .7z format supporting was improved
+    - LZMA# SDK (C#.NET version) was included
+
+
+  Version 4.27 (Updated)      2005-09-21
+  --------------------------------------
+   - Some GUIDs/interfaces in C++ were changed.
+     IStream.h:
+       ISequentialInStream::Read now works as old ReadPart
+       ISequentialOutStream::Write now works as old WritePart
+
+  
+  Version 4.27                2005-08-07
+  --------------------------------------
+    - Bug in LzmaDecodeSize.c was fixed:
+       if _LZMA_IN_CB and _LZMA_OUT_READ were defined,
+       decompressing worked incorrectly.
+
+
+  Version 4.26                2005-08-05
+  --------------------------------------
+    - Fixes in 7z_C code and LzmaTest.c:
+      previous versions could work incorrectly,
+      if malloc(0) returns 0
+
+
+  Version 4.23                2005-06-29
+  --------------------------------------
+    - Small fixes in C++ code
+
+
+  Version 4.22                2005-06-10
+  --------------------------------------
+    - Small fixes
+
+
+  Version 4.21                2005-06-08
+  --------------------------------------
+    - Interfaces for ANSI-C LZMA Decoder (LzmaDecode.c) were changed
+    - New additional version of ANSI-C LZMA Decoder with zlib-like interface:
+        - LzmaStateDecode.h
+        - LzmaStateDecode.c
+        - LzmaStateTest.c
+    - ANSI-C LZMA Decoder now can decompress files larger than 4 GB
+
+  
+  Version 4.17                2005-04-18
+  --------------------------------------
+    - New example for RAM-&gt;RAM compressing/decompressing: 
+      LZMA + BCJ (filter for x86 code):
+        - LzmaRam.h
+        - LzmaRam.cpp
+        - LzmaRamDecode.h
+        - LzmaRamDecode.c
+        - -f86 switch for lzma.exe
+
+  
+  Version 4.16                2005-03-29
+  --------------------------------------
+    - Bug was fixed in LzmaDecode.c (ANSI-C LZMA Decoder): 
+       If _LZMA_OUT_READ was defined, and if encoded stream was corrupted,
+       decoder could access memory outside of allocated range.
+    - Speed optimization of ANSI-C LZMA Decoder (now it's about 20% faster).
+      Old version of LZMA Decoder now is in file LzmaDecodeSize.c. 
+      LzmaDecodeSize.c can provide slightly smaller code than LzmaDecode.c
+    - Small speed optimization in LZMA C++ code
+    - filter for SPARC's code was added
+    - Simplified version of .7z ANSI-C Decoder was included
+
+
+  Version 4.06                2004-09-05
+  --------------------------------------
+    - Bug in v4.05 was fixed:
+        LZMA-Encoder didn't release output stream in some cases.
+
+
+  Version 4.05                2004-08-25
+  --------------------------------------
+    - Source code of filters for x86, IA-64, ARM, ARM-Thumb 
+      and PowerPC code was included to SDK
+    - Some internal minor changes
+
+
+  Version 4.04                2004-07-28
+  --------------------------------------
+    - More compatibility with some C++ compilers
+
+
+  Version 4.03                2004-06-18
+  --------------------------------------
+    - &quot;Benchmark&quot; command was added. It measures compressing 
+      and decompressing speed and shows rating values. 
+      Also it checks hardware errors.
+
+
+  Version 4.02                2004-06-10
+  --------------------------------------
+    - C++ LZMA Encoder/Decoder code now is more portable
+      and it can be compiled by GCC on Linux.
+
+
+  Version 4.01                2004-02-15
+  --------------------------------------
+    - Some detection of data corruption was enabled.
+        LzmaDecode.c / RangeDecoderReadByte
+        .....
+        {
+          rd-&gt;ExtraBytes = 1;
+          return 0xFF;
+        }
+
+
+  Version 4.00                2004-02-13
+  --------------------------------------
+    - Original version of LZMA SDK
+
+
+
+HISTORY of the LZMA
+-------------------
+  2001-2006:  Improvements to LZMA compressing/decompressing code, 
+              keeping compatibility with original LZMA format
+  1996-2001:  Development of LZMA compression format
+
+  Some milestones:
+
+  2001-08-30: LZMA compression was added to 7-Zip
+  1999-01-02: First version of 7-Zip was released
+  
+
+End of document


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/history.txt
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Marvell/Src/uClinux-dist/lzma/lzma.exe
===================================================================
(Binary files differ)


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/lzma.exe
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Marvell/Src/uClinux-dist/lzma/lzma.txt
===================================================================
--- trunk/Marvell/Src/uClinux-dist/lzma/lzma.txt	2006-09-22 17:16:51 UTC (rev 353)
+++ trunk/Marvell/Src/uClinux-dist/lzma/lzma.txt	2006-09-22 17:40:29 UTC (rev 354)
@@ -0,0 +1,630 @@
+LZMA SDK 4.43
+-------------
+
+LZMA SDK   Copyright (C) 1999-2006 Igor Pavlov
+
+LZMA SDK provides the documentation, samples, header files, libraries, 
+and tools you need to develop applications that use LZMA compression.
+
+LZMA is default and general compression method of 7z format
+in 7-Zip compression program (www.7-zip.org). LZMA provides high 
+compression ratio and very fast decompression.
+
+LZMA is an improved version of famous LZ77 compression algorithm. 
+It was improved in way of maximum increasing of compression ratio,
+keeping high decompression speed and low memory requirements for 
+decompressing.
+
+
+
+LICENSE
+-------
+
+LZMA SDK is available under any of the following licenses:
+
+1) GNU Lesser General Public License (GNU LGPL)
+2) Common Public License (CPL)
+3) Simplified license for unmodified code (read SPECIAL EXCEPTION) 
+4) Proprietary license 
+
+It means that you can select one of these four options and follow rules of that license.
+
+
+1,2) GNU LGPL and CPL licenses are pretty similar and both these
+licenses are classified as 
+ - &quot;Free software licenses&quot; at <A HREF="http://www.gnu.org/">http://www.gnu.org/</A> 
+ - &quot;OSI-approved&quot; at <A HREF="http://www.opensource.org/">http://www.opensource.org/</A>
+
+
+3) SPECIAL EXCEPTION
+
+Igor Pavlov, as the author of this code, expressly permits you 
+to statically or dynamically link your code (or bind by name) 
+to the files from LZMA SDK without subjecting your linked 
+code to the terms of the CPL or GNU LGPL. 
+Any modifications or additions to files from LZMA SDK, however, 
+are subject to the GNU LGPL or CPL terms.
+
+SPECIAL EXCEPTION allows you to use LZMA SDK in applications with closed code, 
+while you keep LZMA SDK code unmodified.
+
+
+SPECIAL EXCEPTION #2: Igor Pavlov, as the author of this code, expressly permits 
+you to use this code under the same terms and conditions contained in the License 
+Agreement you have for any previous version of LZMA SDK developed by Igor Pavlov.
+
+SPECIAL EXCEPTION #2 allows owners of proprietary licenses to use latest version 
+of LZMA SDK as update for previous versions.
+
+
+SPECIAL EXCEPTION #3: Igor Pavlov, as the author of this code, expressly permits 
+you to use code of the following files: 
+BranchTypes.h, LzmaTypes.h, LzmaTest.c, LzmaStateTest.c, LzmaAlone.cpp, 
+LzmaAlone.cs, LzmaAlone.java
+as public domain code. 
+
+
+4) Proprietary license
+
+LZMA SDK also can be available under a proprietary license which 
+can include:
+
+1) Right to modify code without subjecting modified code to the 
+terms of the CPL or GNU LGPL
+2) Technical support for code
+
+To request such proprietary license or any additional consultations,
+send email message from that page:
+<A HREF="http://www.7-zip.org/support.html">http://www.7-zip.org/support.html</A>
+
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+You should have received a copy of the Common Public License
+along with this library.
+
+
+LZMA SDK Contents
+-----------------
+
+LZMA SDK includes:
+
+  - C++ source code of LZMA compressing and decompressing
+  - ANSI-C compatible source code for LZMA decompressing
+  - C# source code for LZMA compressing and decompressing
+  - Java source code for LZMA compressing and decompressing
+  - Compiled file-&gt;file LZMA compressing/decompressing program for Windows system
+
+ANSI-C LZMA decompression code was ported from original C++ sources to C.
+Also it was simplified and optimized for code size. 
+But it is fully compatible with LZMA from 7-Zip.
+
+
+UNIX/Linux version 
+------------------
+To compile C++ version of file-&gt;file LZMA, go to directory
+C/7zip/Compress/LZMA_Alone 
+and type &quot;make&quot; or &quot;make clean all&quot; to recompile all.
+
+In some UNIX/Linux versions you must compile LZMA with static libraries.
+To compile with static libraries, change string in makefile
+LIB = -lm
+to string  
+LIB = -lm -static
+
+
+Files
+---------------------
+C        - C / CPP source code
+CS       - C# source code
+Java     - Java source code
+lzma.txt - LZMA SDK description (this file)
+7zFormat.txt - 7z Format description
+7zC.txt  - 7z ANSI-C Decoder description (this file)
+methods.txt  - Compression method IDs for .7z
+LGPL.txt - GNU Lesser General Public License
+CPL.html - Common Public License
+lzma.exe - Compiled file-&gt;file LZMA encoder/decoder for Windows
+history.txt - history of the LZMA SDK
+
+
+Source code structure
+---------------------
+
+C  - C / CPP files
+  Common  - common files for C++ projects
+  Windows - common files for Windows related code
+  7zip    - files related to 7-Zip Project
+    Common   - common files for 7-Zip
+    Compress - files related to compression/decompression
+      LZ     - files related to LZ (Lempel-Ziv) compression algorithm
+        BinTree    - Binary Tree Match Finder for LZ algorithm
+        HashChain  - Hash Chain Match Finder for LZ algorithm
+        Patricia   - Patricia Match Finder for LZ algorithm
+      RangeCoder   - Range Coder (special code of compression/decompression)
+      LZMA         - LZMA compression/decompression on C++
+      LZMA_Alone   - file-&gt;file LZMA compression/decompression
+      LZMA_C       - ANSI-C compatible LZMA decompressor
+        LzmaDecode.h  - interface for LZMA decoding on ANSI-C
+        LzmaDecode.c      - LZMA decoding on ANSI-C (new fastest version)
+        LzmaDecodeSize.c  - LZMA decoding on ANSI-C (old size-optimized version)
+        LzmaTest.c        - test application that decodes LZMA encoded file
+        LzmaTypes.h       - basic types for LZMA Decoder
+        LzmaStateDecode.h - interface for LZMA decoding (State version)
+        LzmaStateDecode.c - LZMA decoding on ANSI-C (State version)
+        LzmaStateTest.c   - test application (State version)
+      Branch       - Filters for x86, IA-64, ARM, ARM-Thumb, PowerPC and SPARC code
+    Archive - files related to archiving
+      7z_C     - 7z ANSI-C Decoder
+
+CS - C# files
+  7zip
+    Common   - some common files for 7-Zip
+    Compress - files related to compression/decompression
+      LZ     - files related to LZ (Lempel-Ziv) compression algorithm
+      LZMA         - LZMA compression/decompression
+      LzmaAlone    - file-&gt;file LZMA compression/decompression
+      RangeCoder   - Range Coder (special code of compression/decompression)
+
+Java  - Java files
+  SevenZip
+    Compression    - files related to compression/decompression
+      LZ           - files related to LZ (Lempel-Ziv) compression algorithm
+      LZMA         - LZMA compression/decompression
+      RangeCoder   - Range Coder (special code of compression/decompression)
+
+C/C++ source code of LZMA SDK is part of 7-Zip project.
+
+You can find ANSI-C LZMA decompressing code at folder 
+  C/7zip/Compress/LZMA_C
+7-Zip doesn't use that ANSI-C LZMA code and that code was developed 
+specially for this SDK. And files from LZMA_C do not need files from 
+other directories of SDK for compiling.
+
+7-Zip source code can be downloaded from 7-Zip's SourceForge page:
+
+  <A HREF="http://sourceforge.net/projects/sevenzip/">http://sourceforge.net/projects/sevenzip/</A>
+
+
+LZMA features
+-------------
+  - Variable dictionary size (up to 1 GB)
+  - Estimated compressing speed: about 1 MB/s on 1 GHz CPU
+  - Estimated decompressing speed: 
+      - 8-12 MB/s on 1 GHz Intel Pentium 3 or AMD Athlon
+      - 500-1000 KB/s on 100 MHz ARM, MIPS, PowerPC or other simple RISC
+  - Small memory requirements for decompressing (8-32 KB + DictionarySize)
+  - Small code size for decompressing: 2-8 KB (depending from 
+    speed optimizations) 
+
+LZMA decoder uses only integer operations and can be 
+implemented in any modern 32-bit CPU (or on 16-bit CPU with some conditions).
+
+Some critical operations that affect to speed of LZMA decompression:
+  1) 32*16 bit integer multiply
+  2) Misspredicted branches (penalty mostly depends from pipeline length)
+  3) 32-bit shift and arithmetic operations
+
+Speed of LZMA decompressing mostly depends from CPU speed.
+Memory speed has no big meaning. But if your CPU has small data cache, 
+overall weight of memory speed will slightly increase.
+
+
+How To Use
+----------
+
+Using LZMA encoder/decoder executable
+--------------------------------------
+
+Usage:  LZMA &lt;e|d&gt; inputFile outputFile [&lt;switches&gt;...]
+
+  e: encode file
+
+  d: decode file
+
+  b: Benchmark. There are two tests: compressing and decompressing 
+     with LZMA method. Benchmark shows rating in MIPS (million 
+     instructions per second). Rating value is calculated from 
+     measured speed and it is normalized with AMD Athlon 64 X2 CPU
+     results. Also Benchmark checks possible hardware errors (RAM 
+     errors in most cases). Benchmark uses these settings:
+     (-a1, -d21, -fb32, -mfbt4). You can change only -d. Also you 
+     can change number of iterations. Example for 30 iterations:
+	LZMA b 30
+     Default number of iterations is 10.
+
+&lt;Switches&gt;
+  
+
+  -a{N}:  set compression mode 0 = fast, 1 = normal
+          default: 1 (normal)
+
+  d{N}:   Sets Dictionary size - [0, 30], default: 23 (8MB)
+          The maximum value for dictionary size is 1 GB = 2^30 bytes.
+          Dictionary size is calculated as DictionarySize = 2^N bytes. 
+          For decompressing file compressed by LZMA method with dictionary 
+          size D = 2^N you need about D bytes of memory (RAM).
+
+  -fb{N}: set number of fast bytes - [5, 273], default: 128
+          Usually big number gives a little bit better compression ratio 
+          and slower compression process.
+
+  -lc{N}: set number of literal context bits - [0, 8], default: 3
+          Sometimes lc=4 gives gain for big files.
+
+  -lp{N}: set number of literal pos bits - [0, 4], default: 0
+          lp switch is intended for periodical data when period is 
+          equal 2^N. For example, for 32-bit (4 bytes) 
+          periodical data you can use lp=2. Often it's better to set lc0, 
+          if you change lp switch.
+
+  -pb{N}: set number of pos bits - [0, 4], default: 2
+          pb switch is intended for periodical data 
+          when period is equal 2^N.
+
+  -mf{MF_ID}: set Match Finder. Default: bt4. 
+              Algorithms from hc* group doesn't provide good compression 
+              ratio, but they often works pretty fast in combination with 
+              fast mode (-a0).
+
+              Memory requirements depend from dictionary size 
+              (parameter &quot;d&quot; in table below). 
+
+               MF_ID     Memory                   Description
+
+                bt2    d *  9.5 + 4MB  Binary Tree with 2 bytes hashing.
+                bt3    d * 11.5 + 4MB  Binary Tree with 3 bytes hashing.
+                bt4    d * 11.5 + 4MB  Binary Tree with 4 bytes hashing.
+                hc4    d *  7.5 + 4MB  Hash Chain with 4 bytes hashing.
+
+  -eos:   write End Of Stream marker. By default LZMA doesn't write 
+          eos marker, since LZMA decoder knows uncompressed size 
+          stored in .lzma file header.
+
+  -si:    Read data from stdin (it will write End Of Stream marker).
+  -so:    Write data to stdout
+
+
+Examples:
+
+1) LZMA e file.bin file.lzma -d16 -lc0 
+
+compresses file.bin to file.lzma with 64 KB dictionary (2^16=64K)  
+and 0 literal context bits. -lc0 allows to reduce memory requirements 
+for decompression.
+
+
+2) LZMA e file.bin file.lzma -lc0 -lp2
+
+compresses file.bin to file.lzma with settings suitable 
+for 32-bit periodical data (for example, ARM or MIPS code).
+
+3) LZMA d file.lzma file.bin
+
+decompresses file.lzma to file.bin.
+
+
+Compression ratio hints
+-----------------------
+
+Recommendations
+---------------
+
+To increase compression ratio for LZMA compressing it's desirable 
+to have aligned data (if it's possible) and also it's desirable to locate
+data in such order, where code is grouped in one place and data is 
+grouped in other place (it's better than such mixing: code, data, code,
+data, ...).
+
+
+Using Filters
+-------------
+You can increase compression ratio for some data types, using
+special filters before compressing. For example, it's possible to 
+increase compression ratio on 5-10% for code for those CPU ISAs: 
+x86, IA-64, ARM, ARM-Thumb, PowerPC, SPARC.
+
+You can find C/C++ source code of such filters in folder &quot;7zip/Compress/Branch&quot;
+
+You can check compression ratio gain of these filters with such 
+7-Zip commands (example for ARM code):
+No filter:
+  7z a a1.7z a.bin -m0=lzma
+
+With filter for little-endian ARM code:
+  7z a a2.7z a.bin -m0=bc_arm -m1=lzma        
+
+With filter for big-endian ARM code (using additional Swap4 filter):
+  7z a a3.7z a.bin -m0=swap4 -m1=bc_arm -m2=lzma
+
+It works in such manner:
+Compressing    = Filter_encoding + LZMA_encoding
+Decompressing  = LZMA_decoding + Filter_decoding
+
+Compressing and decompressing speed of such filters is very high,
+so it will not increase decompressing time too much.
+Moreover, it reduces decompression time for LZMA_decoding, 
+since compression ratio with filtering is higher.
+
+These filters convert CALL (calling procedure) instructions 
+from relative offsets to absolute addresses, so such data becomes more 
+compressible. Source code of these CALL filters is pretty simple
+(about 20 lines of C++), so you can convert it from C++ version yourself.
+
+For some ISAs (for example, for MIPS) it's impossible to get gain from such filter.
+
+
+LZMA compressed file format
+---------------------------
+Offset Size Description
+  0     1   Special LZMA properties for compressed data
+  1     4   Dictionary size (little endian)
+  5     8   Uncompressed size (little endian). -1 means unknown size
+ 13         Compressed data
+
+
+ANSI-C LZMA Decoder
+~~~~~~~~~~~~~~~~~~~
+
+To compile ANSI-C LZMA Decoder you can use one of the following files sets:
+1) LzmaDecode.h + LzmaDecode.c + LzmaTest.c  (fastest version)
+2) LzmaDecode.h + LzmaDecodeSize.c + LzmaTest.c  (old size-optimized version)
+3) LzmaStateDecode.h + LzmaStateDecode.c + LzmaStateTest.c  (zlib-like interface)
+
+
+Memory requirements for LZMA decoding
+-------------------------------------
+
+LZMA decoder doesn't allocate memory itself, so you must 
+allocate memory and send it to LZMA.
+
+Stack usage of LZMA decoding function for local variables is not 
+larger than 200 bytes.
+
+How To decompress data
+----------------------
+
+LZMA Decoder (ANSI-C version) now supports 5 interfaces:
+1) Single-call Decompressing
+2) Single-call Decompressing with input stream callback
+3) Multi-call Decompressing with output buffer
+4) Multi-call Decompressing with input callback and output buffer
+5) Multi-call State Decompressing (zlib-like interface)
+
+Variant-5 is similar to Variant-4, but Variant-5 doesn't use callback functions.
+
+Decompressing steps
+-------------------
+
+1) read LZMA properties (5 bytes):
+   unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+2) read uncompressed size (8 bytes, little-endian)
+
+3) Decode properties:
+
+  CLzmaDecoderState state;  /* it's 24-140 bytes structure, if int is 32-bit */
+
+  if (LzmaDecodeProperties(&amp;state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+    return PrintError(rs, &quot;Incorrect stream properties&quot;);
+
+4) Allocate memory block for internal Structures:
+
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&amp;state.Properties) * sizeof(CProb));
+  if (state.Probs == 0)
+    return PrintError(rs, kCantAllocateMessage);
+
+  LZMA decoder uses array of CProb variables as internal structure.
+  By default, CProb is unsigned_short. But you can define _LZMA_PROB32 to make 
+  it unsigned_int. It can increase speed on some 32-bit CPUs, but memory 
+  usage will be doubled in that case.
+
+
+5) Main Decompressing
+
+You must use one of the following interfaces:
+
+5.1 Single-call Decompressing
+-----------------------------
+When to use: RAM-&gt;RAM decompressing
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: no defines
+Memory Requirements:
+  - Input buffer: compressed size
+  - Output buffer: uncompressed size
+  - LZMA Internal Structures (~16 KB for default settings) 
+
+Interface:
+  int res = LzmaDecode(&amp;state, 
+      inStream, compressedSize, &amp;inProcessed,
+      outStream, outSize, &amp;outProcessed);
+
+
+5.2 Single-call Decompressing with input stream callback
+--------------------------------------------------------
+When to use: File-&gt;RAM or Flash-&gt;RAM decompressing.
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: _LZMA_IN_CB
+Memory Requirements:
+  - Buffer for input stream: any size (for example, 16 KB)
+  - Output buffer: uncompressed size
+  - LZMA Internal Structures (~16 KB for default settings) 
+
+Interface:
+  typedef struct _CBuffer
+  {
+    ILzmaInCallback InCallback;
+    FILE *File;
+    unsigned char Buffer[kInBufferSize];
+  } CBuffer;
+
+  int LzmaReadCompressed(void *object, const unsigned char **buffer, SizeT *size)
+  {
+    CBuffer *bo = (CBuffer *)object;
+    *buffer = bo-&gt;Buffer;
+    *size = MyReadFile(bo-&gt;File, bo-&gt;Buffer, kInBufferSize);
+    return LZMA_RESULT_OK;
+  }
+
+  CBuffer g_InBuffer;
+
+  g_InBuffer.File = inFile;
+  g_InBuffer.InCallback.Read = LzmaReadCompressed;
+  int res = LzmaDecode(&amp;state, 
+      &amp;g_InBuffer.InCallback,
+      outStream, outSize, &amp;outProcessed);
+
+
+5.3 Multi-call decompressing with output buffer
+-----------------------------------------------
+When to use: RAM-&gt;File decompressing 
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: _LZMA_OUT_READ
+Memory Requirements:
+ - Input buffer: compressed size
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures (~16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in stream properties)
+ 
+Interface:
+
+  state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+
+  LzmaDecoderInit(&amp;state);
+  do
+  {
+    LzmaDecode(&amp;state,
+      inBuffer, inAvail, &amp;inProcessed,
+      g_OutBuffer, outAvail, &amp;outProcessed);
+    inAvail -= inProcessed;
+    inBuffer += inProcessed;
+  }
+  while you need more bytes
+
+  see LzmaTest.c for more details.
+
+
+5.4 Multi-call decompressing with input callback and output buffer
+------------------------------------------------------------------
+When to use: File-&gt;File decompressing 
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: _LZMA_IN_CB, _LZMA_OUT_READ
+Memory Requirements:
+ - Buffer for input stream: any size (for example, 16 KB)
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures (~16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in stream properties)
+ 
+Interface:
+
+  state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+ 
+  LzmaDecoderInit(&amp;state);
+  do
+  {
+    LzmaDecode(&amp;state,
+      &amp;bo.InCallback,
+      g_OutBuffer, outAvail, &amp;outProcessed);
+  }
+  while you need more bytes
+
+  see LzmaTest.c for more details:
+
+
+5.5 Multi-call State Decompressing (zlib-like interface)
+------------------------------------------------------------------
+When to use: file-&gt;file decompressing 
+Compile files: LzmaStateDecode.h, LzmaStateDecode.c
+Compile defines:
+Memory Requirements:
+ - Buffer for input stream: any size (for example, 16 KB)
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures (~16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in stream properties)
+ 
+Interface:
+
+  state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+
+  
+  LzmaDecoderInit(&amp;state);
+  do
+  {
+    res = LzmaDecode(&amp;state,
+      inBuffer, inAvail, &amp;inProcessed,
+      g_OutBuffer, outAvail, &amp;outProcessed,
+      finishDecoding);
+    inAvail -= inProcessed;
+    inBuffer += inProcessed;
+  }
+  while you need more bytes
+
+  see LzmaStateTest.c for more details:
+
+
+6) Free all allocated blocks
+
+
+Note
+----
+LzmaDecodeSize.c is size-optimized version of LzmaDecode.c.
+But compiled code of LzmaDecodeSize.c can be larger than 
+compiled code of LzmaDecode.c. So it's better to use 
+LzmaDecode.c in most cases.
+
+
+EXIT codes
+-----------
+
+LZMA decoder can return one of the following codes:
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+If you use callback function for input data and you return some 
+error code, LZMA Decoder also returns that code.
+
+
+
+LZMA Defines
+------------
+
+_LZMA_IN_CB    - Use callback for input data
+
+_LZMA_OUT_READ - Use read function for output data
+
+_LZMA_LOC_OPT  - Enable local speed optimizations inside code.
+                 _LZMA_LOC_OPT is only for LzmaDecodeSize.c (size-optimized version).
+                 _LZMA_LOC_OPT doesn't affect LzmaDecode.c (speed-optimized version)
+                 and LzmaStateDecode.c
+
+_LZMA_PROB32   - It can increase speed on some 32-bit CPUs, 
+                 but memory usage will be doubled in that case
+
+_LZMA_UINT32_IS_ULONG  - Define it if int is 16-bit on your compiler
+                         and long is 32-bit.
+
+_LZMA_SYSTEM_SIZE_T  - Define it if you want to use system's size_t.
+                       You can use it to enable 64-bit sizes supporting
+
+
+
+C++ LZMA Encoder/Decoder 
+~~~~~~~~~~~~~~~~~~~~~~~~
+C++ LZMA code use COM-like interfaces. So if you want to use it, 
+you can study basics of COM/OLE.
+
+By default, LZMA Encoder contains all Match Finders.
+But for compressing it's enough to have just one of them.
+So for reducing size of compressing code you can define:
+  #define COMPRESS_MF_BT
+  #define COMPRESS_MF_BT4
+and it will use only bt4 match finder.
+
+
+---
+
+<A HREF="http://www.7-zip.org">http://www.7-zip.org</A>
+<A HREF="http://www.7-zip.org/support.html">http://www.7-zip.org/support.html</A>


Property changes on: trunk/Marvell/Src/uClinux-dist/lzma/lzma.txt
___________________________________________________________________
Name: svn:executable
   + *


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000139.html">[Wl530g-svncheckins] r353 - in	trunk/Marvell/Src/uClinux-dist/linux-2.4.x:	arch/armnommu/boot/compressed lib
</A></li>
	<LI>Next message: <A HREF="000141.html">[Wl530g-svncheckins] r355 - trunk/Marvell/Src/uClinux-dist/lzma
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#140">[ date ]</a>
              <a href="thread.html#140">[ thread ]</a>
              <a href="subject.html#140">[ subject ]</a>
              <a href="author.html#140">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/wl530g-svncheckins">More information about the Wl530g-svncheckins
mailing list</a><br>
</body></html>
